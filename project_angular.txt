

--- FILE: @fwk/auth/abstract-auth.service.ts ---

import { Observable } from 'rxjs';

export interface SignInData {
    username: string;
    password: string;
    [key: string]: any;
}

export abstract class AbstractAuthService {
    abstract readonly authenticated$: Observable<boolean>;

    abstract signIn(credentials: SignInData): Observable<any>;
    abstract signOut(): Observable<any>;
    abstract check(): Observable<boolean>;
    abstract refreshToken(): Observable<any>;
    abstract hasPermission(permission?: string): boolean;
    abstract getToken(): string | null;
}

--- FILE: @fwk/auth/auth.interceptor.ts ---

import { HttpErrorResponse, HttpEvent, HttpHandlerFn, HttpRequest } from '@angular/common/http';
import { inject } from '@angular/core';
import { Observable, throwError } from 'rxjs';
import { catchError, switchMap } from 'rxjs/operators';
import { NotificationService } from '@fwk/services/notification/notification.service';
import { AbstractAuthService } from './abstract-auth.service';
import { I18nService } from '@fwk/services/i18n-service/i18n.service';

export const authInterceptor = (req: HttpRequest<unknown>, next: HttpHandlerFn): Observable<HttpEvent<unknown>> => {
    const authService = inject(AbstractAuthService);
    const notificationService = inject(NotificationService);
    const i18nService = inject(I18nService);
    const token = authService.getToken();

    let authReq = req;
    if (token) {
        authReq = addTokenHeader(req, token);
    }

    return next(authReq).pipe(
        catchError((error) => {
            if (error instanceof HttpErrorResponse && error.status === 401 && token) {
                return handle401Error(authReq, next);
            }

            if (error instanceof HttpErrorResponse && error.status === 401) {
                const errorMessage = i18nService.getDictionary('fwk')?.translate?.('interceptor_session_expired_relogin') ?? 'interceptor_session_expired_relogin';
                notificationService.notifyError(errorMessage);
                authService.signOut().subscribe();
            }

            return throwError(() => error);
        })
    );
};

const addTokenHeader = (request: HttpRequest<any>, token: string) => {
    return request.clone({
        headers: request.headers.set('Authorization', `Bearer ${token}`),
    });
};

const handle401Error = (req: HttpRequest<any>, next: HttpHandlerFn): Observable<HttpEvent<any>> => {
    const authService = inject(AbstractAuthService);
    const i18nService = inject(I18nService);

    return authService.refreshToken().pipe(
        switchMap((tokenResponse: any) => {
            return next(addTokenHeader(req, tokenResponse.token));
        }),
        catchError((err) => {
            authService.signOut().subscribe();
            const errorMessage = i18nService.getDictionary('fwk')?.translate?.('interceptor_session_expired_no_renew') ?? 'interceptor_session_expired_no_renew';
            return throwError(() => new Error(errorMessage));
        })
    );
};

--- FILE: @fwk/auth/auth.provider.ts ---

import { EnvironmentProviders, Provider } from '@angular/core';
import { provideHttpClient, withInterceptors } from '@angular/common/http';
import { authInterceptor } from '@fwk/auth/auth.interceptor';
import { AuthService } from '@fwk/auth/auth.service';
import { AbstractAuthService } from '@fwk/auth/abstract-auth.service';

export const provideAppAuth = (): Array<Provider | EnvironmentProviders> =>
{
    return [
        {
            provide: AbstractAuthService,
            useClass: AuthService
        }
    ];
};

export const provideFwkAuth = (): Array<Provider | EnvironmentProviders> =>
{
    return [
        provideHttpClient(withInterceptors([authInterceptor])),
    ];
};

--- FILE: @fwk/auth/auth.service.ts ---

import { Injectable, inject } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { Router } from '@angular/router';
import { Observable, switchMap, of, BehaviorSubject, throwError, catchError, tap, finalize, take, filter } from 'rxjs';
import { User } from '@fwk/auth/user.types';
import { UserService } from '@fwk/auth/user.service';
import { environment } from 'environments/environment';
import { AuthUtils } from '@fwk/auth/auth.utils';
import { AbstractAuthService, SignInData } from '@fwk/auth/abstract-auth.service';
import { I18nService } from '@fwk/services/i18n-service/i18n.service';

@Injectable({ providedIn: 'root' })
export class AuthService implements AbstractAuthService {
    private _httpClient = inject(HttpClient);
    private _router = inject(Router);
    private _userService = inject(UserService);
    private _i18nService = inject(I18nService);

    private _authenticated: BehaviorSubject<boolean> = new BehaviorSubject<boolean>(false);
    private _userPermissions: Set<string> = new Set<string>();

    private isRefreshing = false;
    private refreshTokenSubject: BehaviorSubject<any> = new BehaviorSubject<any>(null);

    private readonly TOKEN_KEY = 'accessToken';
    private readonly USER_DATA_KEY = 'currentUser';

    get authenticated$(): Observable<boolean> { return this._authenticated.asObservable(); }

    signIn(credentials: SignInData): Observable<any> {
        return this._httpClient.post(environment.auth.signIn, credentials, { responseType: 'json' }).pipe(
            tap((responseFromApi: any) => {

                const accessToken = responseFromApi.token;
                const refreshTokenValue = responseFromApi.refreshToken;

                if (!accessToken || typeof accessToken !== 'string') {
                    console.error('La respuesta de la API de login no contiene un "token" válido.', responseFromApi);
                    throw new Error('Respuesta de autenticación inválida.');
                }

                const emailNotSpecified = this._i18nService.getDictionary('fwk')?.translate?.('auth_email_not_specified') ?? 'auth_email_not_specified';

                const userForFuse: User = {
                    id: responseFromApi.guid,
                    name: responseFromApi.username,
                    email: responseFromApi.email || emailNotSpecified,
                    avatar: null,
                    status: 'online',
                    permisos: responseFromApi.permisos ? responseFromApi.permisos.split(';') : [],
                    refreshToken: refreshTokenValue || accessToken
                };

                this.setToken(accessToken);
                this.setUser(userForFuse);

                this._authenticated.next(true);
                this._userService.user = userForFuse;
                this._userPermissions = new Set(userForFuse.permisos);
            }),
            catchError((error) => throwError(() => error))
        );
    }

    signOut(): Observable<any> {
        this.clearLocalStorageAndState();
        return of(true);
    }

    check(): Observable<boolean> {
        if (this._authenticated.value) {
            return of(true);
        }

        const token = this.getToken();
        if (!token) {
            return of(false);
        }

        if (AuthUtils.isTokenExpired(token, 60)) {
            return this.refreshToken().pipe(
                switchMap(() => this.checkUserAndPermissions()),
                catchError(() => {
                    this.clearLocalStorageAndState();
                    return of(false);
                })
            );
        }

        return this.checkUserAndPermissions();
    }

    private checkUserAndPermissions(): Observable<boolean> {
        const user = this.getUserFromLocalStorage();
        if (!user || !user.id || !user.name) {
            this.clearLocalStorageAndState();
            return of(false);
        }

        this._authenticated.next(true);
        this._userService.user = user;
        this._userPermissions = new Set(user.permisos || []);
        return of(true);
    }

    refreshToken(): Observable<any> {
        if (this.isRefreshing) {
            return this.refreshTokenSubject.pipe(
                filter(token => token !== null),
                take(1)
            );
        } else {
            this.isRefreshing = true;
            this.refreshTokenSubject.next(null);

            const user = this.getUserFromLocalStorage();
            const refreshToken = user?.refreshToken;

            if (!refreshToken) {
                this.isRefreshing = false;
                return throwError(() => new Error('No refresh token available.'));
            }

            return this._httpClient.post<any>(environment.auth.refreshToken, { token: refreshToken }).pipe(
                tap((response: any) => {
                    const newAccessToken = response.token;
                    if (!newAccessToken || typeof newAccessToken !== 'string') {
                        console.error('La respuesta de la API de refresh token no contiene un "token" válido.', response);
                        throw new Error('Respuesta de refresh token inválida.');
                    }

                    this.setToken(newAccessToken);

                    if (response.refreshToken && user) {
                        user.refreshToken = response.refreshToken;
                        this.setUser(user);
                    }
                    this.refreshTokenSubject.next(newAccessToken);
                }),
                catchError((error) => {
                    this.signOut().subscribe();
                    return throwError(() => error);
                }),
                finalize(() => {
                    this.isRefreshing = false;
                })
            );
        }
    }

    hasPermission(permission?: string): boolean {
        if (!environment.production) {
            return true;
        }
        if (!permission) {
            return true;
        }
        return this._userPermissions.has(permission);
    }

    private clearLocalStorageAndState(): void {
        localStorage.removeItem(this.TOKEN_KEY);
        localStorage.removeItem(this.USER_DATA_KEY);
        this._authenticated.next(false);
        if (this._userService) {
            this._userService.user = null;
        }
        this._userPermissions.clear();
    }

    forgotPassword(email: string): Observable<any> {
        return this._httpClient.post(environment.auth.forgotPassword, { email });
    }
    resetPassword(data: any): Observable<any> {
        return this._httpClient.post(environment.auth.resetPassword, data);
    }
    signUp(data: any): Observable<any> {
        return this._httpClient.post(environment.auth.signUp, data);
    }
    unlockSession(data: { email: string; password: string }): Observable<any> {
        return this.signIn({ username: data.email, password: data.password });
    }

    getToken(): string | null { return localStorage.getItem(this.TOKEN_KEY); }
    private setToken(token: string): void { localStorage.setItem(this.TOKEN_KEY, token); }
    private setUser(user: User): void { localStorage.setItem(this.USER_DATA_KEY, JSON.stringify(user)); }
    getUserFromLocalStorage(): User | null {
        const userData = localStorage.getItem(this.USER_DATA_KEY);
        return userData ? JSON.parse(userData) : null;
    }
}

--- FILE: @fwk/auth/auth.utils.ts ---

export class AuthUtils
{
    /**
     * Is token expired?
     *
     * @param token
     * @param offsetSeconds
     */
    static isTokenExpired(token: string, offsetSeconds?: number): boolean
    {
        if ( !token || token === '' ) {
            return true;
        }

        const date = this._getTokenExpirationDate(token);
        offsetSeconds = offsetSeconds || 0;

        if ( date === null ) {
            return true;
        }

        return !(date.valueOf() > new Date().valueOf() + offsetSeconds * 1000);
    }

    private static _b64decode(str: string): string
    {
        const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
        let output = '';
        str = String(str).replace(/=+$/, '');
        if ( str.length % 4 === 1 ) {
            throw new Error('\'atob\' failed: The string to be decoded is not correctly encoded.');
        }
        for (
            let bc = 0, bs: any, buffer: any, idx = 0;
            (buffer = str.charAt(idx++));
            ~buffer &&
            ((bs = bc % 4 ? bs * 64 + buffer : buffer),
            bc++ % 4)
                ? (output += String.fromCharCode(255 & (bs >> ((-2 * bc) & 6))))
                : 0
        )
        {
            buffer = chars.indexOf(buffer);
        }
        return output;
    }

    private static _b64DecodeUnicode(str: any): string
    {
        return decodeURIComponent(
            Array.prototype.map
                .call(this._b64decode(str), (c: any) => '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2))
                .join(''),
        );
    }

    private static _urlBase64Decode(str: string): string
    {
        let output = str.replace(/-/g, '+').replace(/_/g, '/');
        switch ( output.length % 4 )
        {
            case 0: { break; }
            case 2: { output += '=='; break; }
            case 3: { output += '='; break; }
            default: { throw Error('Illegal base64url string!'); }
        }
        return this._b64DecodeUnicode(output);
    }

    private static _decodeToken(token: string): any
    {
        if ( !token ) {
            return null;
        }
        const parts = token.split('.');
        if ( parts.length !== 3 ) {
            throw new Error('The inspected token doesn\'t appear to be a JWT.');
        }
        const decoded = this._urlBase64Decode(parts[1]);
        if ( !decoded ) {
            throw new Error('Cannot decode the token.');
        }
        return JSON.parse(decoded);
    }

    private static _getTokenExpirationDate(token: string): Date | null
    {
        const decodedToken = this._decodeToken(token);
        if ( !decodedToken.hasOwnProperty('exp') ) {
            return null;
        }
        const date = new Date(0);
        date.setUTCSeconds(decodedToken.exp);
        return date;
    }
}

--- FILE: @fwk/auth/components/confirmation-required/confirmation-required.component.html ---

<div class="flex flex-col sm:flex-row items-center md:items-start sm:justify-center md:justify-start flex-auto min-w-0">
    <div class="md:flex md:items-center md:justify-end w-full sm:w-auto md:h-full md:w-1/2 py-8 px-4 sm:p-12 md:p-16 sm:rounded-2xl md:rounded-none sm:shadow md:shadow-none sm:bg-card">
        <div class="w-full max-w-80 sm:w-80 mx-auto sm:mx-0">
            <!-- Logo -->
            <div class="w-12">
                <img src="https://premecsa.com.ar/wp-content/uploads/2018/05/logo-pestan%CC%83a-01.png">
            </div>

            <!-- Title -->
            <div class="mt-8 text-4xl font-extrabold tracking-tight leading-tight">{{ 'confirmation_required_title' | translate }}</div>
            <div class="mt-4">
                {{ 'confirmation_required_subtitle' | translate }}
            </div>

            <!-- Form footer -->
            <div class="mt-8 text-md font-medium text-secondary">
                <span>{{ 'return_to' | translate }}</span>
                <a
                    class="ml-1 text-primary-500 hover:underline"
                    [routerLink]="['/sign-in']">{{ 'sign_in_link' | translate }}
                </a>
            </div>
        </div>
    </div>
    <div class="relative hidden md:flex flex-auto items-center justify-center w-1/2 h-full p-16 lg:px-28 overflow-hidden bg-gray-800 dark:border-l">
        <!-- Background - @formatter:off -->
        <!-- Rings -->
        <svg class="absolute inset-0 pointer-events-none"
             viewBox="0 0 960 540" width="100%" height="100%" preserveAspectRatio="xMidYMax slice" xmlns="http://www.w3.org/2000/svg">
            <g class="text-gray-700 opacity-25" fill="none" stroke="currentColor" stroke-width="100">
                <circle r="234" cx="196" cy="23"></circle>
                <circle r="234" cx="790" cy="491"></circle>
            </g>
        </svg>
        <!-- Dots -->
        <svg class="absolute -top-16 -right-16 text-gray-700"
             viewBox="0 0 220 192" width="220" height="192" fill="none">
            <defs>
                <pattern id="837c3e70-6c3a-44e6-8854-cc48c737b659" x="0" y="0" width="20" height="20" patternUnits="userSpaceOnUse">
                    <rect x="0" y="0" width="4" height="4" fill="currentColor"></rect>
                </pattern>
            </defs>
            <rect width="220" height="192" fill="url(#837c3e70-6c3a-44e6-8854-cc48c737b659)"></rect>
        </svg>
        <!-- @formatter:on -->
        <!-- Content -->
        <div class="z-10 relative w-full max-w-2xl">
            <div class="text-7xl font-bold leading-none text-gray-100">
                <div>{{ 'welcome_to' | translate }}</div>
                <div>{{ 'our_community' | translate }}</div>
            </div>
            <div class="mt-6 text-lg tracking-tight leading-6 text-gray-400">
                {{ 'template_description' | translate }}
            </div>
            <div class="flex items-center mt-8">
                <div class="flex flex-0 items-center -space-x-1.5">
                    <img
                        class="flex-0 w-10 h-10 rounded-full ring-4 ring-offset-1 ring-gray-800 ring-offset-gray-800 object-cover"
                        src="assets/images/avatars/female-18.jpg">
                    <img
                        class="flex-0 w-10 h-10 rounded-full ring-4 ring-offset-1 ring-gray-800 ring-offset-gray-800 object-cover"
                        src="assets/images/avatars/female-11.jpg">
                    <img
                        class="flex-0 w-10 h-10 rounded-full ring-4 ring-offset-1 ring-gray-800 ring-offset-gray-800 object-cover"
                        src="assets/images/avatars/male-09.jpg">
                    <img
                        class="flex-0 w-10 h-10 rounded-full ring-4 ring-offset-1 ring-gray-800 ring-offset-gray-800 object-cover"
                        src="assets/images/avatars/male-16.jpg">
                </div>
                <div class="ml-4 font-medium tracking-tight text-gray-400">{{ 'template_join_us' | translate }}</div>
            </div>
        </div>
    </div>
</div>

--- FILE: @fwk/auth/components/confirmation-required/confirmation-required.component.ts ---

import { Component, ViewEncapsulation } from '@angular/core';
import { RouterLink } from '@angular/router';
import { fuseAnimations } from '@fuse/animations';
import { TranslatePipe } from '@fwk/pipe/translate.pipe';

@Component({
    selector     : 'auth-confirmation-required',
    templateUrl  : './confirmation-required.component.html',
    encapsulation: ViewEncapsulation.None,
    animations   : fuseAnimations,
    standalone   : true,
    imports      : [RouterLink, TranslatePipe],
})
export class AuthConfirmationRequiredComponent
{
    /**
     * Constructor
     */
    constructor()
    {
    }
}

--- FILE: @fwk/auth/components/confirmation-required/confirmation-required.routes.ts ---

import { Routes } from '@angular/router';
import { AuthConfirmationRequiredComponent } from '@fwk/auth/components/confirmation-required/confirmation-required.component';

export default [
    {
        path     : '',
        component: AuthConfirmationRequiredComponent,
    },
] as Routes;


--- FILE: @fwk/auth/components/forgot-password/forgot-password.component.html ---

<div class="flex flex-col sm:flex-row items-center md:items-start sm:justify-center md:justify-start flex-auto min-w-0">
    <div class="md:flex md:items-center md:justify-end w-full sm:w-auto md:h-full md:w-1/2 py-8 px-4 sm:p-12 md:p-16 sm:rounded-2xl md:rounded-none sm:shadow md:shadow-none sm:bg-card">
        <div class="w-full max-w-80 sm:w-80 mx-auto sm:mx-0">
            <!-- Logo -->
            <div class="w-12">
                <img src="https://premecsa.com.ar/wp-content/uploads/2018/05/logo-pestan%CC%83a-01.png">
            </div>

            <!-- Title -->
            <div class="mt-8 text-4xl font-extrabold tracking-tight leading-tight">{{ 'forgot_password_title' | translate }}</div>
            <div class="mt-0.5 font-medium">{{ 'forgot_password_subtitle' | translate }}</div>

            <!-- Alert -->
            <fuse-alert
                class="mt-8"
                *ngIf="showAlert"
                [appearance]="'outline'"
                [showIcon]="false"
                [type]="alert.type"
                [@shake]="alert.type === 'error'">
                {{alert.message}}
            </fuse-alert>

            <!-- Forgot password form -->
            <form
                class="mt-8"
                [formGroup]="forgotPasswordForm"
                #forgotPasswordNgForm="ngForm">

                <!-- Email field -->
                <mat-form-field class="w-full">
                    <mat-label>{{ 'email_address_label' | translate }}</mat-label>
                    <input
                        id="email"
                        matInput
                        [formControlName]="'email'">
                    <mat-error *ngIf="forgotPasswordForm.get('email').hasError('required')">
                        {{ 'email_address_required_error' | translate }}
                    </mat-error>
                    <mat-error *ngIf="forgotPasswordForm.get('email').hasError('email')">
                        {{ 'email_address_invalid_error' | translate }}
                    </mat-error>
                </mat-form-field>

                <!-- Submit button -->
                <button
                    class="fuse-mat-button-large w-full mt-3"
                    mat-flat-button
                    color="accent"
                    [disabled]="forgotPasswordForm.disabled"
                    (click)="sendResetLink()">
                    <span *ngIf="!forgotPasswordForm.disabled">
                        {{ 'send_reset_link_button' | translate }}
                    </span>
                    <mat-progress-spinner
                        *ngIf="forgotPasswordForm.disabled"
                        [diameter]="24"
                        [mode]="'indeterminate'"></mat-progress-spinner>
                </button>

                <!-- Form footer -->
                <div class="mt-8 text-md font-medium text-secondary">
                    <span>{{ 'return_to' | translate }}</span>
                    <a
                        class="ml-1 text-primary-500 hover:underline"
                        [routerLink]="['/sign-in']">{{ 'sign_in_link' | translate }}
                    </a>
                </div>

            </form>
        </div>
    </div>
    <div class="relative hidden md:flex flex-auto items-center justify-center w-1/2 h-full p-16 lg:px-28 overflow-hidden bg-gray-800 dark:border-l">
        <!-- Background - @formatter:off -->
        <!-- Rings -->
        <svg class="absolute inset-0 pointer-events-none"
             viewBox="0 0 960 540" width="100%" height="100%" preserveAspectRatio="xMidYMax slice" xmlns="http://www.w3.org/2000/svg">
            <g class="text-gray-700 opacity-25" fill="none" stroke="currentColor" stroke-width="100">
                <circle r="234" cx="196" cy="23"></circle>
                <circle r="234" cx="790" cy="491"></circle>
            </g>
        </svg>
        <!-- Dots -->
        <svg class="absolute -top-16 -right-16 text-gray-700"
             viewBox="0 0 220 192" width="220" height="192" fill="none">
            <defs>
                <pattern id="837c3e70-6c3a-44e6-8854-cc48c737b659" x="0" y="0" width="20" height="20" patternUnits="userSpaceOnUse">
                    <rect x="0" y="0" width="4" height="4" fill="currentColor"></rect>
                </pattern>
            </defs>
            <rect width="220" height="192" fill="url(#837c3e70-6c3a-44e6-8854-cc48c737b659)"></rect>
        </svg>
        <!-- @formatter:on -->
        <!-- Content -->
        <div class="z-10 relative w-full max-w-2xl">
            <div class="text-7xl font-bold leading-none text-gray-100">
                <div>{{ 'welcome_to' | translate }}</div>
                <div>{{ 'our_community' | translate }}</div>
            </div>
            <div class="mt-6 text-lg tracking-tight leading-6 text-gray-400">
                {{ 'template_description' | translate }}
            </div>
            <div class="flex items-center mt-8">
                <div class="flex flex-0 items-center -space-x-1.5">
                    <img
                        class="flex-0 w-10 h-10 rounded-full ring-4 ring-offset-1 ring-gray-800 ring-offset-gray-800 object-cover"
                        src="assets/images/avatars/female-18.jpg">
                    <img
                        class="flex-0 w-10 h-10 rounded-full ring-4 ring-offset-1 ring-gray-800 ring-offset-gray-800 object-cover"
                        src="assets/images/avatars/female-11.jpg">
                    <img
                        class="flex-0 w-10 h-10 rounded-full ring-4 ring-offset-1 ring-gray-800 ring-offset-gray-800 object-cover"
                        src="assets/images/avatars/male-09.jpg">
                    <img
                        class="flex-0 w-10 h-10 rounded-full ring-4 ring-offset-1 ring-gray-800 ring-offset-gray-800 object-cover"
                        src="assets/images/avatars/male-16.jpg">
                </div>
                <div class="ml-4 font-medium tracking-tight text-gray-400">{{ 'template_join_us' | translate }}</div>
            </div>
        </div>
    </div>
</div>

--- FILE: @fwk/auth/components/forgot-password/forgot-password.component.ts ---

import { NgIf } from '@angular/common';
import { Component, OnInit, ViewChild, ViewEncapsulation, inject } from '@angular/core';
import { FormsModule, NgForm, ReactiveFormsModule, FormBuilder, FormGroup, Validators, FormControl } from '@angular/forms';
import { MatButtonModule } from '@angular/material/button';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatInputModule } from '@angular/material/input';
import { MatProgressSpinnerModule } from '@angular/material/progress-spinner';
import { RouterLink } from '@angular/router';
import { fuseAnimations } from '@fuse/animations';
import { FuseAlertComponent, FuseAlertType } from '@fuse/components/alert';
import { AuthService } from '@fwk/auth/auth.service';
import { I18nService } from '@fwk/services/i18n-service/i18n.service';
import { TranslatePipe } from '@fwk/pipe/translate.pipe';
import { finalize } from 'rxjs';

interface ForgotPasswordForm {
    email: FormControl<string>;
}

@Component({
    selector: 'auth-forgot-password',
    templateUrl: './forgot-password.component.html',
    encapsulation: ViewEncapsulation.None,
    animations: fuseAnimations,
    standalone: true,
    imports: [NgIf, FuseAlertComponent, FormsModule, ReactiveFormsModule, MatFormFieldModule, MatInputModule, MatButtonModule, MatProgressSpinnerModule, RouterLink, TranslatePipe],
})
export class AuthForgotPasswordComponent implements OnInit {
    @ViewChild('forgotPasswordNgForm') forgotPasswordNgForm: NgForm;

    alert: { type: FuseAlertType; message: string } = {
        type: 'success',
        message: '',
    };
    forgotPasswordForm: FormGroup<ForgotPasswordForm>;
    showAlert: boolean = false;
    private _translatePipe = new TranslatePipe(inject(I18nService));

    constructor(
        private _authService: AuthService,
        private _formBuilder: FormBuilder,
    ) {
    }

    ngOnInit(): void {
        this.forgotPasswordForm = this._formBuilder.group({
            email: ['', [Validators.required, Validators.email]],
        });
    }

    sendResetLink(): void {
        if (this.forgotPasswordForm.invalid) {
            return;
        }

        this.forgotPasswordForm.disable();
        this.showAlert = false;

        this._authService.forgotPassword(this.forgotPasswordForm.get('email').value)
            .pipe(
                finalize(() => {
                    this.forgotPasswordForm.enable();
                    this.forgotPasswordNgForm.resetForm();
                    this.showAlert = true;
                }),
            )
            .subscribe(
                (response) => {
                    this.alert = {
                        type: 'success',
                        message: this._translatePipe.transform('forgot_password_success_message'),
                    };
                },
                (response) => {
                    this.alert = {
                        type: 'error',
                        message: this._translatePipe.transform('forgot_password_error_message'),
                    };
                },
            );
    }
}

--- FILE: @fwk/auth/components/forgot-password/forgot-password.routes.ts ---

import { Routes } from '@angular/router';
import { AuthForgotPasswordComponent } from '@fwk/auth/components/forgot-password/forgot-password.component';

export default [
    {
        path     : '',
        component: AuthForgotPasswordComponent,
    },
] as Routes;


--- FILE: @fwk/auth/components/reset-password/reset-password.component.html ---

<div class="flex flex-col sm:flex-row items-center md:items-start sm:justify-center md:justify-start flex-auto min-w-0">
    <div
        class="md:flex md:items-center md:justify-end w-full sm:w-auto md:h-full md:w-1/2 py-8 px-4 sm:p-12 md:p-16 sm:rounded-2xl md:rounded-none sm:shadow md:shadow-none sm:bg-card">
        <div class="w-full max-w-80 sm:w-80 mx-auto sm:mx-0">
            <!-- Logo -->
            <div class="w-12">
                <img src="https://premecsa.com.ar/wp-content/uploads/2018/05/logo-pestan%CC%83a-01.png">
            </div>

            <!-- Title -->
            <div class="mt-8 text-4xl font-extrabold tracking-tight leading-tight">{{ 'reset_password_title' | translate
                }}</div>
            <div class="mt-0.5 font-medium">{{ 'reset_password_subtitle' | translate }}</div>

            <!-- Alert -->
            <fuse-alert class="mt-8" *ngIf="showAlert" [appearance]="'outline'" [showIcon]="false" [type]="alert.type"
                [@shake]="alert.type === 'error'">
                {{alert.message}}
            </fuse-alert>

            <!-- Reset password form -->
            <form class="mt-8" [formGroup]="resetPasswordForm" #resetPasswordNgForm="ngForm">

                <!-- Password field -->
                <mat-form-field class="w-full">
                    <mat-label>{{ 'password_label' | translate }}</mat-label>
                    <input id="password" matInput type="password" [formControlName]="'password'" #passwordField>
                    <button mat-icon-button type="button"
                        (click)="passwordField.type === 'password' ? passwordField.type = 'text' : passwordField.type = 'password'"
                        matSuffix>
                        <mat-icon class="icon-size-5" *ngIf="passwordField.type === 'password'"
                            [svgIcon]="'heroicons_solid:eye'"></mat-icon>
                        <mat-icon class="icon-size-5" *ngIf="passwordField.type === 'text'"
                            [svgIcon]="'heroicons_solid:eye-slash'"></mat-icon>
                    </button>
                    <mat-error>
                        {{ 'password_required_error' | translate }}
                    </mat-error>
                </mat-form-field>

                <!-- Password confirm field -->
                <mat-form-field class="w-full">
                    <mat-label>{{ 'password_confirm_label' | translate }}</mat-label>
                    <input id="password-confirm" matInput type="password" [formControlName]="'passwordConfirm'"
                        #passwordConfirmField>
                    <button mat-icon-button type="button"
                        (click)="passwordConfirmField.type === 'password' ? passwordConfirmField.type = 'text' : passwordConfirmField.type = 'password'"
                        matSuffix>
                        <mat-icon class="icon-size-5" *ngIf="passwordConfirmField.type === 'password'"
                            [svgIcon]="'heroicons_solid:eye'"></mat-icon>
                        <mat-icon class="icon-size-5" *ngIf="passwordConfirmField.type === 'text'"
                            [svgIcon]="'heroicons_solid:eye-slash'"></mat-icon>
                    </button>
                    <mat-error *ngIf="resetPasswordForm.get('passwordConfirm').hasError('required')">
                        {{ 'password_confirm_required_error' | translate }}
                    </mat-error>
                    <mat-error *ngIf="resetPasswordForm.get('passwordConfirm').hasError('mustMatch')">
                        {{ 'passwords_must_match_error' | translate }}
                    </mat-error>
                </mat-form-field>

                <!-- Submit button -->
                <button class="fuse-mat-button-large w-full mt-3" mat-flat-button color="accent"
                    [disabled]="resetPasswordForm.disabled" (click)="resetPassword()">
                    <span *ngIf="!resetPasswordForm.disabled">{{ 'reset_your_password_button' | translate }}</span>
                    <mat-progress-spinner *ngIf="resetPasswordForm.disabled" [diameter]="24"
                        [mode]="'indeterminate'"></mat-progress-spinner>
                </button>

                <!-- Form footer -->
                <div class="mt-8 text-md font-medium text-secondary">
                    <span>{{ 'return_to' | translate }}</span>
                    <a class="ml-1 text-primary-500 hover:underline"
                       [routerLink]="['/sign-in']">{{ 'sign_in_link' | translate }}</a>
                </div>

            </form>
        </div>
    </div>
    <div
        class="relative hidden md:flex flex-auto items-center justify-center w-1/2 h-full p-16 lg:px-28 overflow-hidden bg-gray-800 dark:border-l">
        <!-- Background - @formatter:off -->
        <!-- Rings -->
        <svg class="absolute inset-0 pointer-events-none" viewBox="0 0 960 540" width="100%" height="100%"
            preserveAspectRatio="xMidYMax slice" xmlns="http://www.w3.org/2000/svg">
            <g class="text-gray-700 opacity-25" fill="none" stroke="currentColor" stroke-width="100">
                <circle r="234" cx="196" cy="23"></circle>
                <circle r="234" cx="790" cy="491"></circle>
            </g>
        </svg>
        <!-- Dots -->
        <svg class="absolute -top-16 -right-16 text-gray-700" viewBox="0 0 220 192" width="220" height="192"
            fill="none">
            <defs>
                <pattern id="837c3e70-6c3a-44e6-8854-cc48c737b659" x="0" y="0" width="20" height="20"
                    patternUnits="userSpaceOnUse">
                    <rect x="0" y="0" width="4" height="4" fill="currentColor"></rect>
                </pattern>
            </defs>
            <rect width="220" height="192" fill="url(#837c3e70-6c3a-44e6-8854-cc48c737b659)"></rect>
        </svg>
        <!-- @formatter:on -->
        <!-- Content -->
        <div class="z-10 relative w-full max-w-2xl">
            <div class="text-7xl font-bold leading-none text-gray-100">
                <div>{{ 'welcome_to' | translate }}</div>
                <div>{{ 'our_community' | translate }}</div>
            </div>
            <div class="mt-6 text-lg tracking-tight leading-6 text-gray-400">
                {{ 'template_description' | translate }}
            </div>
            <div class="flex items-center mt-8">
                <div class="flex flex-0 items-center -space-x-1.5">
                    <img class="flex-0 w-10 h-10 rounded-full ring-4 ring-offset-1 ring-gray-800 ring-offset-gray-800 object-cover"
                        src="assets/images/avatars/female-18.jpg">
                    <img class="flex-0 w-10 h-10 rounded-full ring-4 ring-offset-1 ring-gray-800 ring-offset-gray-800 object-cover"
                        src="assets/images/avatars/female-11.jpg">
                    <img class="flex-0 w-10 h-10 rounded-full ring-4 ring-offset-1 ring-gray-800 ring-offset-gray-800 object-cover"
                        src="assets/images/avatars/male-09.jpg">
                    <img class="flex-0 w-10 h-10 rounded-full ring-4 ring-offset-1 ring-gray-800 ring-offset-gray-800 object-cover"
                        src="assets/images/avatars/male-16.jpg">
                </div>
                <div class="ml-4 font-medium tracking-tight text-gray-400">{{ 'template_join_us' | translate }}</div>
            </div>
        </div>
    </div>
</div>

--- FILE: @fwk/auth/components/reset-password/reset-password.component.ts ---

import { NgIf } from '@angular/common';
import { Component, OnInit, ViewChild, ViewEncapsulation, inject } from '@angular/core';
import { FormsModule, NgForm, ReactiveFormsModule, FormBuilder, FormGroup, Validators, FormControl } from '@angular/forms';
import { MatButtonModule } from '@angular/material/button';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatIconModule } from '@angular/material/icon';
import { MatInputModule } from '@angular/material/input';
import { MatProgressSpinnerModule } from '@angular/material/progress-spinner';
import { RouterLink } from '@angular/router';
import { fuseAnimations } from '@fuse/animations';
import { FuseAlertComponent, FuseAlertType } from '@fuse/components/alert';
import { FuseValidators } from '@fuse/validators';
import { AuthService } from '@fwk/auth/auth.service';
import { finalize } from 'rxjs';
import { TranslatePipe } from '@fwk/pipe/translate.pipe';
import { I18nService } from '@fwk/services/i18n-service/i18n.service';

interface ResetPasswordForm {
    password: FormControl<string>;
    passwordConfirm: FormControl<string>;
}

@Component({
    selector: 'auth-reset-password', 
    templateUrl: './reset-password.component.html',
    encapsulation: ViewEncapsulation.None,
    animations: fuseAnimations,
    standalone: true,
    imports: [NgIf, FuseAlertComponent, FormsModule, ReactiveFormsModule, MatFormFieldModule, MatInputModule, MatButtonModule, MatIconModule, MatProgressSpinnerModule, RouterLink, TranslatePipe],
})
export class AuthResetPasswordComponent implements OnInit {
    @ViewChild('resetPasswordNgForm') resetPasswordNgForm: NgForm;

    alert: { type: FuseAlertType; message: string } = {
        type: 'success',
        message: '',
    };
    resetPasswordForm: FormGroup<ResetPasswordForm>;
    showAlert: boolean = false;
    private _translatePipe = new TranslatePipe(inject(I18nService));

    constructor(
        private _authService: AuthService,
        private _formBuilder: FormBuilder, 
    ) {
    }

    ngOnInit(): void {
        this.resetPasswordForm = this._formBuilder.group({
            password: ['', Validators.required],
            passwordConfirm: ['', Validators.required],
        },
            {
                validators: FuseValidators.mustMatch('password', 'passwordConfirm'),
            },
        );
    }

    resetPassword(): void {
        if (this.resetPasswordForm.invalid) {
            return;
        }

        this.resetPasswordForm.disable();
        this.showAlert = false;

        this._authService.resetPassword(this.resetPasswordForm.get('password').value)
            .pipe(
                finalize(() => {
                    this.resetPasswordForm.enable();
                    this.resetPasswordNgForm.resetForm();
                    this.showAlert = true;
                }),
            )
            .subscribe(
                (response) => {
                    this.alert = {
                        type: 'success',
                        message: this._translatePipe.transform('reset_password_success_message'),
                    };
                },
                (response) => {
                    this.alert = {
                        type: 'error',
                        message: this._translatePipe.transform('reset_password_error_message'),
                    };
                },
            );
    }
}

--- FILE: @fwk/auth/components/reset-password/reset-password.routes.ts ---

import { Routes } from '@angular/router';
import { AuthResetPasswordComponent } from '@fwk/auth/components/reset-password/reset-password.component';

export default [
    {
        path     : '',
        component: AuthResetPasswordComponent,
    },
] as Routes;


--- FILE: @fwk/auth/components/sign-in/sign-in.component.html ---

<div class="flex flex-col sm:flex-row items-center md:items-start sm:justify-center md:justify-start flex-auto min-w-0">

    <div class="md:flex md:items-center md:justify-end w-full sm:w-auto md:h-full md:w-1/2 py-8 px-4 sm:p-12 md:p-16 sm:rounded-2xl md:rounded-none sm:shadow md:shadow-none sm:bg-card">
        <div class="w-full max-w-80 sm:w-80 mx-auto sm:mx-0">

            <div class="w-16 flex items-center gap-2">
                <img src="https://premecsa.com.ar/wp-content/uploads/2018/05/logo-pestan%CC%83a-01.png" class="h-10" alt="Logo PREMEC">
                <h1 class="text-xl font-bold">PREMEC</h1>
            </div>

            <div class="mt-8 text-4xl font-extrabold tracking-tight leading-tight">{{ 'sign_in_title' | translate }}</div>

            <fuse-alert
                class="mt-8"
                *ngIf="showAlert"
                [appearance]="'outline'"
                [showIcon]="false"
                [type]="alert.type"
                [@shake]="alert.type === 'error'">
                {{alert.message}}
            </fuse-alert>

            <form
                class="mt-8 flex flex-col gap-4"
                [formGroup]="signInForm"
                #signInNgForm="ngForm">

                <mat-form-field class="w-full" appearance="outline">
                    <mat-label>{{ 'username_label' | translate }}</mat-label>
                    <input
                        id="username"
                        matInput
                        autocomplete="username"
                        [formControlName]="'username'">
                    <mat-error *ngIf="signInForm.get('username').hasError('required')">
                        {{ 'username_required_error' | translate }}
                    </mat-error>
                </mat-form-field>

                <mat-form-field class="w-full" appearance="outline">
                    <mat-label>{{ 'password_label' | translate }}</mat-label>
                    <input
                        id="password"
                        matInput
                        type="password"
                        autocomplete="current-password"
                        [formControlName]="'password'"
                        #passwordField>
                    <button
                        mat-icon-button
                        type="button"
                        (click)="passwordField.type === 'password' ? passwordField.type = 'text' : passwordField.type = 'password'"
                        matSuffix>
                        <mat-icon
                            class="icon-size-5"
                            *ngIf="passwordField.type === 'password'"
                            [svgIcon]="'heroicons_solid:eye'"></mat-icon>
                        <mat-icon
                            class="icon-size-5"
                            *ngIf="passwordField.type === 'text'"
                            [svgIcon]="'heroicons_solid:eye-slash'"></mat-icon>
                    </button>
                    <mat-error>
                        {{ 'password_required_error' | translate }}
                    </mat-error>
                </mat-form-field>

                <button
                    class="fuse-mat-button-large w-full mt-3"
                    mat-flat-button
                    color="accent"
                    [disabled]="signInForm.disabled || signInForm.invalid"
                    (click)="signIn()">
                    <span *ngIf="!signInForm.disabled">
                        {{ 'sign_in_button' | translate }}
                    </span>
                    <mat-progress-spinner
                        *ngIf="signInForm.disabled"
                        [diameter]="24"
                        [mode]="'indeterminate'"></mat-progress-spinner>
                </button>
            </form>
        </div>
    </div>

    <div class="relative hidden md:flex flex-auto items-center justify-center w-1/2 h-full p-16 lg:px-28 overflow-hidden bg-gray-800 dark:border-l">
        <svg class="absolute inset-0 pointer-events-none" viewBox="0 0 960 540" width="100%" height="100%" preserveAspectRatio="xMidYMax slice" xmlns="http://www.w3.org/2000/svg">
            <g class="text-gray-700 opacity-25" fill="none" stroke="currentColor" stroke-width="100">
                <circle r="234" cx="196" cy="23"></circle>
                <circle r="234" cx="790" cy="491"></circle>
            </g>
        </svg>
        <svg class="absolute -top-16 -right-16 text-gray-700" viewBox="0 0 220 192" width="220" height="192" fill="none">
            <defs>
                <pattern id="837c3e70-6c3a-44e6-8854-cc48c737b659" x="0" y="0" width="20" height="20" patternUnits="userSpaceOnUse">
                    <rect x="0" y="0" width="4" height="4" fill="currentColor"></rect>
                </pattern>
            </defs>
            <rect width="220" height="192" fill="url(#837c3e70-6c3a-44e6-8854-cc48c737b659)"></rect>
        </svg>
        
        <div class="z-10 relative w-full max-w-2xl">
            <div class="text-7xl font-bold leading-none text-gray-100">
                <div>{{ 'sign_in_welcome_title_1' | translate }}</div>
                <div>{{ 'sign_in_welcome_title_2' | translate }}</div>
            </div>
            <div class="mt-6 text-lg tracking-tight leading-6 text-gray-400">
                {{ 'sign_in_welcome_subtitle' | translate }}
            </div>
        </div>
    </div>
</div>

--- FILE: @fwk/auth/components/sign-in/sign-in.component.ts ---

import { NgIf } from '@angular/common';
import { Component, OnInit, ViewChild, ViewEncapsulation } from '@angular/core';
import { FormBuilder, FormControl, FormGroup, FormsModule, NgForm, ReactiveFormsModule, Validators } from '@angular/forms';
import { MatButtonModule } from '@angular/material/button';
import { MatCheckboxModule } from '@angular/material/checkbox';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatIconModule } from '@angular/material/icon';
import { MatInputModule } from '@angular/material/input';
import { MatProgressSpinnerModule } from '@angular/material/progress-spinner';
import { ActivatedRoute, Router, RouterLink } from '@angular/router';
import { fuseAnimations } from '@fuse/animations';
import { FuseAlertComponent, FuseAlertType } from '@fuse/components/alert';
import { AuthService } from '@fwk/auth/auth.service';
import { I18nService } from '@fwk/services/i18n-service/i18n.service';
import { TranslatePipe } from '@fwk/pipe/translate.pipe';

interface SignInForm {
    username: FormControl<string>;
    password: FormControl<string>;
    rememberMe: FormControl<boolean | null>;
}

@Component({
    selector     : 'auth-sign-in',
    templateUrl  : './sign-in.component.html',
    encapsulation: ViewEncapsulation.None,
    animations   : fuseAnimations,
    standalone   : true,
    imports      : [RouterLink, FuseAlertComponent, NgIf, FormsModule, ReactiveFormsModule, MatFormFieldModule, MatInputModule, MatButtonModule, MatIconModule, MatCheckboxModule, MatProgressSpinnerModule, TranslatePipe],
})
export class AuthSignInComponent implements OnInit
{
    @ViewChild('signInNgForm') signInNgForm: NgForm;

    alert: { type: FuseAlertType; message: string } = {
        type   : 'success',
        message: '',
    };
    signInForm: FormGroup<SignInForm>;
    showAlert: boolean = false;

    constructor(
        private _activatedRoute: ActivatedRoute,
        private _authService: AuthService,
        private _formBuilder: FormBuilder,
        private _router: Router,
        private _i18nService: I18nService,
    ) {}

    ngOnInit(): void
    {
        this.signInForm = this._formBuilder.group({
            username: ['', [Validators.required]],
            password: ['', Validators.required],
            rememberMe: [false], 
        });
    }

    signIn(): void
    {
        if ( this.signInForm.invalid )
        {
            return;
        }

        this.signInForm.disable();
        this.showAlert = false;

        this._authService.signIn(this.signInForm.getRawValue()).subscribe(
            () => {
                const redirectURL = this._activatedRoute.snapshot.queryParamMap.get('redirectURL') || '/signed-in-redirect';
                this._router.navigateByUrl(redirectURL);
            },
            (error) => {
                this.signInForm.enable();
                this.alert = {
                    type   : 'error',
                    message: this._i18nService.getDictionary('fwk')?.translate?.('sign_in_error_message') ?? 'sign_in_error_message'
                };
                this.showAlert = true;
            }
        );
    }
}

--- FILE: @fwk/auth/components/sign-in/sign-in.routes.ts ---

import { Routes } from '@angular/router';
import { AuthSignInComponent } from '@fwk/auth/components/sign-in/sign-in.component';

export default [
    {
        path     : '',
        component: AuthSignInComponent,
    },
] as Routes;


--- FILE: @fwk/auth/components/sign-out/sign-out.component.html ---

<div class="flex flex-col flex-auto items-center sm:justify-center min-w-0">
    <div class="w-full sm:w-auto py-8 px-4 sm:p-12 sm:rounded-2xl sm:shadow sm:bg-card">
        <div class="w-full max-w-80 sm:w-80 mx-auto sm:mx-0">
            <div class="w-12 mx-auto">
                <img src="https://premecsa.com.ar/wp-content/uploads/2018/05/logo-pestan%CC%83a-01.png">
            </div>

            <div class="mt-8 text-4xl font-extrabold tracking-tight leading-tight text-center">{{ 'sign_out_title' | translate }}</div>
            <div class="flex justify-center text-center mt-0.5 font-medium">
                <ng-container *ngIf="countdown > 0">
                    {{ countdownMessage }}
                </ng-container>

                <ng-container *ngIf="countdown === 0">
                   {{ 'sign_out_redirecting_now' | translate }}
                </ng-container>
            </div>

            <div class="mt-8 text-md font-medium text-secondary text-center">
                <span>{{ 'go_to_link' | translate }}</span>
                <a
                    class="ml-1 text-primary-500 hover:underline"
                    [routerLink]="['/sign-in']">{{ 'sign_in_link' | translate }}
                </a>
            </div>
        </div>
    </div>
</div>

--- FILE: @fwk/auth/components/sign-out/sign-out.component.ts ---

import { I18nPluralPipe, NgIf } from '@angular/common';
import { Component, OnDestroy, OnInit, ViewEncapsulation, inject } from '@angular/core';
import { Router, RouterLink } from '@angular/router';
import { AuthService } from '@fwk/auth/auth.service';
import { TranslatePipe } from '@fwk/pipe/translate.pipe';
import { I18nService } from '@fwk/services/i18n-service/i18n.service';
import { finalize, Subject, switchMap, takeUntil, takeWhile, tap, timer } from 'rxjs';

@Component({
    selector: 'auth-sign-out',
    templateUrl: './sign-out.component.html',
    encapsulation: ViewEncapsulation.None,
    standalone: true,
    imports: [NgIf, RouterLink, I18nPluralPipe, TranslatePipe],
})
export class AuthSignOutComponent implements OnInit, OnDestroy {
    countdown: number = 3;
    countdownMessage: string = '';
    countdownMapping: any = {
        '=1': '# segundo',
        'other': '# segundos',
    };
    private _unsubscribeAll: Subject<any> = new Subject<any>();

    private _authService = inject(AuthService);
    private _router = inject(Router);
    private _translatePipe = new TranslatePipe(inject(I18nService));

    constructor() { }

    ngOnInit(): void {
        this.updateCountdownMessage();

        this._authService.signOut().pipe(
            switchMap(() => timer(1000, 1000)),
            takeWhile(() => this.countdown > 0),
            tap(() => {
                this.countdown--;
                this.updateCountdownMessage();
            }),
            finalize(() => {
                window.location.assign('/sign-in');
            }),
            takeUntil(this._unsubscribeAll)
        ).subscribe();
    }

    ngOnDestroy(): void {
        this._unsubscribeAll.next(null);
        this._unsubscribeAll.complete();
    }

    private updateCountdownMessage(): void {
        const baseMessage = this._translatePipe.transform('sign_out_redirect_countdown');
        this.countdownMessage = baseMessage.replace('{{countdown}}', this.countdown.toString());
    }
}

--- FILE: @fwk/auth/components/sign-out/sign-out.routes.ts ---

import { Routes } from '@angular/router';
import { AuthSignOutComponent } from '@fwk/auth/components/sign-out/sign-out.component';

export default [
    {
        path     : '',
        component: AuthSignOutComponent,
    },
] as Routes;


--- FILE: @fwk/auth/components/sign-up/sign-up.component.html ---

<div class="flex flex-col sm:flex-row items-center md:items-start sm:justify-center md:justify-start flex-auto min-w-0">
    <div class="md:flex md:items-center md:justify-end w-full sm:w-auto md:h-full md:w-1/2 py-8 px-4 sm:p-12 md:p-16 sm:rounded-2xl md:rounded-none sm:shadow md:shadow-none sm:bg-card">
        <div class="w-full max-w-80 sm:w-80 mx-auto sm:mx-0">
            <!-- Logo -->
            <div class="w-12">
                <img src="https://premecsa.com.ar/wp-content/uploads/2018/05/logo-pestan%CC%83a-01.png">
            </div>

            <!-- Title -->
            <div class="mt-8 text-4xl font-extrabold tracking-tight leading-tight">{{ 'sign_up_title' | translate }}</div>
            <div class="flex items-baseline mt-0.5 font-medium">
                <div>{{ 'already_have_account' | translate }}</div>
                <a
                    class="ml-1 text-primary-500 hover:underline"
                    [routerLink]="['/sign-in']">{{ 'sign_in_link' | translate }}
                </a>
            </div>

            <!-- Alert -->
            <fuse-alert
                class="mt-8"
                *ngIf="showAlert"
                [appearance]="'outline'"
                [showIcon]="false"
                [type]="alert.type"
                [@shake]="alert.type === 'error'">
                {{alert.message}}
            </fuse-alert>

            <!-- Sign Up form -->
            <form
                class="mt-8"
                [formGroup]="signUpForm"
                #signUpNgForm="ngForm">

                <!-- Name field -->
                <mat-form-field class="w-full">
                    <mat-label>{{ 'full_name_label' | translate }}</mat-label>
                    <input
                        id="name"
                        matInput
                        [formControlName]="'name'">
                    <mat-error *ngIf="signUpForm.get('name').hasError('required')">
                        {{ 'full_name_required_error' | translate }}
                    </mat-error>
                </mat-form-field>

                <!-- Email field -->
                <mat-form-field class="w-full">
                    <mat-label>{{ 'email_address_label' | translate }}</mat-label>
                    <input
                        id="email"
                        matInput
                        [formControlName]="'email'">
                    <mat-error *ngIf="signUpForm.get('email').hasError('required')">
                        {{ 'email_address_required_error' | translate }}
                    </mat-error>
                    <mat-error *ngIf="signUpForm.get('email').hasError('email')">
                        {{ 'email_address_invalid_error' | translate }}
                    </mat-error>
                </mat-form-field>

                <!-- Password field -->
                <mat-form-field class="w-full">
                    <mat-label>{{ 'password_label' | translate }}</mat-label>
                    <input
                        id="password"
                        matInput
                        type="password"
                        [formControlName]="'password'"
                        #passwordField>
                    <button
                        mat-icon-button
                        type="button"
                        (click)="passwordField.type === 'password' ? passwordField.type = 'text' : passwordField.type = 'password'"
                        matSuffix>
                        <mat-icon
                            class="icon-size-5"
                            *ngIf="passwordField.type === 'password'"
                            [svgIcon]="'heroicons_solid:eye'"></mat-icon>
                        <mat-icon
                            class="icon-size-5"
                            *ngIf="passwordField.type === 'text'"
                            [svgIcon]="'heroicons_solid:eye-slash'"></mat-icon>
                    </button>
                    <mat-error>
                        {{ 'password_required_error' | translate }}
                    </mat-error>
                </mat-form-field>

                <!-- Company field -->
                <mat-form-field class="w-full">
                    <mat-label>{{ 'company_label' | translate }}</mat-label>
                    <input
                        id="company-confirm"
                        matInput
                        [formControlName]="'company'">
                </mat-form-field>

                <!-- ToS and PP -->
                <div class="inline-flex items-end w-full mt-1.5">
                    <mat-checkbox
                        class="-ml-2"
                        color="accent"
                        [formControlName]="'agreements'">
                        <span>{{ 'i_agree_with' | translate }}</span>
                        <a
                            class="ml-1 text-primary-500 hover:underline"
                            [routerLink]="['./']">{{ 'terms' | translate }}
                        </a>
                        <span>{{ 'and' | translate }}</span>
                        <a
                            class="ml-1 text-primary-500 hover:underline"
                            [routerLink]="['./']">{{ 'privacy_policy' | translate }}
                        </a>
                    </mat-checkbox>
                </div>

                <!-- Submit button -->
                <button
                    class="fuse-mat-button-large w-full mt-6"
                    mat-flat-button
                    color="accent"
                    [disabled]="signUpForm.disabled"
                    (click)="signUp()">
                    <span *ngIf="!signUpForm.disabled">
                        {{ 'create_free_account_button' | translate }}
                    </span>
                    <mat-progress-spinner
                        *ngIf="signUpForm.disabled"
                        [diameter]="24"
                        [mode]="'indeterminate'"></mat-progress-spinner>
                </button>

            </form>
        </div>
    </div>
    <div class="relative hidden md:flex flex-auto items-center justify-center w-1/2 h-full p-16 lg:px-28 overflow-hidden bg-gray-800 dark:border-l">
        <!-- Background -->
        <svg class="absolute inset-0 pointer-events-none" viewBox="0 0 960 540" width="100%" height="100%" preserveAspectRatio="xMidYMax slice" xmlns="http://www.w3.org/2000/svg">
            <g class="text-gray-700 opacity-25" fill="none" stroke="currentColor" stroke-width="100">
                <circle r="234" cx="196" cy="23"></circle>
                <circle r="234" cx="790" cy="491"></circle>
            </g>
        </svg>
        <svg class="absolute -top-16 -right-16 text-gray-700" viewBox="0 0 220 192" width="220" height="192" fill="none">
            <defs>
                <pattern id="837c3e70-6c3a-44e6-8854-cc48c737b659" x="0" y="0" width="20" height="20" patternUnits="userSpaceOnUse">
                    <rect x="0" y="0" width="4" height="4" fill="currentColor"></rect>
                </pattern>
            </defs>
            <rect width="220" height="192" fill="url(#837c3e70-6c3a-44e6-8854-cc48c737b659)"></rect>
        </svg>
        <!-- Content -->
        <div class="z-10 relative w-full max-w-2xl">
            <div class="text-7xl font-bold leading-none text-gray-100">
                <div>{{ 'welcome_to' | translate }}</div>
                <div>{{ 'our_community' | translate }}</div>
            </div>
            <div class="mt-6 text-lg tracking-tight leading-6 text-gray-400">
                {{ 'template_description' | translate }}
            </div>
            <div class="flex items-center mt-8">
                <div class="flex flex-0 items-center -space-x-1.5">
                    <img
                        class="flex-0 w-10 h-10 rounded-full ring-4 ring-offset-1 ring-gray-800 ring-offset-gray-800 object-cover"
                        src="assets/images/avatars/female-18.jpg">
                    <img
                        class="flex-0 w-10 h-10 rounded-full ring-4 ring-offset-1 ring-gray-800 ring-offset-gray-800 object-cover"
                        src="assets/images/avatars/female-11.jpg">
                    <img
                        class="flex-0 w-10 h-10 rounded-full ring-4 ring-offset-1 ring-gray-800 ring-offset-gray-800 object-cover"
                        src="assets/images/avatars/male-09.jpg">
                    <img
                        class="flex-0 w-10 h-10 rounded-full ring-4 ring-offset-1 ring-gray-800 ring-offset-gray-800 object-cover"
                        src="assets/images/avatars/male-16.jpg">
                </div>
                <div class="ml-4 font-medium tracking-tight text-gray-400">{{ 'template_join_us' | translate }}</div>
            </div>
        </div>
    </div>
</div>

--- FILE: @fwk/auth/components/sign-up/sign-up.component.ts ---

import { NgIf } from '@angular/common';
import { Component, OnInit, ViewChild, ViewEncapsulation, inject } from '@angular/core';
import { FormBuilder, FormControl, FormGroup, FormsModule, NgForm, ReactiveFormsModule, Validators } from '@angular/forms';
import { MatButtonModule } from '@angular/material/button';
import { MatCheckboxModule } from '@angular/material/checkbox';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatIconModule } from '@angular/material/icon';
import { MatInputModule } from '@angular/material/input';
import { MatProgressSpinnerModule } from '@angular/material/progress-spinner';
import { Router, RouterLink } from '@angular/router';
import { fuseAnimations } from '@fuse/animations';
import { FuseAlertComponent, FuseAlertType } from '@fuse/components/alert';
import { AuthService } from '@fwk/auth/auth.service';
import { I18nService } from '@fwk/services/i18n-service/i18n.service';
import { TranslatePipe } from '@fwk/pipe/translate.pipe';

interface SignUpForm {
    name: FormControl<string>;
    email: FormControl<string>;
    password: FormControl<string>;
    company: FormControl<string | null>;
    agreements: FormControl<boolean>;
}

@Component({
    selector     : 'auth-sign-up',
    templateUrl  : './sign-up.component.html',
    encapsulation: ViewEncapsulation.None,
    animations   : fuseAnimations,
    standalone   : true,
    imports      : [RouterLink, NgIf, FuseAlertComponent, FormsModule, ReactiveFormsModule, MatFormFieldModule, MatInputModule, MatButtonModule, MatIconModule, MatCheckboxModule, MatProgressSpinnerModule, TranslatePipe],
})
export class AuthSignUpComponent implements OnInit
{
    @ViewChild('signUpNgForm') signUpNgForm: NgForm;

    private _authService = inject(AuthService);
    private _formBuilder = inject(FormBuilder);
    private _router = inject(Router);
    private _i18nService = inject(I18nService);

    alert: { type: FuseAlertType; message: string } = {
        type   : 'success',
        message: '',
    };

    signUpForm: FormGroup<SignUpForm>;
    showAlert: boolean = false;

    constructor() {}

    ngOnInit(): void
    {
        this.signUpForm = this._formBuilder.group({
                name      : ['', Validators.required],
                email     : ['', [Validators.required, Validators.email]],
                password  : ['', Validators.required],
                company   : [''],
                agreements: [false, Validators.requiredTrue],
            },
        );
    }

    signUp(): void
    {
        if ( this.signUpForm.invalid )
        {
            return;
        }

        this.signUpForm.disable();
        this.showAlert = false;

        this._authService.signUp(this.signUpForm.getRawValue())
            .subscribe(
                (response) =>
                {
                    this._router.navigateByUrl('/confirmation-required');
                },
                (response) =>
                {
                    this.signUpForm.enable();
                    this.signUpNgForm.resetForm();

                    this.alert = {
                        type   : 'error',
                        message: this._i18nService.getDictionary('fwk')?.translate?.('generic_error_try_again') ?? 'generic_error_try_again',
                    };

                    this.showAlert = true;
                },
            );
    }
}

--- FILE: @fwk/auth/components/sign-up/sign-up.routes.ts ---

import { Routes } from '@angular/router';
import { AuthSignUpComponent } from '@fwk/auth/components/sign-up/sign-up.component';

export default [
    {
        path     : '',
        component: AuthSignUpComponent,
    },
] as Routes;


--- FILE: @fwk/auth/components/unlock-session/unlock-session.component.html ---

<div class="flex flex-col sm:flex-row items-center md:items-start sm:justify-center md:justify-start flex-auto min-w-0">
    <div class="md:flex md:items-center md:justify-end w-full sm:w-auto md:h-full md:w-1/2 py-8 px-4 sm:p-12 md:p-16 sm:rounded-2xl md:rounded-none sm:shadow md:shadow-none sm:bg-card">
        <div class="w-full max-w-80 sm:w-80 mx-auto sm:mx-0">
            <!-- Logo -->
            <div class="w-12">
                <img src="https://premecsa.com.ar/wp-content/uploads/2018/05/logo-pestan%CC%83a-01.png">
            </div>

            <!-- Title -->
            <div class="mt-8 text-4xl font-extrabold tracking-tight leading-tight">{{ 'unlock_session_title' | translate }}</div>
            <div class="mt-0.5 font-medium">{{ 'unlock_session_subtitle' | translate }}</div>

            <!-- Alert -->
            <fuse-alert
                class="mt-8"
                *ngIf="showAlert"
                [appearance]="'outline'"
                [showIcon]="false"
                [type]="alert.type"
                [@shake]="alert.type === 'error'">
                {{alert.message}}
            </fuse-alert>

            <!-- Unlock form -->
            <form
                class="mt-8"
                [formGroup]="unlockSessionForm"
                #unlockSessionNgForm="ngForm">

                <!-- Name field -->
                <mat-form-field class="w-full">
                    <mat-label>{{ 'full_name_label' | translate }}</mat-label>
                    <input
                        id="name"
                        matInput
                        [formControlName]="'name'">
                </mat-form-field>

                <!-- Password field -->
                <mat-form-field class="w-full">
                    <mat-label>{{ 'password_label' | translate }}</mat-label>
                    <input
                        id="password"
                        matInput
                        type="password"
                        [formControlName]="'password'"
                        #passwordField>
                    <button
                        mat-icon-button
                        type="button"
                        (click)="passwordField.type === 'password' ? passwordField.type = 'text' : passwordField.type = 'password'"
                        matSuffix>
                        <mat-icon
                            class="icon-size-5"
                            *ngIf="passwordField.type === 'password'"
                            [svgIcon]="'heroicons_solid:eye'"></mat-icon>
                        <mat-icon
                            class="icon-size-5"
                            *ngIf="passwordField.type === 'text'"
                            [svgIcon]="'heroicons_solid:eye-slash'"></mat-icon>
                    </button>
                    <mat-error>
                        {{ 'password_required_error' | translate }}
                    </mat-error>
                </mat-form-field>

                <!-- Submit button -->
                <button
                    class="fuse-mat-button-large w-full mt-3"
                    mat-flat-button
                    color="accent"
                    [disabled]="unlockSessionForm.disabled"
                    (click)="unlock()">
                    <span *ngIf="!unlockSessionForm.disabled">
                        {{ 'unlock_session_button' | translate }}
                    </span>
                    <mat-progress-spinner
                        *ngIf="unlockSessionForm.disabled"
                        [diameter]="24"
                        [mode]="'indeterminate'"></mat-progress-spinner>
                </button>

                <!-- Form footer -->
                <div class="mt-8 text-md font-medium text-secondary">
                    <span>{{ 'i_am_not' | translate }}</span>
                    <a
                        class="ml-1 text-primary-500 hover:underline"
                        [routerLink]="['/sign-out']">{{name}}</a>
                </div>

            </form>
        </div>
    </div>
    <div class="relative hidden md:flex flex-auto items-center justify-center w-1/2 h-full p-16 lg:px-28 overflow-hidden bg-gray-800 dark:border-l">
        <!-- Background -->
        <svg class="absolute inset-0 pointer-events-none" viewBox="0 0 960 540" width="100%" height="100%" preserveAspectRatio="xMidYMax slice" xmlns="http://www.w3.org/2000/svg">
            <g class="text-gray-700 opacity-25" fill="none" stroke="currentColor" stroke-width="100">
                <circle r="234" cx="196" cy="23"></circle>
                <circle r="234" cx="790" cy="491"></circle>
            </g>
        </svg>
        <svg class="absolute -top-16 -right-16 text-gray-700" viewBox="0 0 220 192" width="220" height="192" fill="none">
            <defs>
                <pattern id="837c3e70-6c3a-44e6-8854-cc48c737b659" x="0" y="0" width="20" height="20" patternUnits="userSpaceOnUse">
                    <rect x="0" y="0" width="4" height="4" fill="currentColor"></rect>
                </pattern>
            </defs>
            <rect width="220" height="192" fill="url(#837c3e70-6c3a-44e6-8854-cc48c737b659)"></rect>
        </svg>
        <!-- Content -->
        <div class="z-10 relative w-full max-w-2xl">
            <div class="text-7xl font-bold leading-none text-gray-100">
                <div>{{ 'welcome_to' | translate }}</div>
                <div>{{ 'our_community' | translate }}</div>
            </div>
            <div class="mt-6 text-lg tracking-tight leading-6 text-gray-400">
                {{ 'template_description' | translate }}
            </div>
            <div class="flex items-center mt-8">
                <div class="flex flex-0 items-center -space-x-1.5">
                    <img
                        class="flex-0 w-10 h-10 rounded-full ring-4 ring-offset-1 ring-gray-800 ring-offset-gray-800 object-cover"
                        src="assets/images/avatars/female-18.jpg">
                    <img
                        class="flex-0 w-10 h-10 rounded-full ring-4 ring-offset-1 ring-gray-800 ring-offset-gray-800 object-cover"
                        src="assets/images/avatars/female-11.jpg">
                    <img
                        class="flex-0 w-10 h-10 rounded-full ring-4 ring-offset-1 ring-gray-800 ring-offset-gray-800 object-cover"
                        src="assets/images/avatars/male-09.jpg">
                    <img
                        class="flex-0 w-10 h-10 rounded-full ring-4 ring-offset-1 ring-gray-800 ring-offset-gray-800 object-cover"
                        src="assets/images/avatars/male-16.jpg">
                </div>
                <div class="ml-4 font-medium tracking-tight text-gray-400">{{ 'template_join_us' | translate }}</div>
            </div>
        </div>
    </div>
</div>

--- FILE: @fwk/auth/components/unlock-session/unlock-session.component.ts ---

import { NgIf } from '@angular/common';
import { Component, OnInit, ViewChild, ViewEncapsulation, inject } from '@angular/core';
import { FormsModule, NgForm, ReactiveFormsModule, FormBuilder, FormGroup, Validators, FormControl } from '@angular/forms';
import { MatButtonModule } from '@angular/material/button';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatIconModule } from '@angular/material/icon';
import { MatInputModule } from '@angular/material/input';
import { MatProgressSpinnerModule } from '@angular/material/progress-spinner';
import { ActivatedRoute, Router, RouterLink } from '@angular/router';
import { fuseAnimations } from '@fuse/animations';
import { FuseAlertComponent, FuseAlertType } from '@fuse/components/alert';
import { AuthService } from '@fwk/auth/auth.service';
import { UserService } from '@fwk/auth/user.service';
import { I18nService } from '@fwk/services/i18n-service/i18n.service';
import { TranslatePipe } from '@fwk/pipe/translate.pipe';

interface UnlockSessionForm {
    name: FormControl<string>;
    password: FormControl<string>;
}

@Component({
    selector     : 'auth-unlock-session',
    templateUrl  : './unlock-session.component.html',
    encapsulation: ViewEncapsulation.None,
    animations   : fuseAnimations,
    standalone   : true,
    imports      : [NgIf, FuseAlertComponent, FormsModule, ReactiveFormsModule, MatFormFieldModule, MatInputModule, MatButtonModule, MatIconModule, MatProgressSpinnerModule, RouterLink, TranslatePipe],
})
export class AuthUnlockSessionComponent implements OnInit
{
    @ViewChild('unlockSessionNgForm') unlockSessionNgForm: NgForm;

    alert: { type: FuseAlertType; message: string } = {
        type   : 'success',
        message: '',
    };
    name: string;
    showAlert: boolean = false;
    unlockSessionForm: FormGroup<UnlockSessionForm>;
    private _email: string;
    private _translatePipe = new TranslatePipe(inject(I18nService));

    constructor(
        private _activatedRoute: ActivatedRoute,
        private _authService: AuthService,
        private _formBuilder: FormBuilder, 
        private _router: Router,
        private _userService: UserService,
    )
    {
    }

    ngOnInit(): void
    {
        this._userService.user$.subscribe((user) =>
        {
            this.name = user.name;
            this._email = user.email;
        });

        this.unlockSessionForm = this._formBuilder.group({
            name    : [
                {
                    value   : this.name,
                    disabled: true,
                },
            ],
            password: ['', Validators.required],
        });
    }

    unlock(): void
    {
        if ( this.unlockSessionForm.invalid )
        {
            return;
        }

        this.unlockSessionForm.disable();
        this.showAlert = false;

        this._authService.unlockSession({
            email   : this._email ?? '',
            password: this.unlockSessionForm.get('password').value,
        }).subscribe(
            () =>
            {
                const redirectURL = this._activatedRoute.snapshot.queryParamMap.get('redirectURL') || '/signed-in-redirect';
                this._router.navigateByUrl(redirectURL);
            },
            (response) =>
            {
                this.unlockSessionForm.enable();
                this.unlockSessionNgForm.resetForm({
                    name: {
                        value   : this.name,
                        disabled: true,
                    },
                });

                this.alert = {
                    type   : 'error',
                    message: this._translatePipe.transform('unlock_session_invalid_password'),
                };

                this.showAlert = true;
            },
        );
    }
}

--- FILE: @fwk/auth/components/unlock-session/unlock-session.routes.ts ---

import { Routes } from '@angular/router';
import { AuthUnlockSessionComponent } from '@fwk/auth/components/unlock-session/unlock-session.component';

export default [
    {
        path     : '',
        component: AuthUnlockSessionComponent,
    },
] as Routes;


--- FILE: @fwk/auth/guards/auth.guard.ts ---

import { inject } from '@angular/core';
import { CanActivateFn, Router, ActivatedRouteSnapshot, RouterStateSnapshot, UrlTree } from '@angular/router';
import { Observable, of, switchMap } from 'rxjs';
import { NotificationService } from '@fwk/services/notification/notification.service';
import { AbstractAuthService } from '../abstract-auth.service';
import { I18nService } from '@fwk/services/i18n-service/i18n.service';
import { CrudDef } from '@fwk/model/component-def/crud-def';
import { PageComponentDef } from '@fwk/model/component-def/page-component-def';

export const AuthGuard: CanActivateFn = (route: ActivatedRouteSnapshot, state: RouterStateSnapshot): Observable<boolean | UrlTree> => {
    const authService = inject(AbstractAuthService);
    const router = inject(Router);
    const notificationService = inject(NotificationService);
    const i18nService = inject(I18nService);

    const noPermissionMessage = i18nService.getDictionary('fwk')?.translate?.('guard_no_permission') ?? 'guard_no_permission';

    if (state.url === '/sign-out') {
        return of(true);
    }
    
    return authService.check().pipe(
        switchMap((authenticated) => {
            if (!authenticated) {
                const redirectURL = state.url === '/sign-out' ? '' : `redirectURL=${state.url}`;
                return of(router.parseUrl(`sign-in?${redirectURL}`));
            }

            const definition: CrudDef | PageComponentDef | null = route.firstChild?.data['definition'];

            if (definition) {
                const requiredPermission = definition.security?.readAccess;
                if (requiredPermission && !authService.hasPermission(requiredPermission)) {
                    notificationService.notifyError(noPermissionMessage);
                    return of(router.parseUrl('/403'));
                }
            }

            const staticPermission = route.data['requiredPermission'];
            if (staticPermission && !authService.hasPermission(staticPermission)) {
                notificationService.notifyError(noPermissionMessage);
                return of(router.parseUrl('/403'));
            }

            return of(true);
        }),
    );
};

--- FILE: @fwk/auth/guards/dev-mode.guard.ts ---

import { inject } from '@angular/core';
import { CanActivateFn, Router } from '@angular/router';
import { environment } from 'environments/environment';

export const DevModeGuard: CanActivateFn = () => {
    const router = inject(Router);

    if (environment.production) {
        return router.parseUrl('/404');
    }

    return true;
};

--- FILE: @fwk/auth/guards/initial-redirect.component.ts ---

import { Component, inject, OnInit } from '@angular/core';
import { Router } from '@angular/router';

@Component({
    selector: 'fwk-initial-redirect',
    template: '',
    standalone: true,
})
export class InitialRedirectComponent implements OnInit {
    private readonly _router = inject(Router);

    ngOnInit(): void {
        this._router.navigate(['/sign-in']);
    }
}

--- FILE: @fwk/auth/guards/noAuth.guard.ts ---

import { inject } from '@angular/core';
import { CanActivateChildFn, CanActivateFn, Router } from '@angular/router';
import { of, switchMap } from 'rxjs';
import { AbstractAuthService } from '../abstract-auth.service';

export const NoAuthGuard: CanActivateFn | CanActivateChildFn = (route, state) =>
{
    const router: Router = inject(Router);

    return inject(AbstractAuthService).check().pipe(
        switchMap((authenticated) =>
        {
            if ( authenticated )
            {
                return of(router.parseUrl('signed-in-redirect'));
            }
            return of(true);
        }),
    );
};

--- FILE: @fwk/auth/user.service.ts ---

import { HttpClient } from '@angular/common/http';
import { inject, Injectable } from '@angular/core';
import { User } from '@fwk/auth/user.types';
import { map, Observable, ReplaySubject, tap } from 'rxjs';

@Injectable({providedIn: 'root'})
export class UserService
{
    private _httpClient = inject(HttpClient);
    private _user: ReplaySubject<User> = new ReplaySubject<User>(1);

    /**
     * Setter & getter for user
     *
     * @param value
     */
    set user(value: User)
    {
        this._user.next(value);
    }

    get user$(): Observable<User>
    {
        return this._user.asObservable();
    }

    get(): Observable<User>
    {
        return this._httpClient.get<User>('api/common/user').pipe(
            tap((user) =>
            {
                this._user.next(user);
            }),
        );
    }

    /**
     * @param user
     */
    update(user: User): Observable<any>
    {
        return this._httpClient.patch<User>('api/common/user', {user}).pipe(
            map((response) =>
            {
                this._user.next(response);
            }),
        );
    }
}


--- FILE: @fwk/auth/user.types.ts ---

export interface User {
    id: string;
    name: string;
    email: string;
    avatar?: string;
    status?: string;
    permisos?: string[];
    refreshToken?: string;
}


--- FILE: @fwk/components/abstract-component.component.ts ---

﻿import { Directive, Injector, OnInit, OnDestroy } from '@angular/core';
import { Subscription } from 'rxjs';
import { Router } from '@angular/router';
import { FuseConfig, FuseConfigService } from '@fuse/services/config';
import { I18nService } from '../services/i18n-service/i18n.service';
import { I18n } from '../model/i18n';
import { NotificationService } from '../services/notification/notification.service';
import { ComponentDefService } from '../services/component-def-service/component-def.service';
import { ComponentDef } from '../model/component-def/component-def';

@Directive()
export abstract class AbstractComponent implements OnInit, OnDestroy {

    protected i18nService: I18nService;
    protected notificationService: NotificationService;
    protected componentDefService: ComponentDefService;
    protected router: Router;
    protected fuseConfigService: FuseConfigService;

    private _fuseConfigSubscription: Subscription;

    fuseConfig: FuseConfig;
    i18n?: I18n;
    i18nName: string = 'fwk';
    i18nLoaded: boolean = false;
    name: string = '';
    componentDef?: ComponentDef;

    constructor(injector: Injector) {
        this.i18nService = injector.get(I18nService);
        this.notificationService = injector.get(NotificationService);
        this.componentDefService = injector.get(ComponentDefService);
        this.router = injector.get(Router);
        this.fuseConfigService = injector.get(FuseConfigService);

        this.fuseConfig = this.fuseConfigService.config;
        this._fuseConfigSubscription = this.fuseConfigService.config$.subscribe(config => {
            this.fuseConfig = config;
        });
    }

    ngOnInit(): void {
        const i18nNameToLoad = this.getI18nName();
        if (i18nNameToLoad) {
            this.i18nService.getByName(i18nNameToLoad).subscribe(
                i18n => {
                    this.i18n = i18n;
                    this.i18nLoaded = true;
                }
            );
        } else {
            this.i18nLoaded = true;
        }
    }

    ngOnDestroy(): void {
        this._fuseConfigSubscription?.unsubscribe();
    }

    getI18nName(): string {
        return this.i18nName;
    }

    getName(): string {
        return this.name;
    }

    setUpI18n(i18n: I18n): void {
        this.i18nService.addI18n(i18n);
    }

    setUpComponentDef(componentDef: ComponentDef): void {
        this.componentDef = componentDef;
        this.name = componentDef.name;
        this.componentDefService.create(componentDef);
    }

    translate(key: string): string {
        if (!key) return '';

        const specificDict = this.i18nService.getDictionary(this.getI18nName());
        let translation = specificDict?.translate?.(key);

        if (!translation || translation === key) {
            const fwkDict = this.i18nService.getDictionary('fwk');
            translation = fwkDict?.translate?.(key);
        }

        return translation || key;
    }

    navigateWithInjector(url: string, param: Record<string, any>, injector: Injector): void {
        const router = injector.get(Router);
        router.navigateByUrl(this.buildURL(url, param));
    }

    navigate(url: string, param: Record<string, any>): void {
        this.router.navigateByUrl(this.buildURL(url, param));
    }

    private buildURL(url: string, param: Record<string, any> | null): string {
        let finalUrl = url;
        if (param) {
            Object.keys(param).forEach(key => {
                const placeholder = `:${key}`;
                if (finalUrl.includes(placeholder)) {
                    finalUrl = finalUrl.replace(new RegExp(placeholder, 'g'), param[key]);
                }
            });
        }
        return finalUrl.startsWith('/') ? finalUrl : `/${finalUrl}`;
    }
}

--- FILE: @fwk/components/abstract-form.component.ts ---

﻿import { Directive, Injector, OnInit } from '@angular/core';
import { MatStepper } from '@angular/material/stepper';
import { Observable, throwError, of } from 'rxjs';
import { tap, catchError, finalize } from 'rxjs/operators';

import { AbstractComponent } from './abstract-component.component';
import { FormService } from '../services/dynamic-form/form.service';
import { WsDef } from '../model/ws-def';
import { GenericHttpService } from '../services/generic-http-service/generic-http.service';
import { SpinnerService } from '../modules/spinner/service/spinner.service';

export const VALIDATIONS_ERRORS = 'VALIDATIONS_ERRORS';

@Directive()
export abstract class AbstractFormComponent extends AbstractComponent implements OnInit {

    protected formService: FormService;
    protected genericHttpService: GenericHttpService;
    protected spinnerService: SpinnerService;
    protected spinnerControl: any;
    private requestCount = 0;

    constructor(injector: Injector) {
        super(injector);
        this.formService = injector.get(FormService);
        this.genericHttpService = injector.get(GenericHttpService);
        this.spinnerService = injector.get(SpinnerService);
    }

    override ngOnInit(): void {
        super.ngOnInit();
        this.spinnerControl = this.spinnerService.getControlGlobalSpinner();
    }

    private showSpinner(): void {
        this.requestCount++;
        if (this.requestCount === 1 && this.spinnerControl) {
            setTimeout(() => this.spinnerControl.show(), 0);
        }
    }

    private hideSpinner(): void {
        this.requestCount--;
        if (this.requestCount === 0 && this.spinnerControl) {
            setTimeout(() => this.spinnerControl.hide(), 0);
        }
    }

    private handleFormError(error: any, form: any): Observable<never> {
        if (error?.error?.status === VALIDATIONS_ERRORS) {
            this.formService.addErrorToFields(form, error.error.errors);
        }
        return throwError(() => error);
    }

    genericSubmitWithWsDef(ws: WsDef, entity: any, form: any): Observable<any> {
        this.showSpinner();
        return this.genericHttpService.callWs(ws, entity).pipe(
            catchError(e => this.handleFormError(e, form)),
            finalize(() => this.hideSpinner())
        );
    }

    genericSubmit(service: { [key: string]: (entity: any) => Observable<any> }, wsMethod: string, entity: any, form: any): Observable<any> {
        if (!service || typeof service[wsMethod] !== 'function') {
            const error = `El método '${wsMethod}' no existe en el servicio proporcionado.`;
            console.error(`[FWK] ${error}`);
            return throwError(() => new Error(error));
        }

        this.showSpinner();
        return service[wsMethod](entity).pipe(
            catchError(e => this.handleFormError(e, form)),
            finalize(() => this.hideSpinner())
        );
    }

    submitFormStepper(service: { [key: string]: (entity: any) => Observable<any> }, method: string, entity: any, form: any, stepper: MatStepper): Observable<any> {
        return this.genericSubmit(service, method, entity, form).pipe(
            tap(() => {
                stepper.next();
            })
        );
    }

    setUpTextFromI18n(fields: any[]): void {
        if (this.i18n) {
            this.formService.setUpFieldTextFromI18n(this.i18n, fields);
        }
    }

    get submitting(): boolean {
        return this.requestCount > 0;
    }
}

--- FILE: @fwk/components/autocomplete/autocomplete.component.html ---

﻿<mat-form-field class="w-full" appearance="outline">
    <mat-label>{{ config?.label }}</mat-label>

    <input
        type="text"
        matInput
        [formControl]="autocompleteControl"
        [matAutocomplete]="auto"
        [required]="config?.required"
        [errorStateMatcher]="matcher">

    <mat-error *ngIf="autocompleteControl.hasError('required') && !errorMessage">
        {{ config?.options?.requiredMessage || ('autocomplete_required_error' | translate) }}
    </mat-error>
    <mat-error *ngIf="autocompleteControl.hasError('selectOrCleanField') && !errorMessage">
        {{ config?.options?.selectElementOrCleanField || ('autocomplete_select_or_clean_error' | translate) }}
    </mat-error>

    <mat-error *ngIf="errorMessage">{{ errorMessage }}</mat-error>
</mat-form-field>

<mat-autocomplete #auto="matAutocomplete"
                [displayWith]="displayWith"
                (optionSelected)="onOptionSelected()">
    <mat-option *ngFor="let option of filteredOptions$ | async" [value]="option">
        <span>{{ config?.options?.elementLabel ? option[config.options.elementLabel] : option }}</span>
    </mat-option>
</mat-autocomplete>

--- FILE: @fwk/components/autocomplete/autocomplete.component.ts ---

﻿import { Component, OnInit, Input, forwardRef, OnDestroy, ChangeDetectorRef } from '@angular/core';
import { CommonModule } from '@angular/common';
import { ControlValueAccessor, NG_VALUE_ACCESSOR, Validator, FormControl, AbstractControl, ValidationErrors, NG_VALIDATORS, ReactiveFormsModule, FormGroupDirective, NgForm } from '@angular/forms';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatInputModule } from '@angular/material/input';
import { MatAutocompleteModule } from '@angular/material/autocomplete';
import { MatOptionModule, ErrorStateMatcher } from '@angular/material/core';
import { Subject, Observable, of } from 'rxjs';
import { debounceTime, distinctUntilChanged, switchMap, takeUntil } from "rxjs/operators";
import { AutocompleteConfiguration, AutocompleteSearchTerm } from './autocomplete.interface';
import { TranslatePipe } from '../../pipe/translate.pipe';

@Component({
     selector: 'fwk-autocomplete',
    templateUrl: './autocomplete.component.html',
    styleUrls: ['./autocomplete.component.scss'],
    standalone: true,
    imports: [
        CommonModule,
        ReactiveFormsModule,
        MatFormFieldModule,
        MatInputModule,
        MatAutocompleteModule,
        MatOptionModule,
        TranslatePipe,
    ],
    providers: [
        {
            provide: NG_VALUE_ACCESSOR,
            useExisting: forwardRef(() => AutocompleteComponent),
            multi: true
        },
        {
            provide: NG_VALIDATORS,
            useExisting: forwardRef(() => AutocompleteComponent),
            multi: true
        }
    ]
})
export class AutocompleteComponent implements OnInit, OnDestroy, ControlValueAccessor, Validator {

    @Input() config!: AutocompleteConfiguration;
    @Input() searchTermInterface!: AutocompleteSearchTerm;
    @Input() errorMessage: string | null = null;

    autocompleteControl = new FormControl<string | object | null>(null);
    filteredOptions$: Observable<any[]> = of([]);

    matcher = new class implements ErrorStateMatcher {
        constructor(private component: AutocompleteComponent) { }
        isErrorState(control: FormControl | null, form: FormGroupDirective | NgForm | null): boolean {
            return !!(this.component.errorMessage || (control?.invalid && (control?.dirty || control?.touched)));
        }
    }(this);

    private destroy$ = new Subject<void>();
    private isOptionSelected: boolean = false;

    onChange: (value: any) => void = () => {};
    onTouched: () => void = () => {};

    constructor(private cdr: ChangeDetectorRef) {}

    ngOnInit() {
        if (!this.searchTermInterface) {
            console.error('[FWK] AutocompleteComponent requiere un [searchTermInterface].');
            return;
        }

        this.setupFiltering();

        this.autocompleteControl.valueChanges
            .pipe(takeUntil(this.destroy$))
            .subscribe(value => {
                if (typeof value !== 'string') {
                    this.onChange(value);
                } else {
                    this.onChange(null);
                }
            });
    }

    ngOnDestroy() {
        this.destroy$.next();
        this.destroy$.complete();
    }

    private setupFiltering(): void {
        this.filteredOptions$ = this.autocompleteControl.valueChanges.pipe(
            takeUntil(this.destroy$),
            debounceTime(500),
            distinctUntilChanged(),
            switchMap(value => {
                if (this.isOptionSelected) {
                    this.isOptionSelected = false;
                    return of([]);
                }
                if (typeof value !== 'string' || !value || value.length < (this.config.options?.minTermLength ?? 3)) {
                    return of([]);
                }
                return this.searchTermInterface.search(value);
            })
        );
    }

    writeValue(value: any): void {
        this.autocompleteControl.setValue(value, { emitEvent: false });
        this.cdr.markForCheck();
    }

    registerOnChange(fn: (value: any) => void): void {
        this.onChange = fn;
    }

    registerOnTouched(fn: () => void): void {
        this.onTouched = fn;
    }

    setDisabledState?(isDisabled: boolean): void {
        isDisabled ? this.autocompleteControl.disable() : this.autocompleteControl.enable();
        this.cdr.markForCheck();
    }

    validate(control: AbstractControl): ValidationErrors | null {
        const value = this.autocompleteControl.value;
        const isRequired = this.config?.required;

        if (isRequired && (value === null || value === undefined)) {
            return { required: true };
        }

        if (typeof value === 'string' && value.trim() !== '') {
            return { selectOrCleanField: true };
        }
        
        return null;
    }

    displayWith = (value: any): string => {
        if (!value || typeof value === 'string') {
            return '';
        }
        const labelKey = this.config?.options?.elementLabel;
        return labelKey && value[labelKey] ? value[labelKey] : '';
    }

    onOptionSelected(): void {
        this.isOptionSelected = true;
        this.onTouched();
    }
}

--- FILE: @fwk/components/autocomplete/autocomplete.interface.ts ---

﻿import { Observable } from "rxjs";

export interface AutocompleteConfiguration {
    key: string;
    label: string;
    required?: boolean;
    disabled?: boolean;
    value?: string;
    options?: AutocompleteOptions;
}

export interface AutocompleteOptions {
    requiredMessage?: string;
    invalidValueMessage?: string;
    selectElementOrCleanField?: string;
    elementLabel: string;
    elementValue: string;
    useNativeFilter?: boolean;
    transferIdToField: string;

    minTermLength?: number;
    useFormSenderFilter?: boolean;
}

export interface AutocompleteChangeValue {
    value: string;
}

export interface AutocompleteSearchTerm {
    search(term: string): Observable<any[]>;
}


export interface ApiAutocompleteConfiguration extends AutocompleteConfiguration {
    apiOptions: ApiAutocompleteOptions;
}

export interface ApiAutocompleteOptions {
    queryString?: any;
    url?: string;
    fromData?: any[];
    defaultShow?: number;
}


--- FILE: @fwk/components/autocomplete/autocomplete.service.ts ---

﻿import { Injectable } from '@angular/core';
import { Observable, of } from 'rxjs';
import { FormGroup } from '@angular/forms';
import { ApiAutocompleteConfiguration } from './autocomplete.interface';
import { GenericHttpService } from '../../services/generic-http-service/generic-http.service';
import { map, catchError } from 'rxjs/operators';
import { HttpParams } from '@angular/common/http';

@Injectable({
  providedIn: 'root'
})
export class AutocompleteService {

  constructor(protected httpService: GenericHttpService) { }

  public autocompleteSearch(formGroup: FormGroup, configuration: ApiAutocompleteConfiguration, term: string): Observable<any[]> {
    const apiOptions = configuration.apiOptions;

    if (!apiOptions?.url) {
      return of(apiOptions?.fromData || []);
    }

    let params = new HttpParams();
    const queryString = apiOptions.queryString || {};

    const searchTermKey = Object.keys(queryString).find(
      key => queryString[key] === configuration.key
    );

    if (searchTermKey) {
      params = params.set(searchTermKey, term);
    } else {
      console.warn(`[FWK] Autocomplete: No se encontró la clave del término de búsqueda en queryString para el campo '${configuration.key}'. La búsqueda podría fallar si se esperaba un término.`);
    }

    for (const key in queryString) {
      if (queryString.hasOwnProperty(key) && key !== searchTermKey) {
        const controlName = queryString[key];
        const control = formGroup.get(controlName);

        if (control && control.value !== null && control.value !== undefined) {
          params = params.set(key, control.value);
        }
      }
    }

    return this.httpService.basicGet(apiOptions.url, params, {}, {}).pipe(
      map(response => response || []),
      catchError(error => {
        console.error('Error en la búsqueda de autocompletado:', error);
        return of([]);
      })
    );
  }

  private getFilter(queryString: any, formGroup: FormGroup): { [key: string]: any } {
    const filter: { [key: string]: any } = {};
    if (queryString) {
      for (const prop in queryString) {
        if (queryString.hasOwnProperty(prop)) {
          const controlName = queryString[prop];
          if (formGroup.controls[controlName]) {
            filter[prop] = formGroup.controls[controlName].value;
          }
        }
      }
    }
    return filter;
  }
}

--- FILE: @fwk/components/autocomplete-desplegable/autocomplete-desplegable.component.html ---

﻿<mat-form-field class="w-full" appearance="outline">
    <mat-label>{{ config?.label }}</mat-label>

    <input
        #autoCompleteInput
        type="text"
        matInput
        [formControl]="autocompleteControl"
        [matAutocomplete]="auto"
        [required]="config?.required"
        [errorStateMatcher]="matcher"
        (blur)="onTouched()">

    <button
        mat-icon-button
        matSuffix
        type="button"
        (click)="openDropdown()"
        [disabled]="autocompleteControl.disabled"
        [matTooltip]="'autocomplete_show_options_tooltip' | translate">
        <mat-icon [svgIcon]="'heroicons_outline:chevron-down'"></mat-icon>
    </button>

    <mat-error *ngIf="autocompleteControl.hasError('required') && !errorMessage">
        {{ config?.options?.requiredMessage || ('autocomplete_required_error' | translate) }}
    </mat-error>
    <mat-error *ngIf="autocompleteControl.hasError('selectOrCleanField') && !errorMessage">
        {{ config?.options?.selectElementOrCleanField || ('autocomplete_select_or_clean_error' | translate) }}
    </mat-error>

    <mat-error *ngIf="errorMessage">{{ errorMessage }}</mat-error>
</mat-form-field>

<mat-autocomplete #auto="matAutocomplete"
                [displayWith]="displayWith"
                (optionSelected)="onOptionSelected()">
    <mat-option *ngFor="let option of filteredOptions$ | async" [value]="option">
        <span>{{ config?.options?.elementLabel ? option[config.options.elementLabel] : option }}</span>
    </mat-option>
</mat-autocomplete>

--- FILE: @fwk/components/autocomplete-desplegable/autocomplete-desplegable.component.ts ---

﻿import { Component, OnInit, Input, forwardRef, OnDestroy, ViewChild, ChangeDetectorRef } from '@angular/core';
import { CommonModule } from '@angular/common';
import { ControlValueAccessor, NG_VALUE_ACCESSOR, Validator, FormControl, AbstractControl, ValidationErrors, NG_VALIDATORS, ReactiveFormsModule, FormGroupDirective, NgForm } from '@angular/forms';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatInputModule } from '@angular/material/input';
import { MatTooltipModule } from '@angular/material/tooltip';
import { MatAutocompleteModule, MatAutocompleteTrigger } from '@angular/material/autocomplete';
import { MatOptionModule, ErrorStateMatcher } from '@angular/material/core';
import { MatButtonModule } from '@angular/material/button';
import { MatIconModule } from '@angular/material/icon';
import { Subject, Observable, of } from 'rxjs';
import { debounceTime, distinctUntilChanged, switchMap, takeUntil, startWith, filter } from "rxjs/operators";
import { ApiAutocompleteConfiguration, AutocompleteSearchTerm } from '../autocomplete/autocomplete.interface';
import { environment } from '../../../environments/environment';
import { TranslatePipe } from '../../pipe/translate.pipe';
import { AutocompleteOptions } from '@fwk/model/dynamic-form/dynamic-field-options.interface';

@Component({
     selector: 'fwk-autocomplete-desplegable',
    templateUrl: './autocomplete-desplegable.component.html',
    styleUrls: ['./autocomplete-desplegable.component.scss'],
    standalone: true,
    imports: [
        CommonModule,
        ReactiveFormsModule,
        MatFormFieldModule,
        MatInputModule,
        MatAutocompleteModule,
        MatOptionModule,
        MatButtonModule,
        MatIconModule,
        MatTooltipModule,
        TranslatePipe,
    ],
    providers: [
        {
            provide: NG_VALUE_ACCESSOR,
            useExisting: forwardRef(() => AutocompleteDesplegableComponent),
            multi: true
        },
        {
            provide: NG_VALIDATORS,
            useExisting: forwardRef(() => AutocompleteDesplegableComponent),
            multi: true
        }
    ]
})
export class AutocompleteDesplegableComponent implements OnInit, OnDestroy, ControlValueAccessor, Validator {

    @Input() config!: ApiAutocompleteConfiguration;
    @Input() searchTermInterface!: AutocompleteSearchTerm;
    @Input() errorMessage: string | null = null;
    
    @ViewChild('autoCompleteInput', { read: MatAutocompleteTrigger }) autoCompleteTrigger!: MatAutocompleteTrigger;

    autocompleteControl = new FormControl<string | object | null>(null);
    filteredOptions$: Observable<any[]> = of([]);

    matcher = new class implements ErrorStateMatcher {
        constructor(private component: AutocompleteDesplegableComponent) { }
        isErrorState(control: FormControl | null, form: FormGroupDirective | NgForm | null): boolean {
            return !!(this.component.errorMessage || (control?.invalid && (control?.dirty || control?.touched)));
        }
    }(this);

    private destroy$ = new Subject<void>();
    private isOptionSelected: boolean = false;

    onChange: (value: any) => void = () => { };
    onTouched: () => void = () => { };

    constructor(private cdr: ChangeDetectorRef) {}

    ngOnInit() {
        if (!this.searchTermInterface) {
            console.error('[FWK] AutocompleteDesplegableComponent requiere un [searchTermInterface].');
            return;
        }

        this.setupFiltering();

        this.autocompleteControl.valueChanges
            .pipe(takeUntil(this.destroy$))
            .subscribe(value => {
                if (typeof value !== 'string') {
                    this.onChange(value);
                }
            });
    }

    ngOnDestroy() {
        this.destroy$.next();
        this.destroy$.complete();
    }

    private setupFiltering(): void {
        const options = this.config?.options as AutocompleteOptions;
        const searchOnFocus = options?.searchOnFocus !== false;

        this.filteredOptions$ = of(null).pipe(
            switchMap(() => this.autocompleteControl.valueChanges.pipe(
                startWith(searchOnFocus ? '' : null),
            )),
            takeUntil(this.destroy$),
            filter(value => value !== null),
            debounceTime(environment.AUTOCOMPLETE_WAITING_TIME ?? 300),
            distinctUntilChanged(),
            switchMap(value => {
                if (this.isOptionSelected) {
                    this.isOptionSelected = false;
                    return of([]);
                }

                const searchTerm = typeof value === 'string' ? value : '';

                if (searchTerm === '' && !searchOnFocus) {
                    return of([]);
                }

                return this.searchTermInterface.search(searchTerm);
            })
        );
    }

    writeValue(value: any): void {
        this.autocompleteControl.setValue(value, { emitEvent: false });
        this.cdr.markForCheck();
    }

    registerOnChange(fn: (value: any) => void): void {
        this.onChange = fn;
    }

    registerOnTouched(fn: () => void): void {
        this.onTouched = fn;
    }

    setDisabledState?(isDisabled: boolean): void {
        isDisabled ? this.autocompleteControl.disable() : this.autocompleteControl.enable();
        this.cdr.markForCheck();
    }

    validate(control: AbstractControl): ValidationErrors | null {
        const value = this.autocompleteControl.value;
        const isRequired = this.config?.required;

        if (isRequired && (value === null || value === undefined)) {
            return { required: true };
        }

        if (typeof value === 'string' && value.trim() !== '') {
            return { selectOrCleanField: true };
        }

        return null;
    }

    displayWith = (value: any): string => {
        if (!value || typeof value !== 'object') {
            return typeof value === 'string' ? value : '';
        }

        const labelKey = this.config?.options?.elementLabel;

        if (labelKey && value[labelKey]) {
            return value[labelKey];
        }

        return '';
    }

    onOptionSelected(): void {
        this.isOptionSelected = true;
        this.onTouched();
    }

    openDropdown(): void {
        if (this.autoCompleteTrigger) {
            this.autoCompleteTrigger.openPanel();
        }
    }
}

--- FILE: @fwk/components/back-button/back-button.component.html ---

<button
    mat-icon-button
    [color]="color"
    (click)="goBack()"
    [matTooltip]="'back_button_tooltip' | translate">
    <mat-icon [svgIcon]="'heroicons_outline:arrow-uturn-left'"></mat-icon>
</button>

--- FILE: @fwk/components/back-button/backbutton.component.ts ---

﻿import { Component, Input } from '@angular/core';
import { CommonModule, Location } from '@angular/common';
import { ThemePalette } from '@angular/material/core';
import { MatButtonModule } from '@angular/material/button';
import { MatIconModule } from '@angular/material/icon';
import { MatTooltipModule } from '@angular/material/tooltip';
import { TranslatePipe } from '../../pipe/translate.pipe';

@Component({
    selector: 'back-button',
    templateUrl: './back-button.component.html',
    styleUrls: ['./back-button.component.scss'],
    standalone: true,
    imports: [
        CommonModule,
        MatButtonModule,
        MatIconModule,
        MatTooltipModule,
        TranslatePipe, 
    ]
})
export class BackButtonComponent {

    @Input() color: ThemePalette;

    constructor(private location: Location) {}

    goBack(): void {
        this.location.back();
    }
}

--- FILE: @fwk/components/color-picker/color-picker.component.html ---

﻿<div class="flex items-center w-full space-x-2 relative">
    <mat-form-field class="flex-auto" appearance="outline">
        <mat-label>{{ config.label }}</mat-label>

        <span
            matPrefix
            class="w-6 h-6 mr-2 rounded border"
            [style.background]="colorControl.value">
        </span>

        <input
            matInput
            [formControl]="colorControl"
            [id]="config.key"
            [required]="config.required"
            [readonly]="config.disabled"
            [errorStateMatcher]="matcher"
            (blur)="onTouched()">

        <mat-error *ngIf="colorControl.hasError('required') && !errorMessage">
            {{ config.options?.requiredMessage || ('color_picker_required' | translate) }}
        </mat-error>
        <mat-error *ngIf="colorControl.hasError('invalidValue') && !errorMessage">
            {{ config.options?.invalidValueMessage || ('color_picker_invalid' | translate) }}
        </mat-error>

        <mat-error *ngIf="errorMessage">{{ errorMessage }}</mat-error>
    </mat-form-field>

    <button
        type="button"
        mat-icon-button
        class="flex-none"
        [disabled]="config.disabled || colorControl.disabled"
        (click)="openPicker()"
        [matTooltip]="'color_picker_tooltip' | translate"
        [style.background]="colorControl.value">
        <mat-icon [svgIcon]="'heroicons_outline:swatch'"></mat-icon>
    </button>

    <input
        #pickerDirectiveElement
        class="hidden"
        [colorPicker]="colorControl.value ?? '#FFFFFF'"
        (colorPickerChange)="updateColor($event)"
        [cpDialogDisplay]="'popup'"
        [cpAlphaChannel]="'disabled'" />

</div>

--- FILE: @fwk/components/color-picker/color-picker.component.ts ---

﻿import { Component, OnInit, Input, forwardRef, OnDestroy, ViewChild, ChangeDetectorRef } from '@angular/core';
import { CommonModule } from '@angular/common';
import { ControlValueAccessor, NG_VALUE_ACCESSOR, Validator, FormControl, AbstractControl, ValidationErrors, NG_VALIDATORS, ReactiveFormsModule, FormGroupDirective, NgForm } from '@angular/forms';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatInputModule } from '@angular/material/input';
import { MatButtonModule } from '@angular/material/button';
import { MatIconModule } from '@angular/material/icon';
import { Subject } from 'rxjs';
import { takeUntil } from 'rxjs/operators';
import { ColorPickerConfiguration } from './color-picker.interface';
import { TranslatePipe } from '../../pipe/translate.pipe'; 
import { MatTooltipModule } from '@angular/material/tooltip'; 
import { ColorPickerModule, ColorPickerService, ColorPickerDirective } from 'ngx-color-picker'; 
import { ErrorStateMatcher } from '@angular/material/core';

@Component({
   selector: 'fwk-color-picker',
  templateUrl: './color-picker.component.html',
  styleUrls: ['./color-picker.component.scss'],
  standalone: true,
  imports: [
    CommonModule,
    ReactiveFormsModule,
    MatFormFieldModule,
    MatInputModule,
    MatButtonModule,
    MatIconModule,
    ColorPickerModule,
    TranslatePipe,
    MatTooltipModule
  ],
  providers: [
    ColorPickerService,
    {
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => ColorPickerComponent),
      multi: true
    },
    {
      provide: NG_VALIDATORS,
      useExisting: forwardRef(() => ColorPickerComponent),
      multi: true
    }
  ]
})
export class ColorPickerComponent implements OnInit, OnDestroy, ControlValueAccessor, Validator {

  @Input() config: ColorPickerConfiguration = { key: 'color-picker', label: 'Color' };
  @Input() errorMessage: string | null = null;

  @ViewChild('pickerDirectiveElement', { read: ColorPickerDirective }) pickerDirective: ColorPickerDirective;

  colorControl = new FormControl<string | null>(null);
  private destroy$ = new Subject<void>();
  private readonly hexPattern = /^#([a-fA-F0-9]{6})$/;

  matcher = new class implements ErrorStateMatcher {
    constructor(private component: ColorPickerComponent) { }
    isErrorState(control: FormControl | null, form: FormGroupDirective | NgForm | null): boolean {
        return !!(this.component.errorMessage || (control?.invalid && (control?.dirty || control?.touched)));
    }
  }(this);

  onChange: (value: string | null) => void = () => { };
  onTouched: () => void = () => { };
  onValidatorChange: () => void = () => { };

  constructor(private cdr: ChangeDetectorRef) {}

  ngOnInit() {
    this.colorControl.valueChanges
      .pipe(takeUntil(this.destroy$))
      .subscribe(value => {
        if (value === null || this.hexPattern.test(value)) {
            this.onChange(value);
        }
      });

    if (this.config.value) {
      this.colorControl.setValue(this.config.value, { emitEvent: false });
    }
  }

  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }

  writeValue(value: string | null): void {
    this.colorControl.setValue(value, { emitEvent: false });
    this.cdr.markForCheck();
  }

  registerOnChange(fn: (value: string | null) => void): void {
    this.onChange = fn;
  }

  registerOnTouched(fn: () => void): void {
    this.onTouched = fn;
  }

  setDisabledState?(isDisabled: boolean): void {
    isDisabled ? this.colorControl.disable() : this.colorControl.enable();
    this.cdr.markForCheck();
  }

  validate(control: AbstractControl): ValidationErrors | null {
    const value = this.colorControl.value;

    if (this.config.required && (!value || value.trim() === '')) {
      return { required: true };
    }

    if (value && !this.hexPattern.test(value)) {
      return { invalidValue: true };
    }

    return null;
  }

  updateColor(color: string): void {
    this.colorControl.setValue(color);
    this.onTouched();
  }
  
  openPicker(): void {
      if (this.pickerDirective && !this.colorControl.disabled) {
          this.pickerDirective.openDialog();
      }
  }

  registerOnValidatorChange?(fn: () => void): void {
    this.onValidatorChange = fn;
  }
}

--- FILE: @fwk/components/color-picker/color-picker.interface.ts ---

﻿export interface ColorPickerConfiguration {
    key: string;
    label?: string;
    required?: boolean;
    disabled?: boolean;
    value?: string;
    options?: ColorPickerInvalidOptions;
}


export interface ColorPickerInvalidOptions {
    requiredMessage?: string;
    invalidValueMessage?: string;
}

--- FILE: @fwk/components/crud/abstract-crud.component.ts ---

﻿import { Directive, Injector, OnInit, OnDestroy, ChangeDetectorRef } from '@angular/core';
import { MatDialog } from '@angular/material/dialog';
import { FormGroup } from '@angular/forms';
import { ActivatedRoute, Params } from '@angular/router';
import { Observable, of, Subject } from 'rxjs';
import { tap, finalize, takeUntil } from 'rxjs/operators';

import { AbstractComponent } from '../abstract-component.component';
import { FormService } from '@fwk/services/dynamic-form/form.service';
import { CrudDefService } from '@fwk/services/crud-def-service/crud-def.service';
import { CRUD } from '@fwk/services/crud-service/crud';
import { GenericHttpService } from '@fwk/services/generic-http-service/generic-http.service';
import { BaseCrudService } from '@fwk/services/base-crud-service/base.crud.service';
import { ActionDefService } from '@fwk/services/action-def-service/action-def.service';
import { ExpressionService } from '@fwk/services/expression-service/expression.service';
import { SpinnerService } from '@fwk/modules/spinner/service/spinner.service';
import { LocalStorageService } from '@fwk/services/local-storage/local-storage.service';
import { DialogService } from '@fwk/services/dialog-service/dialog.service';
import { FileService } from '@fwk/services/file/file.service';

import { I18n } from '@fwk/model/i18n';
import { CrudDef } from '@fwk/model/component-def/crud-def';
import { GridDef } from '@fwk/model/component-def/grid-def';
import { Entity } from '@fwk/model/entity';

@Directive()
export abstract class AbstractCrudComponent<E extends Entity, S extends CRUD<E>> extends AbstractComponent implements OnInit, OnDestroy {

    entity!: E;
    entities: E[] = [];
    service!: S;
    protected _cdr: ChangeDetectorRef;
    dataSource: E[] = [];
    public isTableLoading = false;
    addForm?: FormGroup;
    editForm?: FormGroup;
    crudDef!: CrudDef;
    filterEntity: any = {};
    appliedFilterEntity: any = {};
    i18nComponent?: I18n;
    public parentTitle: string | null = null;
    public searchPerformed = false;

    protected spinnerControl: any;
    protected destroy$ = new Subject<void>();

    protected formService: FormService;
    protected crudDefService: CrudDefService;
    protected crudService: BaseCrudService;
    protected actionDefService: ActionDefService;
    protected genericHttpService: GenericHttpService;
    protected expressionService: ExpressionService;
    protected activatedRoute: ActivatedRoute;
    protected spinnerService: SpinnerService;
    protected dialog: MatDialog;
    protected localStorageService: LocalStorageService;
    protected dialogService: DialogService;
    protected fileService: FileService;

    constructor(injector: Injector) {
        super(injector);

        this.formService = injector.get(FormService);
        this.crudDefService = injector.get(CrudDefService);
        this.crudService = injector.get(BaseCrudService);
        this.actionDefService = injector.get(ActionDefService);
        this.genericHttpService = injector.get(GenericHttpService);
        this.expressionService = injector.get(ExpressionService);
        this.activatedRoute = injector.get(ActivatedRoute);
        this.spinnerService = injector.get(SpinnerService);
        this.dialog = injector.get(MatDialog);
        this.localStorageService = injector.get(LocalStorageService);
        this.dialogService = injector.get(DialogService);
        this.fileService = injector.get(FileService);
        this._cdr = injector.get(ChangeDetectorRef);
        this.spinnerControl = this.spinnerService.getControlGlobalSpinner();
    }

    abstract newObjectEntity(): E;
    abstract getCRUDName(): string;

    override ngOnInit(): void {
        super.ngOnInit();
        this.activatedRoute.queryParams.pipe(takeUntil(this.destroy$)).subscribe(params => {

            const queryParams = { ...params };
            this.parentTitle = queryParams['parentTitle'] || null;
            delete queryParams['parentTitle'];

            this.filterEntity = {};

            if (this.crudDef) {
                this.applyParamsToFilter(queryParams, this.crudDef);

                const hasUrlFilters = Object.keys(this.filterEntity).some(key =>
                    this.filterEntity[key] !== null &&
                    this.filterEntity[key] !== undefined &&
                    this.filterEntity[key] !== ''
                );

                const searchComp = (this as any).searchComponent;
                if (searchComp) {
                    searchComp.entity = { ...this.filterEntity };
                    searchComp.form.patchValue(this.filterEntity, { emitEvent: false });
                    searchComp.updateActiveFilterCount();
                }

                const hasFilterComponent = !!(this.crudDef.forms?.filter || this.crudDef.formsDef?.filter);

                if (!this.searchPerformed && hasFilterComponent) {
                    return;
                }

                if (!this.crudDef.cancelInitSearch || hasUrlFilters) {
                    this.findAll();
                }
            }
        });
    }

    override ngOnDestroy(): void {
        super.ngOnDestroy();
        this.destroy$.next();
        this.destroy$.complete();
    }

    protected applyParamsToFilter(params: Params, def: CrudDef): void {
        const filterFields = def.formsDef?.filter?.fields ?? def.forms?.filter;
        if (filterFields && params) {
            filterFields.forEach(field => {
                if (params[field.key] !== undefined) {
                    this.filterEntity[field.key] = params[field.key];
                    field.value = params[field.key];
                }
            });
        }
    }

    public setUpCRUDDef(def: CrudDef): void {
        this.crudDef = def;
        this.name = def.name;

        if (this.crudDef.ws && this.crudDef.ws.url) {
            this.crudService.setBaseURL(this.crudDef.ws.url);
            this.service = this.crudService as unknown as S;
        } else if (!this.crudDef.template) {
            console.error(`[AbstractCrudComponent] No se pudo configurar el servicio porque ws.url está vacío para ${this.name}.`);
        }

        if (this.crudDef.template) {
            if (this.crudDef.i18n) {
                this.i18nService.getByName(this.crudDef.i18n.name).subscribe(i18n => {
                    if (i18n) { this.i18nComponent = i18n; }
                });
            }
            return;
        }

        if (!this.crudDef.forms) { this.crudDef.forms = {}; }
        if (this.crudDef.forms.filter === undefined) { this.crudDef.forms.filter = this.crudDef.searchFields; }
        if (this.crudDef.formsDef?.create?.fields) { this.crudDef.forms.create = this.crudDef.formsDef.create.fields; }
        if (this.crudDef.formsDef?.update?.fields) { this.crudDef.forms.update = this.crudDef.formsDef.update.fields; }

        const processFormsAndFinish = (i18n: I18n | null) => {
            if (i18n && this.crudDef.forms) {
                this.setUpI18nForms(this.crudDef.forms, i18n);
            }
            if (i18n && this.crudDef.grid) {
                this.setUpI18nGrid(this.crudDef.grid, i18n);
            }

            if (this.crudDef.forms?.create) {
                this.addForm = this.formService.toFormGroup(this.crudDef.forms.create, {}, null);
            }
            if (this.crudDef.forms?.update) {
                this.editForm = this.formService.toFormGroup(this.crudDef.forms.update, {}, null);
            }

            this.postSetUpCrud(this.crudDef);
        };

        if (this.crudDef.i18n) {
            this.i18nService.getByName(this.crudDef.i18n.name).subscribe(i18n => {
                if (!i18n) {
                    console.error(`[AbstractCrudComponent] No se encontró el diccionario '${this.crudDef.i18n.name}'`);
                    processFormsAndFinish(null);
                    return;
                }
                this.i18nComponent = new I18n();
                if (this.i18nComponent.clone) { this.i18nComponent.clone(i18n); }
                processFormsAndFinish(this.i18nComponent);
            });
        } else {
            processFormsAndFinish(null);
        }
    }

    postSetUpCrud(crudDef: CrudDef): void { /* Hook para clases hijas */ }

    private setUpI18nForms(forms: any, i18n: I18n): void {
        if (!forms) { return; }
        Object.keys(forms).forEach(propName => {
            const formFields = forms[propName];
            if (Array.isArray(formFields)) {
                formFields.forEach(field => {
                    if (field.labelKey) { field.label = i18n?.translate?.(field.labelKey); }
                });
            }
        });
    }

    private setUpI18nGrid(grid: GridDef, i18n: I18n): void {
        grid.columnsDef?.forEach((column) => {
            if (column.columnNameKey) { column.columnName = i18n?.translate?.(column.columnNameKey); }
        });
        grid.actions?.forEach(action => {
            if (action.actionNameKey) { action.actionName = i18n?.translate?.(action.actionNameKey); }
            if (action.form && this.i18nComponent) {
                this.formService.setUpFieldTextFromI18n(this.i18nComponent, action.form);
            }
        });
    }

    findAll(): void {
        if (!this.service) {
            console.warn(`[FWK] findAll: No hay servicio para el componente: ${this.name}.`);
            return;
        }

        this.searchPerformed = true;
        this.isTableLoading = true;

        const filterInMemory = this.crudDef.filterInMemory ?? true;
        const filterFields = this.crudDef.forms?.filter;
        const page = this.crudDef.serverPagination === true
            ? this.crudDef.pagination
            : undefined;

        this.service.findAll(this.filterEntity, filterFields, filterInMemory, page).pipe(
            finalize(() => {
                this.isTableLoading = false;
                this._cdr.markForCheck();
            })
        ).subscribe({
            next: (entities) => {
                this.entities = entities;
                this.dataSource = this.entities;
                this.appliedFilterEntity = { ...this.filterEntity };
                this.postFindAll();
            },
            error: (error) => console.error(`[FWK] Error en findAll para ${this.name}:`, error)
        });
    }


    postFindAll(): void { /* Hook para clases hijas */ }

    add(entity: E): Observable<any> {
        if (!entity) { return of(null); }
        return this.service.add(entity).pipe(tap(() => this.findAll()));
    }

    edit(entity: E): Observable<any> {
        if (!entity) { return of(null); }
        return this.service.update(entity).pipe(tap(() => this.findAll()));
    }

    delete(entity: E): void {
        this.service.delete(entity).subscribe(() => this.findAll());
    }

    deleteAll(entities: E[]): Observable<any> {
        if (this.crudDef.grid?.deleteTernaria) {
            const singleIdKey = this.crudDef.grid.columnsDef.find(c => c.singleId)?.columnDef;
            const multiIdKey = this.crudDef.grid.columnsDef.find(c => c.multiId)?.columnDef;
            if (singleIdKey && multiIdKey) {
                entities.forEach(element => {
                    (element as any).singleId = (element as any)[singleIdKey];
                    (element as any).multiId = (element as any)[multiIdKey];
                });
                return this.service.deleteAllTernario(entities, singleIdKey, multiIdKey);
            }
        }

        const idKey = this.crudDef.grid?.columnsDef.find(c => c.id)?.columnDef;
        if (idKey) {
            entities.forEach(element => {
                element.id = (element as any)[idKey];
            });
        }
        return this.service.deleteAll(entities);
    }

    filterSearchEntity(filterEntity: any): void {
        this.filterEntity = filterEntity;
        if (this.crudDef.pagination) { this.crudDef.pagination.page = 0; }
        this.findAll();
    }

    override translate(key: string): string {
        let word = this.i18nComponent?.translate?.(key);
        if (word === key || !word) {
            word = super.translate(key) ?? key;
        }
        return word;
    }
}

--- FILE: @fwk/components/crud/basic-modal/basic-modal.component.html ---

﻿<div class="flex flex-col max-h-screen" [ngClass]="[data.modalKey + '-modal', currentUrl + '-modal']">

    <mat-progress-bar *ngIf="_submitting" mode="indeterminate"></mat-progress-bar>

    <div class="flex flex-0 items-center justify-between pl-6 pr-4 h-16">
        <h2 class="text-2xl font-semibold">{{ titleLabel }}</h2>
        <button mat-icon-button (click)="onNoClick()" [disabled]="_submitting"
            [matTooltip]="'modal_button_close' | translate">
            <mat-icon [svgIcon]="'heroicons_outline:x-mark'"></mat-icon>
        </button>
    </div>

    <div mat-dialog-content class="flex-auto overflow-y-auto p-6 pb-6 border-t border-gray-200 dark:border-gray-600">
        <fwk-dynamic-form-component #dynamicForm [entity]="entity" [isEdit]="isEdit()" [fields]="fields"
            [subFormName]="formKey" [parentForm]="form" (onChangeEntity)="onChangeEntity($event)">
        </fwk-dynamic-form-component>
    </div>

    <div *ngIf="!notShowButton" mat-dialog-actions
        class="flex items-center justify-end p-6 pt-4 !border-t !border-gray-200 !dark:border-gray-600">


        <button *ngIf="formDef?.showSubmitContinue" class="ml-2" mat-flat-button color="accent"
            (click)="onSubmitNoClose()" [disabled]="form.pristine || form.invalid || _submitting">
            {{ 'modal_button_save_and_continue' | translate }}
        </button>

        <button class="ml-2" mat-flat-button color="accent" (click)="onSubmit()"
            [disabled]="form.pristine || form.invalid || _submitting">
            {{ submitLabel }}
        </button>
    </div>
</div>

--- FILE: @fwk/components/crud/basic-modal/basic-modal.component.ts ---

﻿import { Component, Inject, ViewChild, OnInit, ChangeDetectionStrategy, ChangeDetectorRef } from '@angular/core';
import { CommonModule } from '@angular/common';
import { MatDialogRef, MAT_DIALOG_DATA, MatDialogModule } from '@angular/material/dialog';
import { FormGroup, ReactiveFormsModule } from '@angular/forms';
import { Injector } from '@angular/core';
import { ActivatedRoute } from '@angular/router';

import { AbstractFormComponent } from '../../abstract-form.component';
import { DynamicField } from '../../../model/dynamic-form/dynamic-field';
import { DynamicFormComponent } from '../../dynamic-form/dynamic-form.component';
import { Entity } from '../../../model/entity';
import { I18n } from '../../../model/i18n';
import { FormDef } from '../../../model/form-def';

import { MatButtonModule } from '@angular/material/button';
import { MatIconModule } from '@angular/material/icon';
import { MatProgressBarModule } from '@angular/material/progress-bar';
import { A11yModule } from '@angular/cdk/a11y';
import { TranslatePipe } from '../../../pipe/translate.pipe';
import { MatTooltipModule } from '@angular/material/tooltip';
import { HTTP_METHODS } from '@fwk/model/ws-def';

@Component({
    selector: 'fwk-basic-modal-component',
    templateUrl: './basic-modal.component.html',
    standalone: true,
    imports: [
        CommonModule,
        ReactiveFormsModule,
        MatDialogModule,
        MatButtonModule,
        MatIconModule,
        MatProgressBarModule,
        DynamicFormComponent,
        A11yModule,
        TranslatePipe,
        MatTooltipModule
    ],
    changeDetection: ChangeDetectionStrategy.OnPush,
})
export class BasicModalComponent extends AbstractFormComponent implements OnInit {
    @ViewChild('dynamicForm') dynamicForm!: DynamicFormComponent;

    entity: any;
    config: any;
    fields: DynamicField<any>[] = [];
    form: FormGroup;
    isObjectModified: boolean = false;
    i18nComponent: I18n | undefined;
    submit: any;
    formKey: string;
    notShowButton: boolean;
    formDef: FormDef | undefined;
    _submitting: boolean = false;
    currentUrl: string = '';

    private flattenObject(ob: any, prefix = ''): any {
        const toReturn: any = {};

        for (const i in ob) {
            if (!ob.hasOwnProperty(i)) continue;

            if (Array.isArray(ob[i])) {
                toReturn[prefix + i] = ob[i];
                continue;
            }

            if ((typeof ob[i]) === 'object' && ob[i] !== null) {
                const flatObject = this.flattenObject(ob[i], prefix + i + '.');
                for (const x in flatObject) {
                    if (!flatObject.hasOwnProperty(x)) continue;
                    toReturn[x] = flatObject[x];
                }
            } else {
                toReturn[prefix + i] = ob[i];
            }
        }
        return toReturn;
    }

    constructor(
        public injector: Injector,
        public dialogRef: MatDialogRef<BasicModalComponent>,
        private activatedRoute: ActivatedRoute,
        @Inject(MAT_DIALOG_DATA) public data: any,
        private _cdr: ChangeDetectorRef,
    ) {
        super(injector);
        this.dialogRef.disableClose = true;

        this.config = this.data.config || {};
        this.entity = this.flattenObject(this.data.entity || {});
        this.submit = this.data.submit;
        this.i18nName = this.data.i18n?.name || 'fwk';
        this.formKey = this.config.formKey || 'subForm';
        this.formDef = this.config.formDef;
        this.notShowButton = !!this.config.notShowButton;

        this.fields = this.formDef?.fields || this.config.form || [];
        this.form = new FormGroup({});
        this.getUrl();
    }

    override ngOnInit(): void { }

    private getUrl(): void {
        const firstChild = this.activatedRoute.snapshot.firstChild;
        if (firstChild?.routeConfig?.path) {
            this.currentUrl = firstChild.routeConfig.path;
        }
    }

    onNoClick(): void {
        this.dialogRef.close();
    }

    onChangeEntity(entity) {
        if (this.config.ws && (this.config.ws.method === HTTP_METHODS.put ||
            this.config.ws.method === HTTP_METHODS.delete)) {
            entity.id = this.entity.id;
            this.entity = entity;
        } else if (this.config.ws && this.config.ws.method === HTTP_METHODS.post) {
            this.entity = entity;
        } else {
            this.entity = entity;
        }
    }

    isEdit(): boolean {
        return true;
    }

    onSubmitNoClose(): void {
        this.callSubmit(() => {
            if (this.dynamicForm) {
                this.isObjectModified = false;
                this._cdr.markForCheck();
            }
        });
    }

    onSubmit(): void {
        this.callSubmit((result: any) => {
            this.dialogRef.close(result);
        });
    }


    private callSubmit(callback: (result?: any) => void): void {
        if (this._submitting || this.form.invalid) {
            if (this.form.invalid) {
                this.notificationService.notifyError(this.translate('form_error_correct_errors'));
            }
            return;
        }
        this._submitting = true;
        this._cdr.markForCheck();

        const formWithControls = this.form.get(this.formKey) as FormGroup;
        if (!formWithControls) {
            console.error(`[FWK] BasicModal: No se pudo encontrar el FormGroup anidado.`);
            this._submitting = false;
            this._cdr.markForCheck();
            return;
        }

        let updatedEntity = this.formService.injectToEntity({}, formWithControls, this.fields);

        if (this.entity && (this.entity.id !== undefined && this.entity.id !== null)) {
            updatedEntity = { id: this.entity.id, ...updatedEntity };
        }

        const submitFn = this.submit?.onSubmitModal || this.submit;

        if (submitFn && typeof submitFn === 'function') {
            submitFn(updatedEntity, this.dialogRef);
        } else if (this.config?.ws) {
            this.genericSubmitWithWsDef(this.config.ws, updatedEntity, formWithControls).subscribe({
                next: (result: any) => {
                    this.notificationService.notifySuccess(this.translate('success_message'));
                    callback(result);
                },
                error: (error) => {
                    this._submitting = false;
                    this._cdr.markForCheck();
                },
                complete: () => {
                    this._submitting = false;
                    this._cdr.markForCheck();
                }
            });
        } else {
            callback(updatedEntity);
        }

        if (!this.submitting) {
            this._submitting = false;
            this._cdr.markForCheck();
        }
    }

    objectModified(isModified: boolean): void {
        this.isObjectModified = isModified;
        this._cdr.markForCheck();
    }

    get titleLabel(): string {
        if (this.data?.labelTitle) { return this.data.labelTitle; }
        if (this.config?.modalName) { return this.config.modalName; }
        if (this.config?.titleKey) { return this.translate(this.config.titleKey); }
        return this.translate('modal_confirm_operation_title');
    }

    get submitLabel(): string {
        if (this.config?.submitButtonKey) { return this.translate(this.config.submitButtonKey); }
        return this.translate('modal_button_confirm');
    }
}

--- FILE: @fwk/components/crud/crud-modal/crud-modal.component.html ---

﻿<div class="flex flex-col max-h-screen crud-modal" [ngClass]="[getFuncName() + '-modal', getUrl() + '-modal']">

    <mat-progress-bar *ngIf="submitting" mode="indeterminate"></mat-progress-bar>

    <div class="flex flex-0 items-center justify-between pl-6 pr-4 h-16">
        <h2 class="text-2xl font-semibold">{{ titleLabel }}</h2>
        <button mat-icon-button (click)="onNoClick()" [disabled]="submitting"
            [matTooltip]="'modal_button_close' | translate">
            <mat-icon [svgIcon]="'heroicons_outline:x-mark'"></mat-icon>
        </button>
    </div>

    <div mat-dialog-content class="flex-auto overflow-y-auto p-6  border-t border-gray-200 dark:border-gray-700">
        <fwk-dynamic-form-component cdkFocusInitial #dynamicForm [entity]="entity" [isEdit]="isEdit" [fields]="fields"
            [handlerFieldSourceData]="handlerFieldSourceData" [parentForm]="form"
            (objectModified)="objectModified($event)" (onFieldsChanges)="fieldsChanges(fields, $event)"
            (onChangeEntity)="onChangeEntity($event)">
        </fwk-dynamic-form-component>
    </div>

    <div mat-dialog-actions
        class="flex items-center justify-end p-6 pt-4 border-t border-gray-200 dark:border-gray-700">
        <ng-container *ngIf="!isEdit">
            <button class="ml-2 fuse-mat-button-large" mat-stroked-button (click)="onNoClick()" [disabled]="submitting">
                {{ 'modal_button_close' | translate }}
            </button>
        </ng-container>
        <ng-container *ngIf="formDef">

            <ng-container *ngFor="let action of getActions(formDef)">
                <button mat-button (click)="submitAction(action)">
                    {{ action.actionName }}
                </button>
            </ng-container>

            <ng-container *ngIf="isEdit">
                <button *ngIf="formDef?.showSubmitContinue" class="ml-2" mat-flat-button color="accent"
                    (click)="onSubmit(true)" [disabled]="!isObjectModified || form.invalid || submitting">
                    {{ 'modal_button_save_and_continue' | translate }}
                </button>

                <button class="ml-2" mat-flat-button color="accent" (click)="onSubmit()"
                    [disabled]="!isObjectModified || form.invalid || submitting">
                    {{ 'modal_button_save' | translate }}
                </button>
            </ng-container>
        </ng-container>
    </div>
</div>

--- FILE: @fwk/components/crud/crud-modal/crud-modal.component.ts ---

﻿import { Component, Inject, ViewChild, OnInit, ChangeDetectionStrategy, ChangeDetectorRef, AfterViewInit } from '@angular/core';
import { CommonModule } from '@angular/common';
import { MatDialogRef, MAT_DIALOG_DATA, MatDialogModule } from '@angular/material/dialog';
import { FormGroup, ReactiveFormsModule } from '@angular/forms';
import { Injector } from '@angular/core';
import { ActivatedRoute } from '@angular/router';

import { MatButtonModule } from '@angular/material/button';
import { MatIconModule } from '@angular/material/icon';
import { MatTooltipModule } from '@angular/material/tooltip';
import { MatProgressBarModule } from '@angular/material/progress-bar';
import { MatProgressSpinnerModule } from '@angular/material/progress-spinner';

import { AbstractComponent } from '../../abstract-component.component';
import { DynamicField } from '../../../model/dynamic-form/dynamic-field';
import { FormService } from '@fwk/services/dynamic-form/form.service';
import { DynamicFormComponent } from '../../dynamic-form/dynamic-form.component';
import { DynamicFieldBehavior } from '../../../model/dynamic-form/dynamic-field-behavior';
import { SpinnerService } from '../../../modules/spinner/service/spinner.service';
import { FormDef } from '../../../model/form-def';
import { ActionDef } from '../../../model/component-def/action-def';
import { ActionDefService } from '../../../services/action-def-service/action-def.service';
import { DialogService } from '../../../services/dialog-service/dialog.service';
import { of, finalize } from 'rxjs';
import { A11yModule } from '@angular/cdk/a11y';
import { TranslatePipe } from '../../../pipe/translate.pipe';
import { LocalStorageService } from '../../../services/local-storage/local-storage.service';

export const VALIDATIONS_ERRORS = 'VALIDATIONS_ERRORS';

@Component({
  selector: 'fwk-crud-modal-component',
  templateUrl: './crud-modal.component.html',
  styleUrls: ['./crud-modal.component.scss'],
  standalone: true,
  imports: [
    CommonModule,
    ReactiveFormsModule,
    MatDialogModule,
    MatButtonModule,
    MatTooltipModule,
    MatIconModule,
    MatProgressBarModule,
    MatProgressSpinnerModule,
    DynamicFormComponent,
    A11yModule,
    TranslatePipe
  ],
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class CrudModalComponent extends AbstractComponent implements OnInit, AfterViewInit {
  @ViewChild('dynamicForm') dynamicForm!: DynamicFormComponent;

  form: FormGroup;
  entity: any;
  isAdd: boolean = false;
  isRead: boolean = false;
  submitting: boolean = false;
  isObjectModified: boolean = false;
  formDef: FormDef | undefined;
  handlerFieldSourceData: any;
  _fields: DynamicField<any>[] = [];
  _isEdit: boolean = false;

  private fieldsBehavior: DynamicFieldBehavior[] | undefined;
  private customSubmitActions: ((action: ActionDef, entity: any) => void) | undefined;
  private formService: FormService;
  private spinnerService: SpinnerService;
  private globalSpinnerControl: any;
  private activatedRoute: ActivatedRoute;
  private actionDefService: ActionDefService;
  private dialogService: DialogService;
  private localStorageService: LocalStorageService;

  constructor(
    public injector: Injector,
    public dialogRef: MatDialogRef<CrudModalComponent>,
    @Inject(MAT_DIALOG_DATA) public data: any,
    private _cdr: ChangeDetectorRef,
  ) {
    super(injector);
    this.formService = injector.get(FormService);
    this.localStorageService = injector.get(LocalStorageService);
    this.spinnerService = injector.get(SpinnerService);
    this.activatedRoute = injector.get(ActivatedRoute);
    this.actionDefService = injector.get(ActionDefService);
    this.dialogService = injector.get(DialogService);
    this.i18nName = this.data.i18n?.name || 'fwk';
    this.dialogRef.disableClose = true;
    this.entity = this.localStorageService.clone(this.data.entity || {});
    this.formDef = this.data.formDef;
    this.isAdd = !!this.data.isAdd;
    this.isRead = !!this.data.isRead;
    this.isEdit = !!this.data.isEdit;
    this.customSubmitActions = this.data.submitActions;
    this.handlerFieldSourceData = this.data.handlerFieldSourceData;

    this.fields = this.formDef?.fields || this.data.fields || [];
    this.fieldsBehavior = this.formDef?.fieldsBehavior || this.data.fieldsBehavior;

    this.form = new FormGroup({});
  }

  ngAfterViewInit(): void {
    if (this.dynamicForm) {
      setTimeout(() => {
        this.dynamicForm.updateInitialState();

        if (this.fieldsBehavior && this.fieldsBehavior.length > 0) {
          const uniqueTriggerFields = [...new Set(this.fieldsBehavior.map(fb => fb.fieldKey))];

          uniqueTriggerFields.forEach(key => {
            this.formService.fieldChangeBehavior(
              key,
              this.fieldsBehavior!,
              this.entity,
              this.fields,
              this.form.get('subForm') as FormGroup
            );
          });
        }

        this._cdr.markForCheck();
      }, 0);
    }
  }

  override ngOnInit(): void {
    super.ngOnInit();
    this.globalSpinnerControl = this.spinnerService.getControlGlobalSpinner();
  }

  onNoClick(): void {
    const closeDialog = (): void => {
      this.dialogRef.close();
    };
    if (this.isObjectModified && !this.isRead) {
      this.dialogService.showQuestionModal({
        title: this.translate('modal_close_warning_title'),
        message: this.translate('modal_close_warning_message'),
        actions: {
          confirm: {
            label: this.translate('modal_close_warning_confirm'),
            color: 'warn'
          },
          cancel: {
            label: this.translate('modal_close_warning_cancel')
          }
        },
        onSubmit: closeDialog,
      });
    } else {
      closeDialog();
    }
  }

  onChangeEntity(entity: any): void {
    const originalId = this.isEdit && this.entity ? this.entity['id'] : undefined;
    this.entity = { ...entity };
    if (originalId !== undefined) {
      this.entity['id'] = originalId;
    }
  }

  fieldsChanges(fields: DynamicField<any>[], data: any): void {
    const subForm = this.form.get('subForm');
    if (subForm instanceof FormGroup) {
      this.formService.fieldsChangesBehavior(fields, this.fieldsBehavior || [], data, subForm);
    }
  }

  submitAction(action: ActionDef): void {
    if (this.customSubmitActions) {
      this.customSubmitActions(action, this.entity);
    } else {
      this.actionDefService.submitAction(action, this.entity, this.data.i18n, undefined).subscribe();
    }
  }

   onSubmit(andContinue: boolean = false): void {
    if (this.form.invalid) {
      this.notificationService.notifyError(this.translate('form_error_correct_errors'));
      return;
    }

    this.submitting = true;
    this._cdr.markForCheck();

    const subForm = this.form.get('subForm');

    if (subForm) {
      const formValues = subForm.getRawValue();
      this.entity = { ...this.entity, ...formValues };
    } else {
      console.error('Error: No se encontró el subForm en CrudModal');
    }

    const operation = this.isAdd ? 'add' : 'edit';
    const validationMethod = this.isAdd ? 'validationAdd' : 'validationEdit';

    const validation$ = this.data.crud[validationMethod] ? this.data.crud[validationMethod](this.entity) : of(true);

    validation$.subscribe({
      next: () => {
        this.data.crud[operation](this.entity).pipe(
          finalize(() => {
            this.submitting = false;
            this._cdr.markForCheck();
          })
        ).subscribe({
          next: (response: any) => {

            if (!response) {
              this.notificationService.notifySuccess(this.translate('success_message'));
              this.dialogRef.close(true);
              return;
            }

            if (response.ok === false && response.error) {
              this.notificationService.notifyError(response.error.message || 'Error en el servidor');
              return;
            }

            const isSuccess = response.success === true ||
              typeof response.success === 'undefined' ||
              response.id ||
              response.ok === true;

            if (isSuccess) {
              this.notificationService.notifySuccess(this.translate('success_message'));
              
              if (andContinue) {
                const persistentValues: any = {};
                this.fields.forEach(f => {
                  if (f.mappingQuerystring || f.controlType === 'hidden') {
                    persistentValues[f.key] = this.entity[f.key];
                  }
                });

                this.entity = { ...this.newObjectEntity(), ...persistentValues };
                
                this.form.reset();

                if (subForm) {
                    subForm.patchValue(persistentValues);
                }

                this.isObjectModified = false;
                this.isAdd = true;
                this._cdr.markForCheck();
              } else {
                this.dialogRef.close(response);
              }
            } else {
              this.notificationService.notifyError(response.message || 'Ocurrió un error desconocido.');
            }
          },
          error: (error: any) => this.handlerError(error)
        });
      },
      error: (error: any) => {
        this.handlerError(error);
        this.submitting = false;
        this._cdr.markForCheck();
      }
    });
  }

  private newObjectEntity(): any {
    return {};
  }

  getActions(form: FormDef | undefined): ActionDef[] {
    if (!form?.actions) {
      return [];
    }
    return this.actionDefService.getActions(form.displayActionsCondition || [], form.actions, this.entity);
  }

  objectModified(isModified: boolean): void {
    this.isObjectModified = isModified;
    this._cdr.markForCheck();
  }

  handlerError(error: any): void {
    if (error?.error?.status === VALIDATIONS_ERRORS) {
      const subForm = this.form.get('subForm');
      if (subForm instanceof FormGroup) {
        this.formService.addErrorToFields(subForm, error.error.errors);
      }
      if (error.error.message) {
        this.notificationService.notifyError(error.error.message);
      }
    } else {
      this.notificationService.notifyError(this.translate('generic_error_try_again'));
    }
  }

  get titleLabel(): string {
    if (this.formDef?.title) { return this.formDef.title; }
    if (this.isAdd) { return this.translate('modal_add_title'); }
    if (this._isEdit) { return this.translate('modal_edit_title'); }
    return this.translate('modal_view_title');
  }

  get saveLabel(): string {
    if (this.isAdd) { return this.translate('modal_button_save'); }
    if (this._isEdit) { return this.translate('modal_button_save'); }
    return this.translate('modal_button_confirm');
  }

  get fields(): DynamicField<any>[] { return this._fields; }
  set fields(data: DynamicField<any>[]) { this._fields = data ? [...data] : []; }

  get isEdit(): boolean { return this.isAdd || this._isEdit; }
  set isEdit(value: boolean) { this._isEdit = value; }

  getFuncName(): string { return this.data.funcName || ''; }
  getUrl(): string { return this.activatedRoute.snapshot.children[0]?.routeConfig?.path || ''; }
}

--- FILE: @fwk/components/crud/crud-search/search.component.html ---

﻿<mat-expansion-panel #searchPanel class="border-t shadow-none rounded-none dark:bg-transparent" [expanded]="false"
    *ngIf="generalFields && generalFields.length > 0">
    <mat-expansion-panel-header class="px-4 sm:px-6">
        <mat-panel-title class="flex items-center space-x-3">
            <mat-icon [svgIcon]="'heroicons_outline:magnifying-glass'"></mat-icon>
            <span class="font-semibold">{{ 'search_title' | translate }}</span>
        </mat-panel-title>
        <mat-panel-description class="flex items-center justify-end">
            <span *ngIf="activeFilterCount === 0">{{ 'search_panel_placeholder' | translate }}</span>
            <span *ngIf="activeFilterCount > 0" class="flex items-center font-medium text-primary-400">
                {{ activeFilterCount | i18nPlural: activeFilterCountMapping }}
                <mat-icon class="ml-1 text-primary-400" [svgIcon]="'heroicons_solid:check-circle'"></mat-icon>
            </span>
        </mat-panel-description>
    </mat-expansion-panel-header>

    <form *ngIf="hasVisibleFields" class="w-full" #ngformElement="ngForm" (ngSubmit)="onSubmitSearch()"
        (keydown)="submitOnEnter($event)" [formGroup]="form" novalidate>

        <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-3 pb-4">
            <div *ngFor="let gf of visibleGeneralFields">
                <fwk-dynamic-form-component [entity]="entity" [isEdit]="true" [fields]="[gf]" [parentForm]="form"
                    (onFieldsChanges)="onChangeEntity($event.entity)">
                </fwk-dynamic-form-component>
            </div>
        </div>

    </form>

    <mat-action-row class="p-4 sm:px-6">
        <div class="flex items-center justify-end w-full space-x-2">

            <button *ngIf="!columnsAltered" mat-stroked-button [matMenuTriggerFor]="columnasMenu"
                [matTooltip]="'search_columns_tooltip' | translate">
                <mat-icon class="icon-size-5" [svgIcon]="'heroicons_outline:view-columns'"></mat-icon>
                <span class="ml-2 hidden sm:inline">{{ 'search_columns_button' | translate }}</span>
            </button>

            <button *ngIf="columnsAltered" mat-flat-button color="accent" [matMenuTriggerFor]="columnasMenu"
                [matTooltip]="'search_columns_tooltip_altered' | translate">
                <mat-icon class="icon-size-5" [svgIcon]="'heroicons_solid:view-columns'"></mat-icon>
                <span class="ml-2 hidden sm:inline">{{ 'search_columns_button' | translate }}</span>
            </button>

            <mat-menu #columnasMenu="matMenu" class="max-h-96 rounded-2xl">
                <div class="px-4 py-2 text-sm font-semibold border-b">{{ 'search_columns_title' | translate }}</div>
                <ng-container *ngFor="let col of menuColumns">
                    <div (click)="$event.stopPropagation()">
                        <mat-checkbox class="mat-menu-item" [checked]="columnVisibility.get(col.columnDef)"
                            (change)="toggleColumnVisibility(col.columnDef)">
                            {{ col.columnName }}
                        </mat-checkbox>
                    </div>
                </ng-container>
            </mat-menu>

            <button *ngIf="hasOptions() && !userChangeOptions()" mat-stroked-button type="button"
                (click)="openOptions()" [matTooltip]="'search_advanced_filters_tooltip' | translate">
                <mat-icon class="icon-size-5" [svgIcon]="'heroicons_outline:adjustments-horizontal'"></mat-icon>
                <span class="ml-2 hidden sm:inline">{{ 'search_advanced_filters_button' | translate }}</span>
            </button>

            <button *ngIf="hasOptions() && userChangeOptions()" mat-flat-button color="accent" type="button"
                (click)="openOptions()" [matBadge]="userChangeOptions() ? ' ' : ''" matBadgeSize="small"
                matBadgePosition="above after" matBadgeColor="warn"
                [matTooltip]="'search_advanced_filters_tooltip' | translate">
                <mat-icon class="icon-size-5" [svgIcon]="'heroicons_solid:adjustments-horizontal'"></mat-icon>
                <span class="ml-2 hidden sm:inline">{{ 'search_advanced_filters_button' | translate }}</span>
            </button>

            <button mat-stroked-button type="button" (click)="clearForm()"
                [matTooltip]="'search_clear_tooltip' | translate">
                <mat-icon class="icon-size-5" [svgIcon]="'heroicons_outline:x-mark'"></mat-icon>
                <span class="ml-2 hidden sm:inline">{{ 'search_clear_button' | translate }}</span>
            </button>

            <button mat-flat-button color="accent" type="button" (click)="onSubmitSearch()"
                [matTooltip]="'search_submit_tooltip' | translate">
                <mat-icon class="icon-size-5" [svgIcon]="'heroicons_outline:magnifying-glass'"></mat-icon>
                <span class="ml-2 hidden sm:inline">{{ 'search_submit_button' | translate }}</span>
            </button>

        </div>
    </mat-action-row>

</mat-expansion-panel>

--- FILE: @fwk/components/crud/crud-search/search.component.ts ---

﻿import { OnInit, Component, Injector, Input, Output, EventEmitter, ViewChild, AfterViewInit, ChangeDetectionStrategy, ChangeDetectorRef, forwardRef, OnChanges, SimpleChanges } from '@angular/core';
import { CommonModule, I18nPluralPipe } from '@angular/common';
import { FormGroup, FormsModule, NgForm, ReactiveFormsModule } from '@angular/forms';
import { MatButtonModule } from '@angular/material/button';
import { MatIconModule } from '@angular/material/icon';
import { MatTooltipModule } from '@angular/material/tooltip';
import { MatExpansionPanel, MatExpansionModule } from '@angular/material/expansion';
import { MatBadgeModule } from '@angular/material/badge';
import { MatMenuModule } from '@angular/material/menu';
import { MatCheckboxModule } from '@angular/material/checkbox';

import { AbstractComponent } from '../../abstract-component.component';
import { DynamicField } from '../../../model/dynamic-form/dynamic-field';
import { DialogService } from '../../../services/dialog-service/dialog.service';
import { LocalStorageService } from '../../../services/local-storage/local-storage.service';
import { FormService } from '@fwk/services/dynamic-form/form.service';
import { CrudDef } from '../../../model/component-def/crud-def';
import { DynamicFormComponent } from '../../dynamic-form/dynamic-form.component';
import { TranslatePipe } from '../../../pipe/translate.pipe';
import { I18n } from '../../../model/i18n';

@Component({
   selector: 'fwk-search',
  templateUrl: './search.component.html',
  styleUrls: ['./search.component.scss'],
  standalone: true,
  imports: [
    CommonModule,
    FormsModule,
    ReactiveFormsModule,
    MatButtonModule,
    MatIconModule,
    MatTooltipModule,
    MatExpansionModule,
    MatBadgeModule,
    MatMenuModule,
    MatCheckboxModule,
    forwardRef(() => DynamicFormComponent),
    I18nPluralPipe,
    TranslatePipe
  ],
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class SearchComponent extends AbstractComponent implements OnInit, AfterViewInit, OnChanges {

  @Input() title: string | undefined;
  @Input() forceFirstSubmit: boolean = false;
  @Input() fields!: DynamicField<any>[];
  @Input() crudDef!: CrudDef;
  @Input() columnsDef: any[] = [];
  @Input() displayedColumns: string[] = [];
  @Input() override i18n: I18n;

  @Output() displayedColumnsChange = new EventEmitter<string[]>();
  @Output() onChangeSearchEntity = new EventEmitter<any>();

  @ViewChild('ngformElement') ngFormElement!: NgForm;
  @ViewChild('searchPanel') searchPanel!: MatExpansionPanel;

  firstSubmitForced: boolean = false;
  form: FormGroup = new FormGroup({});
  entity: any = {};
  generalFields: DynamicField<any>[] = [];
  visibleGeneralFields: DynamicField<any>[] = [];
  hasVisibleFields: boolean = false;
  fieldsOptions: DynamicField<any>[] = [];
  activeFilterCount = 0;

  columnVisibility = new Map<string, boolean>();
  menuColumns: { columnDef: string, columnName: string }[] = [];
  columnsAltered: boolean = false;
  private initialDisplayableColumns: string[] = [];

  private cacheFields: DynamicField<any>[] = [];
  private dialogService: DialogService;
  private localStorageService: LocalStorageService;
  private formService: FormService;

  activeFilterCountMapping: any;

  constructor(
    private injector: Injector,
    private _cdr: ChangeDetectorRef,
  ) {
    super(injector);
    this.dialogService = injector.get(DialogService);
    this.localStorageService = injector.get(LocalStorageService);
    this.formService = injector.get(FormService);
  }

  ngOnChanges(changes: SimpleChanges): void {
    if (changes['fields']) {
      this.onInit();
      this.updateActiveFilterCount();

      this.initialDisplayableColumns = [...this.displayedColumns];
      this.buildMenuColumns();
      this.initializeColumnVisibility();
    } else {
      if (changes['displayedColumns']) {
        this.initializeColumnVisibility();
      }
      if (changes['columnsDef']) {
        this.buildMenuColumns();
      }
    }
  }

  override ngOnInit(): void {
    super.ngOnInit();
    this.activeFilterCountMapping = {
      '=1': this.translate('search_filter_count_singular'),
      'other': this.translate('search_filter_count_plural')
    };
    this.onInit();
    this.updateActiveFilterCount();
  }

  ngAfterViewInit(): void {
    if (this.forceFirstSubmit && !this.firstSubmitForced) {
      if (!this.crudDef?.cancelInitSearch || this.userChangeOptions()) {
        Promise.resolve().then(() => {
          this.onSubmitSearch();
          this._cdr.markForCheck();
        });
      }
    }
  }

  private buildMenuColumns(): void {
    if (!this.columnsDef || !this.initialDisplayableColumns) {
      this.menuColumns = [];
      return;
    }

    const allColsMap = new Map(this.columnsDef.map(c => [c.columnDef, c]));

    this.menuColumns = this.initialDisplayableColumns
      .map(columnDef => allColsMap.get(columnDef))
      .filter(col => !!(col && col.columnName))
      .map(col => ({
        columnDef: col.columnDef,
        columnName: col.columnName
      }));
  }

  private initializeColumnVisibility(): void {
    if (this.columnsDef) {
      this.columnsDef.forEach(col => {
        this.columnVisibility.set(col.columnDef, this.displayedColumns.includes(col.columnDef));
      });
      this._checkColumnsAltered();
    }
  }

  toggleColumnVisibility(columnDef: string): void {
    const isVisible = this.columnVisibility.get(columnDef);
    this.columnVisibility.set(columnDef, !isVisible);

    const newDisplayedColumns = this.columnsDef
      .filter(col => this.columnVisibility.get(col.columnDef))
      .map(col => col.columnDef);

    this.displayedColumnsChange.emit(newDisplayedColumns);
    this._checkColumnsAltered();
  }

  onInit() {
    this.form = new FormGroup({});
    this.reInit();
  }

  private reInit() {
    this.entity = {};
    this.cacheFields = this.fields ? this.localStorageService.clone(this.fields) : [];

    this.generalFields = this.getGeneralFields(this.cacheFields);
    this.fieldsOptions = this.cacheFields.filter(f => !f.options?.baseFilter);

    this.visibleGeneralFields = this.generalFields.filter(field =>
      field.controlType !== 'hidden' && !field.options?.hidden
    );

    this.hasVisibleFields = this.visibleGeneralFields.length > 0;

    if (!this.title) {
      this.title = this.translate('search_title');
    }

    this.entity = this.formService.getEntityFromFields(this.cacheFields);
  }

  private getGeneralFields(fields: DynamicField<any>[]): DynamicField<any>[] {
    const baseFilterFields = fields.filter(f => f.options?.baseFilter);

    if (baseFilterFields.length > 0) {
      return baseFilterFields;
    }

    fields.forEach(field => {
      if (field) {
        field.options = { ...field.options, baseFilter: true };
      }
    });
    return fields;
  }

  onChangeEntity(entityUpdate: any): void {
    this.entity = { ...this.entity, ...entityUpdate };
    this.updateActiveFilterCount();
  }

  clearForm(): void {
    const subForm = this.form.get('subForm');
    if (subForm) {
      subForm.reset();
    }

    this.entity = {};

    this.displayedColumnsChange.emit([...this.initialDisplayableColumns]);
    this.initializeColumnVisibility();

    this.onSubmitSearch();
  }

  onSubmitSearch(): void {
    const subForm = this.form.get('subForm') as FormGroup;
    
    if (subForm) {
      this.entity = this.formService.injectToEntity(this.entity, subForm, this.fields);
    }

    if (!this.firstSubmitForced) {
      this.firstSubmitForced = true;
    }

    this.onChangeSearchEntity.emit(this.entity);
    this.updateActiveFilterCount();

    if (this.searchPanel) {
      setTimeout(() => {
        this.searchPanel.close();
        this._cdr.markForCheck();
      }, 0);
    }
  }

  submitOnEnter(event: KeyboardEvent): void {
    if (this.form.valid && event.key === 'Enter') {
      event.preventDefault();
      this.onSubmitSearch();
    }
  }

  hasOptions(): boolean {
    return this.fieldsOptions && this.fieldsOptions.length > 0;
  }

  userChangeOptions(): boolean {
    if (!this.fieldsOptions || !this.entity) {
      return false;
    }

    return this.fieldsOptions.some(field => {
      const value = this.entity[field.key];

      if (field.controlType === 'checkbox') {
        return value === true;
      }

      return value != null && value !== '';
    });
  }

  openOptions(): void {
    if (!this.i18n) {
      console.error('[FWK] El objeto de internacionalización (i18n) no está definido.');
      return;
    }

    const formDef = {
      key: 'searchOptions',
      fields: this.fieldsOptions
    };

    const dialogRef = this.dialogService.showFormDialog({
      i18n: this.i18n,
      formDef: formDef,
      entity: this.entity,
      modalName: this.translate('search_modal_title'),
      onSubmit: (entity: any) => {
        this.onChangeEntity(entity);
        this.onSubmitSearch();
        dialogRef.close();
      }
    });

    dialogRef.afterClosed().subscribe(() => {
      this._cdr.markForCheck();
    });
  }

  private updateActiveFilterCount(): void {
    if (!this.entity || !this.fields) {
      this.activeFilterCount = 0;
      this._cdr.markForCheck();
      return;
    }

    this.activeFilterCount = this.fields.reduce((count, field) => {
      const value = this.entity[field.key];

      if (field.controlType === 'checkbox') {
        if (value === true) {
          return count + 1;
        }
        return count;
      }

      if (value !== null && value !== undefined && value !== '') {
        return count + 1;
      }

      return count;
    }, 0);

    this._cdr.markForCheck();
  }

  private _checkColumnsAltered(): void {
    if (!this.initialDisplayableColumns || !this.columnsDef) {
      this.columnsAltered = false;
      return;
    }

    const currentVisibleColumns = this.columnsDef
      .filter(col => this.columnVisibility.get(col.columnDef))
      .map(col => col.columnDef);

    const initialSorted = [...this.initialDisplayableColumns].sort();
    const currentSorted = [...currentVisibleColumns].sort();

    this.columnsAltered = JSON.stringify(initialSorted) !== JSON.stringify(currentSorted);
  }
}

--- FILE: @fwk/components/crud/crud-table/crud-table.component.html ---

﻿<div *ngIf="initOk" class="relative" [ngClass]="containerClass">

    <div *ngIf="isLoading"
        class="absolute inset-0 z-10 dark:bg-gray-900 flex flex-col bg-card transition-opacity duration-300 overflow-hidden">
        <div class="p-6 space-y-4">
            <div *ngFor="let _ of repeatSkeleton" class="animate-pulse h-8 bg-gray-200 dark:bg-gray-700 rounded w-full">
            </div>
        </div>
    </div>

    <div class="transition-opacity duration-300" style="padding-bottom: 74px;">

        <div *ngIf="datasource?.data?.length > 0" class="overflow-x-auto container-table dark:bg-transparent bg-white">
            <mat-table matSort [dataSource]="datasource">

                <ng-container *ngIf="hasGeneralActions()" [matColumnDef]="getGeneralActionsColumnName()">
                    <mat-header-cell *matHeaderCellDef class="print:hidden column-action-table"
                        [ngClass]="grid.actionHeaderClass">
                        <mat-checkbox (change)="$event ? masterToggle() : null" [checked]="isAllSelected()"
                            [indeterminate]="selects && !isAllSelected()"
                            [matTooltip]="'table_select_all_tooltip' | translate">
                        </mat-checkbox>
                    </mat-header-cell>
                    <mat-cell *matCellDef="let element" class="print:hidden column-action-table"
                        [ngClass]="grid.actionCellClass">
                        <mat-checkbox *ngIf="getRow(element)?.selectable" (click)="$event.stopPropagation()"
                            [(ngModel)]="getRow(element)!.select">
                        </mat-checkbox>
                    </mat-cell>
                </ng-container>

                <ng-container *ngFor="let def of grid.columnsDef" [matColumnDef]="def.columnDef">
                    <mat-header-cell *matHeaderCellDef mat-sort-header [disabled]="isDisableSort(def.columnDef)"
                        [ngClass]="[def.headerClass || '', getColumnStyles(def)]" class="text-sm">
                        {{ def.columnName }}
                    </mat-header-cell>

                    <mat-cell *matCellDef="let element" [ngClass]="[def.cellClass || '', getColumnStyles(def)]">
                        <span>{{ getValue(element, def.columnDef, def) }}</span>
                    </mat-cell>
                </ng-container>

                <ng-container *ngIf="hasActions()" [matColumnDef]="getActionsColumnName()">
                    <mat-header-cell *matHeaderCellDef class="column-action-table justify-end print:hidden"
                        [ngClass]="grid.actionHeaderClass">
                    </mat-header-cell>
                    <mat-cell *matCellDef="let element" class="column-action-table justify-end print:hidden"
                        [ngClass]="grid.actionCellClass">

                        <ng-container *ngIf="grid.groupActions !== false">
                            <ng-container *ngIf="getActionsByElement(element) as actions">

                                <ng-container *ngIf="actions.length > 1">
                                    <button mat-icon-button [matBadge]="actions.length" matBadgeColor="accent"
                                        matBadgeSize="small" [matTooltip]="'table_action_button' | translate"
                                        [matMenuTriggerFor]="actionsMenu" (click)="$event.stopPropagation()">
                                        <mat-icon [svgIcon]="'heroicons_outline:ellipsis-vertical'"></mat-icon>
                                    </button>
                                    <mat-menu #actionsMenu="matMenu" class="rounded-xl">
                                        <ng-container *ngFor="let action of actions">
                                            <button mat-menu-item (click)="submitAction(action, element, $event)">
                                                <ng-container *ngIf="action.icon">
                                                    <mat-icon *ngIf="action.icon.includes(':')"
                                                        [svgIcon]="action.icon"></mat-icon>
                                                    <mat-icon *ngIf="!action.icon.includes(':')">{{ action.icon
                                                        }}</mat-icon>
                                                </ng-container>
                                                <span>{{ action.actionName }}</span>
                                            </button>
                                        </ng-container>
                                    </mat-menu>
                                </ng-container>

                                <ng-container *ngIf="actions.length === 1">
                                    <button mat-icon-button [matTooltip]="actions[0].actionName"
                                        (click)="submitAction(actions[0], element, $event)">
                                        <ng-container *ngIf="actions[0].icon">
                                            <mat-icon *ngIf="actions[0].icon.includes(':')"
                                                [svgIcon]="actions[0].icon"></mat-icon>
                                            <mat-icon *ngIf="!actions[0].icon.includes(':')">{{ actions[0].icon
                                                }}</mat-icon>
                                        </ng-container>
                                        <mat-icon *ngIf="!actions[0].icon"
                                            [svgIcon]="'heroicons_outline:cog-6-tooth'"></mat-icon>
                                    </button>
                                </ng-container>

                            </ng-container>
                        </ng-container>

                        <ng-container *ngIf="grid.groupActions === false">
                            <ng-container *ngFor="let action of getActionsByElement(element)">
                                <button mat-icon-button [matTooltip]="action.actionName"
                                    (click)="submitAction(action, element, $event)">
                                    <ng-container *ngIf="action.icon; else defaultCogIcon">
                                        <mat-icon *ngIf="action.icon.includes(':')" [svgIcon]="action.icon"></mat-icon>
                                        <mat-icon *ngIf="!action.icon.includes(':')">{{ action.icon }}</mat-icon>
                                    </ng-container>
                                    <ng-template #defaultCogIcon>
                                        <mat-icon [svgIcon]="'heroicons_outline:cog-6-tooth'"></mat-icon>
                                    </ng-template>
                                </button>
                            </ng-container>
                        </ng-container>

                    </mat-cell>
                </ng-container>

                <mat-header-row *matHeaderRowDef="grid.displayedColumns; sticky: true"></mat-header-row>
                <mat-row *matRowDef="let row; columns: grid.displayedColumns;" class="cursor-pointer"
                    (click)="onClickRowEvent(row)">
                </mat-row>
            </mat-table>
        </div>

        <div *ngIf="!isLoading && datasource?.data?.length === 0"
            class="flex flex-col items-center justify-center p-16 bg-white dark:bg-transparent rounded-lg">

            <ng-container *ngIf="hasActiveFilters">
                <mat-icon svgIcon="heroicons_outline:magnifying-glass"
                    class="!w-20 !h-20 text-gray-300 mb-4"></mat-icon>
                <span class="text-2xl font-bold text-gray-700 dark:text-gray-200">{{ 'table_no_records_found_title' |
                    translate }}</span>
                <span class="text-md text-secondary mb-6">{{ 'table_no_records_found_subtitle' | translate }}</span>
                <button mat-flat-button color="accent" (click)="triggerClearFilters()">
                    <mat-icon [svgIcon]="'heroicons_outline:x-mark'"></mat-icon>
                    <span class="ml-2">{{ 'table_clear_filters_button' | translate }}</span>
                </button>
            </ng-container>

            <ng-container *ngIf="!hasActiveFilters && crud?.crudDef?.cancelInitSearch && !searchPerformed">
                <mat-icon [svgIcon]="'heroicons_outline:magnifying-glass'"
                    class="!w-20 !h-20 text-gray-300 mb-4"></mat-icon>
                <span class="text-2xl font-bold text-gray-700 dark:text-gray-200">{{ 'table_initial_search_prompt_title'
                    | translate }}</span>
                <span class="text-md text-secondary">{{ 'table_initial_search_prompt_subtitle' | translate }}</span>
            </ng-container>

            <ng-container *ngIf="!hasActiveFilters && (!crud?.crudDef?.cancelInitSearch || searchPerformed)">
                <mat-icon [svgIcon]="'heroicons_outline:circle-stack'"
                    class="!w-20 !h-20 text-gray-300 mb-4"></mat-icon>
                <span class="text-2xl font-bold text-gray-700 dark:text-gray-200">{{ 'table_empty_state_title' |
                    translate }}</span>
                <span class="text-md text-secondary mb-6" *ngIf="canAdd">{{ 'table_empty_state_subtitle' | translate
                    }}</span>
                <button *ngIf="canAdd" mat-flat-button color="accent" (click)="triggerAdd()">
                    <mat-icon [svgIcon]="'heroicons_outline:plus'"></mat-icon>
                    <span class="ml-2">{{ 'add_button' | translate }}</span>
                </button>
            </ng-container>
        </div>

        <mat-paginator *ngIf="datasource?.data?.length > 0" #paginator [length]="totalSize" [pageIndex]="currentPage" [pageSize]="pageSize"
            class="border-t bottom-0 fixed print:hidden w-full z-30" [pageSizeOptions]="[10, 25, 50, 100, 500]"
            [showFirstLastButtons]="true" (page)="onPageFired($event)" [hidden]="datasource?.data?.length === 0">
        </mat-paginator>
    </div>
</div>

--- FILE: @fwk/components/crud/crud-table/crud-table.component.ts ---

﻿import { Component, OnInit, Input, ViewChild, Output, EventEmitter, Injector, AfterViewInit, ChangeDetectionStrategy, ChangeDetectorRef } from '@angular/core';
import { CommonModule, SlicePipe } from '@angular/common';
import { FormsModule } from '@angular/forms';
import { MatDialog } from '@angular/material/dialog';
import { MatPaginator, MatPaginatorIntl, MatPaginatorModule } from '@angular/material/paginator';
import { MatProgressSpinnerModule } from '@angular/material/progress-spinner';
import { MatSort, MatSortModule } from '@angular/material/sort';
import { MatTableDataSource, MatTableModule } from '@angular/material/table';
import { animate, state, style, transition, trigger } from '@angular/animations';
import { Params, RouterModule } from '@angular/router';

import { MatCheckboxModule } from '@angular/material/checkbox';
import { MatButtonModule } from '@angular/material/button';
import { MatIconModule } from '@angular/material/icon';
import { MatTooltipModule } from '@angular/material/tooltip';

import { AbstractComponent } from '../../abstract-component.component';
import { GenericHttpService } from '../../../services/generic-http-service/generic-http.service';
import { BasicModalComponent } from '../basic-modal/basic-modal.component';
import { LocalStorageService } from '../../../services/local-storage/local-storage.service';
import { SpinnerService } from '../../../modules/spinner/service/spinner.service';
import { ACTION_TYPES, ActionDef } from '../../../model/component-def/action-def';
import { FileService } from '../../../services/file/file.service';
import { DialogService } from '../../../services/dialog-service/dialog.service';
import { GridDef } from '../../../model/component-def/grid-def';
import { ExpressionService } from '../../../services/expression-service/expression.service';
import { ActionDefService } from '../../../services/action-def-service/action-def.service';
import { DisplayActionsCondition } from '../../../model/display-actions-condition';
import { DynamicFieldConditionIf } from '../../../model/dynamic-form/dynamic-field-condition-if';
import { FilterService } from '../../../services/filter-service/filter.service';
import { ComponentDefService } from '@fwk/services/component-def-service/component-def.service';
import { TranslatePipe } from '../../../pipe/translate.pipe';
import { Row, StatusTable } from './crud-table.model';
import { AuthService } from '@fwk/auth/auth.service';
import { MatMenuModule } from '@angular/material/menu';
import { FormService } from '@fwk/services/dynamic-form/form.service';

const ACTION_COLUMN = '_action';
const GENERAL_ACTION_COLUMN = '_general_action';

@Component({
    selector: 'fwk-crud-table',
    templateUrl: './crud-table.component.html',
    styleUrls: ['./crud-table.component.scss'],
    standalone: true,
    imports: [
        CommonModule, FormsModule, RouterModule,
        MatTableModule, MatSortModule, MatPaginatorModule,
        MatCheckboxModule, MatButtonModule, MatIconModule, MatTooltipModule,
        MatProgressSpinnerModule, SlicePipe, TranslatePipe, MatMenuModule
    ],
    animations: [
        trigger('groupButtons', [
            state('true', style({ width: '*', opacity: 1 })),
            state('false', style({ width: '0px', opacity: 0, margin: '0px' })),
            transition('true <=> false', animate('225ms cubic-bezier(0.4, 0.0, 0.2, 1)')),
        ]),
    ],
    changeDetection: ChangeDetectionStrategy.OnPush,
})
export class CrudTableComponent extends AbstractComponent implements OnInit, AfterViewInit {

    @Input() isLoading: boolean = false;
    @Input() crud: any;
    @Input() grid!: GridDef;
    @Input() onClickRow: any;
    @Input() urlDelete: any;
    @Input() selectable!: boolean;
    @Input() hasActiveFilters: boolean = false;
    @Input() canAdd: boolean = false;
    @Input() canDelete: boolean = false;
    @Input() containerClass: string = '';
    @Input() searchPerformed: boolean = false;

    public repeatSkeleton = new Array(9).fill(0);

    @Input()
    set datasource(data: any[]) {
        if (data) {
            this._datasource = new MatTableDataSource(data);
            this.wireUpDataSource();

            if (this.crud && this.crud.crudDef) {
                this.totalSize = this.crud.crudDef.serverPagination ? this.filterService.totalReg : data.length;
            } else {
                this.totalSize = data.length;
            }
            this.openActionsArray = new Array(data.length).fill(false);

            this.statustable.statusChanges.subscribe((statustable) => {
                this.status.emit(statustable);
            });

            this.rows = data.map((element, index) => {
                const isSelectable = this.isRowSelectable(element, this.grid.selectCondition);
                return new Row(element, index, false, isSelectable);
            });
            this.statustable.rows = this.rows;

            this._cdr.markForCheck();
        }
    }
    get datasource(): MatTableDataSource<any> {
        return this._datasource;
    }

    @Input()
    set tabledef(tabledef: GridDef) {
        this.grid = tabledef;
    }

    @Output() status = new EventEmitter<StatusTable<any>>();
    @Output() onChangePagination = new EventEmitter<void>();
    @Output() onAddClicked = new EventEmitter<void>();
    @Output() onClearFiltersClicked = new EventEmitter<void>();
    @Output() onRowClicked = new EventEmitter<any>();

    @ViewChild(MatPaginator) paginator!: MatPaginator;
    @ViewChild(MatSort) sort!: MatSort;

    statustable: StatusTable<any>;
    _datasource!: MatTableDataSource<any>;
    selectedRowIndex: number | null = null;
    rows: Row[] = [];
    initOk: boolean = false;
    pageSize: number;
    currentPage: number;
    totalSize = 0;
    openActionsArray: boolean[] = [];

    protected genericHttpService: GenericHttpService;
    private localStorageService: LocalStorageService;
    private spinnerService: SpinnerService;
    private spinnerGeneralControl: any;
    private fileService: FileService;
    private columnDefId: string | undefined;
    private dialogService: DialogService;
    private expressionService: ExpressionService;
    private actionDefService: ActionDefService;
    private filterService: FilterService;
    private _selects: boolean = false;
    private resetSelects: boolean = false;
    private authService: AuthService;
    private formService: FormService;

    constructor(
        public injector: Injector,
        private _cdr: ChangeDetectorRef,
    ) {
        super(injector);
        this.authService = injector.get(AuthService);
        this.genericHttpService = injector.get(GenericHttpService);
        this.localStorageService = injector.get(LocalStorageService);
        this.spinnerService = injector.get(SpinnerService);
        this.fileService = injector.get(FileService);
        this.dialogService = injector.get(DialogService);
        this.expressionService = injector.get(ExpressionService);
        this.actionDefService = injector.get(ActionDefService);
        this.componentDefService = injector.get(ComponentDefService);
        this.filterService = injector.get(FilterService);
        this.formService = injector.get(FormService);
        this.pageSize = this.crud?.crudDef?.pagination?.pageSize ?? 10;
        this.currentPage = this.crud?.crudDef?.pagination?.page ?? 0;

        this.setUpI18n({
            name: 'crud_table', lang: 'es',
            words: {
                itemsPerPageLabel: 'Items por página',
                boolean_true: 'Sí', boolean_false: 'No',
                action_delete: 'Eliminar', grid_action_button_delete: 'Eliminar',
            }
        });
        this.statustable = new StatusTable<any>();
    }

    override ngOnInit(): void {
        super.ngOnInit();
        this.onInit();
    }

    ngAfterViewInit(): void {
        if (this.paginator) {
            this.paginator._intl = new MatPaginatorIntl();
            this.paginator._intl.itemsPerPageLabel = this.translate('table_items_per_page');
        }
        this.wireUpDataSource();
    }

    onInit(): void {
        this.spinnerGeneralControl = this.spinnerService.getControlGlobalSpinner();

        const hasGeneral = this.hasGeneralActions();
        const hasRegularActions = this.hasActions();

        if (hasGeneral && !this.grid.displayedColumns.includes(GENERAL_ACTION_COLUMN)) {
            this.grid.displayedColumns.unshift(GENERAL_ACTION_COLUMN);
        }

        if (hasRegularActions && !this.grid.displayedColumns.includes(ACTION_COLUMN)) {
            const insertIndex = hasGeneral ? 1 : 0;
            this.grid.displayedColumns.splice(insertIndex, 0, ACTION_COLUMN);
        }

        const columnDefId = this.grid.columnsDef.find(c => c.id);
        if (columnDefId) {
            this.columnDefId = columnDefId.columnDef;
        }
        this.initOk = true;
    }

    private wireUpDataSource(): void {
        if (this._datasource) {
            if (this.crud && this.crud.crudDef && this.crud.crudDef.serverPagination === false) {
                this._datasource.paginator = this.paginator;
            } else {
                this._datasource.paginator = null;
            }
            this._datasource.sort = this.sort;
        }
    }

    groupActionButton(index: number): void {
        const currentState = this.openActionsArray[index];
        this.openActionsArray.fill(false);
        this.openActionsArray[index] = !currentState;
    }

    hasActions(): boolean {
        if (!this.grid.actions) {
            return false;
        }

        const hasVisibleActions = this.grid.actions.some(action =>
            this.authService.hasPermission(action.actionSecurity)
        );

        return hasVisibleActions;
    }

    getGeneralActionsColumnName(): string {
        return GENERAL_ACTION_COLUMN;
    }

    getActionsColumnName(): string {
        return ACTION_COLUMN;
    }

    hasGeneralActions(): boolean {
        if (this.selectable) {
            return true;
        }
        return !!(this.grid?.deleteAction || this.grid?.deleteColumn) && this.canDelete;
    }

    getActionsByElement(element: any): ActionDef[] {
        const conditions = this.grid.displayedActionsCondition as DisplayActionsCondition[] | undefined;
        let actions = this.actionDefService.getActions(conditions || [], this.grid.actions || [], element);

        actions = actions.filter(action => this.authService.hasPermission(action.actionSecurity!));

        return actions;
    }

    submitAction(action: ActionDef, entity: any, $event: MouseEvent): void {
        $event.stopPropagation();
        if (this.columnDefId) {
            entity.id = entity[this.columnDefId];
        }
        if (action.gridModal) {
            this.dialogService.showGridModal({
                title: action.actionName,
                entities: entity[action.gridModal.fromArrayField],
                gridDef: action.gridModal.gridDef
            });
        } else if (action.confirm) {
            this.actionDefService.submitAction(action, entity, this.crud.i18nCurrentCrudComponent, undefined)
                .subscribe(r => {
                    this.spinnerGeneralControl.hide();
                    if ((r && r.success === true) || r === true) {
                        this.crud.findAll();
                        this.notificationService.notifySuccess(this.crud.translate('success_message'));
                    } else if (r && r.success === false && r.message) {
                        this.notificationService.notifyError(r.message);
                    }
                });
        } else if (action.form || action.formDef) {
            const actionClone = this.localStorageService.clone(action);
            const dictionaryName = this.crud.crudDef?.i18n?.name;
            const i18n = dictionaryName ? this.i18nService.getDictionary(dictionaryName) : undefined;

            if (actionClone.formDef) {
                this.formService.setUpFormDef(i18n, actionClone.formDef);
            }
            if (actionClone.form) {
                this.formService.setUpFieldTextFromI18n(i18n, actionClone.form);
            }

            const data = {
                entity: entity,
                config: actionClone,
                formDef: actionClone.formDef,
                fields: actionClone.form || actionClone.formDef?.fields,
                i18n: this.crud.i18nCurrentCrudComponent,
            };


            const dialogRef = this.injector.get(MatDialog).open(BasicModalComponent, {
                width: this.crud.crudDef.dialogConfig?.width || '320px',
                panelClass: 'control-mat-dialog',
                data: data
            });
            dialogRef.afterClosed().subscribe(() => this.crud.findAll());
        } else {
            if (ACTION_TYPES.file_download === action.actionType) {
                this.spinnerGeneralControl.show();
                this.fileService.downloadFileByAction(action, entity).subscribe({
                    complete: () => { this.spinnerGeneralControl.hide(); }
                });
            } else if (ACTION_TYPES.file_preview === action.actionType) {
                this.spinnerGeneralControl.show();
                this.fileService.previewFileByAction(action, entity).subscribe({
                    complete: () => { this.spinnerGeneralControl.hide(); }
                });
            } else if (ACTION_TYPES.redirect === action.actionType) {
                this.handleRedirectAction(action, entity, $event);
            } else {
                this.spinnerGeneralControl.show();
                this.genericHttpService.callWs(action.ws, entity).subscribe({
                    next: () => {
                        this.crud.findAll();
                        this.notificationService.notifySuccess(this.crud.translate('success_message'));
                    },
                    complete: () => { this.spinnerGeneralControl.hide(); }
                });
            }
        }
    }

    private handleRedirectAction(action: any, entity: any, $event: MouseEvent): void {
        this.spinnerGeneralControl.show();
        let url: string = action.redirect.url;
        const queryParams: Params = this.getQueryParams(action.redirect.querystring, entity);

        if (queryParams['externalUrl']) {
            url = queryParams['externalUrl'];
            if (!url.startsWith('http://') && !url.startsWith('https://')) {
                url = 'http://' + url;
            }
            delete queryParams['externalUrl'];
        }

        if (action.redirect.openTab || $event.ctrlKey) {
            let queryParamsString = "";
            if (Object.keys(queryParams).length > 0) {
                const paramsStr = new URLSearchParams(queryParams).toString();
                if (paramsStr) {
                    queryParamsString = (url.includes('?') ? '&' : '?') + paramsStr;
                }
            }
            this.spinnerGeneralControl.hide();
            window.open(url + queryParamsString, '_blank')?.focus();
        } else {
            this.router.navigate([url], { queryParams }).finally(() => this.spinnerGeneralControl.hide());
        }
    }

    getQueryParams(querystring: any, entity: any): Params {
        const queryParams: Params = {};
        if (querystring && entity) {
            Object.keys(querystring).forEach(key => {
                const entityKey = querystring[key];
                if (entity[entityKey] !== undefined && entity[entityKey] !== null) {
                    queryParams[key] = entity[entityKey];
                }
            });
        }
        return queryParams;
    }

    onClickRowEvent(row: any): void {
        this.onRowClicked.emit(row);
    }

    getValue(element: any, attribute: string, def: any = null): any {
        let obj = attribute.split('.').reduce((acc, part) => acc && acc[part], element);

        if (def?.columnType && obj != null && obj !== '') {
            if (def.columnType === 'datehour') {
                const date = new Date(Date.parse(obj));
                return date.toLocaleDateString('es-ES') + " " + date.toLocaleTimeString([], { hour12: false, hour: "2-digit", minute: "2-digit" });
            } else if (def.columnType === 'date') {
                return new Date(Date.parse(obj)).toLocaleDateString('es-ES');
            }
        }
        if (typeof obj === 'boolean' || obj === 'true' || obj === 'false') {
            return this.translate(JSON.parse(String(obj)) ? 'boolean_true' : 'boolean_false');
        }
        if (def?.translate && obj) {
            const key = `grid_column_value_translate_${attribute.replace('.', '_').toLowerCase()}_${String(obj).toLowerCase()}`;
            return this.translate(key);
        }
        return obj;
    }

    override translate(key: string): string {
        const value = this.crud?.i18nComponent?.translate(key);
        return (value && value !== key) ? value : super.translate(key);
    }

    isRowSelectable(element: any, displaySelectCondition: DynamicFieldConditionIf | undefined): boolean {
        return !displaySelectCondition || this.expressionService.evaluate(displaySelectCondition, element);
    }

    getRowId(row: any): any {
        const idDef = this.grid.columnsDef.find(c => c.id);
        const idKey = idDef ? idDef.columnDef : 'id';
        return row[idKey];
    }

    getRow(element: any): Row | undefined {
        return this.rows.find(e => e.obj === element);
    }

    isDisableSort(columnKey: string): boolean {
        const def = this.grid.columnsDef.find(x => x.columnDef === columnKey);
        return def?.sort?.disabled ?? !(this.grid.sortAllColumns ?? false);
    }

    restartActionButtons(): void {
        this.openActionsArray.fill(false);
    }

    orderStart(columnKey: string): 'asc' | 'desc' {
        const def = this.grid.columnsDef.find(x => x.columnDef === columnKey);
        return def?.sort?.type || 'asc';
    }

    resetSelectAll(): void {
        this.resetSelects = true;
        this._selects = false;
    }

    override getI18nName(): string {
        return 'crud_table';
    }

    get selects(): boolean {
        const selectableRows = this.rows.filter(r => r.selectable);
        if (!selectableRows.length) return false;
        return this._selects && selectableRows.every(r => r.select);
    }

    set selects(value: boolean) {
        this._selects = value;
        if (this.resetSelects) {
            this.resetSelects = false;
        } else {
            this.rows.forEach(r => {
                if (r.selectable) r.select = value;
            });
        }
    }

    masterToggle(): void {
        this.selects = !this.isAllSelected();
    }

    isAllSelected(): boolean {
        const selectableRows = this.rows.filter(r => r.selectable);
        if (!selectableRows.length) return false;
        return selectableRows.every(r => r.select);
    }

    onPageFired(event: any): void {
        this.currentPage = event.pageIndex;
        this.pageSize = event.pageSize;
        if (this.crud.crudDef.pagination) {
            this.crud.crudDef.pagination.page = event.pageIndex;
            this.crud.crudDef.pagination.pageSize = event.pageSize;
        }
        this.onChangePagination.emit();
    }

    triggerAdd(): void {
        this.onAddClicked.emit();
    }

    triggerClearFilters(): void {
        this.onClearFiltersClicked.emit();
    }

    getColumnStyles(def: any): string {
        const classes = [];

        if (def.fitContent || def.ajustarContenido) classes.push('fit-content');

        if (def.wrapText || def.multiline) {
            classes.push('text-wrap');
        } else {
            classes.push('text-nowrap');
        }

        const alignment = def.textAlign || def.aligntext;
        if (alignment) classes.push(`text-${alignment}`);

        return classes.join(' ').trim();
    }
}

--- FILE: @fwk/components/crud/crud-table/crud-table.model.ts ---

import { Observable, Subscriber } from 'rxjs';

export class Row {
    rowNumber: number;
    obj: any;
    statusChanges: Observable<Row>;
    selectable: boolean;

    private _select: boolean;
    private observer!: Subscriber<Row>;

    constructor(obj: any, rowNumber: number, select: boolean, selectable: boolean) {
        this.obj = obj;
        this.rowNumber = rowNumber;
        this._select = select;
        this.selectable = selectable;

        this.statusChanges = new Observable<Row>((observer) => {
            this.observer = observer;
        });
    }

    get select(): boolean {
        return this._select;
    }

    set select(select: boolean) {
        if (this.selectable) {
            if (this._select !== select) {
                this._select = select;
                if (this.observer) {
                    this.observer.next(this);
                }
            }
        }
    }
}

export class StatusTable<E> {
    private _rows: Row[] = [];
    private observer!: Subscriber<StatusTable<E>>;

    statusChanges = new Observable<StatusTable<E>>((observer) => {
        this.observer = observer;
    });

    set rows(rows: Row[]) {
        this._rows = rows;
        this._rows.forEach((row) => {
            row.statusChanges.subscribe(() => {
                if (this.observer) {
                    this.observer.next(this);
                }
            });
        });
        if (this.observer) {
            this.observer.next(this);
        }
    }

    get selects(): E[] {
        if (this._rows) {
            return this._rows
                .filter(e => e.select)
                .map(e => e.obj as E);
        }
        return [];
    }

    existSelectedItems(): boolean {
        return this.selects.length > 0;
    }
}

--- FILE: @fwk/components/crud/crud.component.html ---

﻿<div class="flex flex-col flex-auto min-w-0" *ngIf="crudDef && name">
    <div class="flex flex-col items-center justify-center border-b bg-card dark:bg-transparent ">
        <div class="flex flex-col sm:flex-row flex-0 sm:items-center sm:justify-between p-4 sm:px-6 pt-2 w-full">
            <div class="flex-1 min-w-0">
                <div class="flex items-center gap-2">
                    <div class="text-3xl font-extrabold tracking-tight leading-7 sm:leading-10 truncate">
                        {{ crudDef.i18n?.words?.['page_title'] || ('page_title_default' | translate) }}
                    </div>
                    <back-button *ngIf="crudDef.backButton" color="accent"></back-button>
                </div>

                <div class="text-lg text-secondary" *ngIf="parentTitle">
                    {{ parentTitle }}
                </div>

                <div class="mt-2 text-lg text-secondary" *ngIf="!parentTitle && crudDef.subtitleKey">
                    {{ crudDef.subtitleKey | translate:crudDef.i18n?.name }}
                </div>
            </div>

            <div class="flex shrink-0 items-center mt-6 sm:mt-0 sm:ml-4 space-x-2 print:hidden">
                <ng-container *ngIf="showCrudActions()">
                    <button *ngFor="let action of getCrudActions()" mat-stroked-button color="accent"
                        [matTooltip]="action.actionName"
                        [disabled]="isTableLoading || actionLoadingStates.get(action.actionNameKey || action.actionName || 'default')"
                        (click)="executeCrudAction(action)">
                        <ng-container
                            *ngIf="!actionLoadingStates.get(action.actionNameKey || action.actionName || 'default')">
                            <mat-icon *ngIf="action.icon" [svgIcon]="action.icon"></mat-icon>
                            <span class="ml-2 hidden sm:inline">{{ action.actionName }}</span>
                        </ng-container>
                        <mat-progress-spinner
                            *ngIf="actionLoadingStates.get(action.actionNameKey || action.actionName || 'default')"
                            [diameter]="24" mode="indeterminate"></mat-progress-spinner>
                    </button>
                </ng-container>

                <button *ngIf="showDeleteButton() && display.selects" mat-stroked-button [color]="'warn'"
                    [matTooltip]="'delete_selected_tooltip' | translate" [disabled]="isTableLoading"
                    (click)="openDeleteDialog()">
                    <mat-icon [svgIcon]="'heroicons_outline:trash'"></mat-icon>
                    <span class="ml-2 hidden sm:inline">{{ 'crud_delete_button' | translate }} ({{ selects.length
                        }})</span>
                </button>

                <button *ngIf="crudDef.exportCsv" mat-icon-button color="accent" (click)="exportCsv()"
                    [matTooltip]="'export_csv_tooltip' | translate" [disabled]="isTableLoading">
                    <mat-icon [svgIcon]="'heroicons_outline:printer'"></mat-icon>
                </button>

                <button *ngIf="crudDef.downloadBoleta" mat-icon-button color="accent" (click)="downloadBoleta()"
                    [matTooltip]="'crud_download_boleta_tooltip' | translate" [disabled]="isTableLoading">
                    <mat-icon [svgIcon]="'heroicons_outline:document-text'"></mat-icon>
                </button>

                <button *ngIf="crudDef.openLink" mat-icon-button color="accent" (click)="goToLink(crudDef.openLink)"
                    [matTooltip]="crudDef.openLinkTitle || ('crud_open_link_default_tooltip' | translate)"
                    [disabled]="isTableLoading">
                    <mat-icon [svgIcon]="'heroicons_outline:envelope'"></mat-icon>
                </button>

                <button *ngIf="showAddButton()" mat-stroked-button color="accent" [disabled]="isTableLoading"
                    (click)="openAddDialog()">
                    <mat-icon [svgIcon]="'heroicons_outline:plus'"></mat-icon>
                    <span class="ml-2">{{ 'add_button' | translate }}</span>
                </button>
            </div>
        </div>

        <div *ngIf="crudDef.forms?.filter" class="w-full print:hidden">
            <fwk-search #searchComponent [fields]="crudDef.forms.filter"
                (onChangeSearchEntity)="filterSearchEntity($event)" [forceFirstSubmit]="true" [crudDef]="crudDef"
                [columnsDef]="crudDef.grid?.columnsDef" [displayedColumns]="crudDef.grid?.displayedColumns"
                (displayedColumnsChange)="onDisplayedColumnsChange($event)" [i18n]="i18nComponent">
            </fwk-search>
        </div>
    </div>

    <div class="flex-auto">
        <div class="relative overflow-hidden">
            <fwk-crud-table *ngIf="crudDef.grid" [containerClass]="isTableLoading ? 'h-[67vh]' : ''"
                [onClickRow]="onClickRow" [datasource]="dataSource" [canDelete]="showDeleteButton()"
                [searchPerformed]="searchPerformed"
                [grid]="crudDef.grid" [crud]="this" [isLoading]="isTableLoading" [hasActiveFilters]="hasActiveFilters"
                [canAdd]="showAddButton()" (status)="statusChanged($event)" (onChangePagination)="handlePageChange()"
                (onAddClicked)="openAddDialog()" (onClearFiltersClicked)="clearFilters()"
                (onRowClicked)="handleRowClick($event)">
            </fwk-crud-table>
        </div>
    </div>
</div>

--- FILE: @fwk/components/crud/crud.component.ts ---

﻿import {
  Component, OnInit, OnDestroy, Input, Output, EventEmitter,
  ViewEncapsulation, Injector, ChangeDetectionStrategy, ChangeDetectorRef, ViewChild
} from '@angular/core';
import { CommonModule } from '@angular/common';
import { Observable, of } from 'rxjs';
import { switchMap, finalize, map, tap } from 'rxjs/operators';
import { fuseAnimations } from '@fuse/animations';

import { AbstractCrudComponent } from './abstract-crud.component';
import { StatusTable } from './crud-table/crud-table.model';
import { CrudModalComponent } from './crud-modal/crud-modal.component';
import { I18n } from '../../model/i18n';
import { CrudDef } from '../../model/component-def/crud-def';
import { FormDef } from '../../model/form-def';
import { ActionDef } from '../../model/component-def/action-def';
import { AuthService } from '@fwk/auth/auth.service';

import { SearchComponent } from './crud-search/search.component';
import { CrudTableComponent } from './crud-table/crud-table.component';
import { MatCardModule } from '@angular/material/card';
import { MatIconModule } from '@angular/material/icon';
import { MatButtonModule } from '@angular/material/button';
import { MatTooltipModule } from '@angular/material/tooltip';
import { MatProgressSpinnerModule } from '@angular/material/progress-spinner';
import { TranslatePipe } from '../../pipe/translate.pipe';
import { FormGridModalComponent } from '../form-grid-dialog/form-grid.dialog.component';
import { BackButtonComponent } from '../back-button/backbutton.component'; 

@Component({
   selector: 'fwk-crud',
  templateUrl: './crud.component.html',
  styleUrls: ['./crud.component.scss'],
  encapsulation: ViewEncapsulation.None,
  animations: fuseAnimations,
  standalone: true,
  imports: [
    CommonModule,
    MatButtonModule,
    MatCardModule,
    MatIconModule,
    MatTooltipModule,
    MatProgressSpinnerModule,
    SearchComponent,
    CrudTableComponent,
    TranslatePipe,
    BackButtonComponent
  ],
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class CrudComponent extends AbstractCrudComponent<any, any> implements OnInit, OnDestroy {
  @ViewChild(SearchComponent) searchComponent!: SearchComponent;

  @Input() title: string = '';
  @Input() handlerFieldSourceData?: (key: string, entity: any, injector: Injector) => Observable<any[]>;
  @Input() onClickRow?: (row: any) => void;

  @Input()
  set componentName(name: string) {
    if (name) {
      this.name = name;
      if (this._isInitialized) {
        super.ngOnInit();
      }
    }
  }

  @Input('service')
  set injectService(service: any) {
    this.service = service;
  }

  @Input()
  set crudDefinition(def: CrudDef) {
    if (def) {
      this.i18nName = def.i18n?.name || 'fwk';
      this.setUpCRUDDef(def);
    }
  }

  @Output() onChangeSearchEntity = new EventEmitter<any>();

  display = {
    deleteButton: false,
    selects: false
  };
  selects: any[] = [];
  hasActiveFilters: boolean = false;
  actionLoadingStates = new Map<string, boolean>();

  private authService: AuthService;
  private _isInitialized = false;
  private _injector: Injector;

  constructor(
    injector: Injector,
  ) {
    super(injector);
    this._injector = injector;
    this.authService = injector.get(AuthService);
  }


  override ngOnDestroy(): void {
    super.ngOnDestroy();
  }

  override postSetUpCrud(crudDef: CrudDef): void {
    if (!crudDef.forms?.filter) {
      // this.findAll();
    }
    this.display.deleteButton = !!crudDef.grid?.deleteAction || !!crudDef.grid?.deleteColumn;
    this._cdr.markForCheck();
  }

  statusChanged(status: StatusTable<any>): void {
    this.displayGlobalButtons(status.existSelectedItems());
    this.selects = status.selects;
    this._cdr.markForCheck();
  }

  onDisplayedColumnsChange(newDataColumns: string[]): void {
    if (this.crudDef && this.crudDef.grid) {
      const currentColumns = this.crudDef.grid.displayedColumns;
      const specialColumns = currentColumns.filter(col => col.startsWith('_'));

      const finalDisplayedColumns = [...specialColumns, ...newDataColumns];

      this.crudDef.grid = {
        ...this.crudDef.grid,
        displayedColumns: finalDisplayedColumns
      };

      this._cdr.markForCheck();
    }
  }

  displayGlobalButtons(hasElementsSelected: boolean): void {
    this.display.selects = hasElementsSelected;
  }

  openAddDialog(): void {
    this.getFormCreate(this.crudDef).pipe(
      switchMap((formCreate: FormDef) => {
        const dialogRef = this.dialog.open(CrudModalComponent, {
          width: this.crudDef.dialogConfig?.width ?? '500px',
          panelClass: 'control-mat-dialog',
          data: {
            isAdd: true,
            formDef: this.clone(formCreate),
            translate: (key: string) => this.translate(key),
            funcName: this.crudDef.name ?? '',
            handlerFieldSourceData: this.handlerFieldSourceData,
            crud: this,
            i18n: this.i18nComponent,
          }
        });
        return dialogRef.afterClosed();
      })
    ).subscribe(result => {
      if (result) {
        this.findAll();
      }
    });
  }

  handleRowClick(row: any): void {
    if (this.onClickRow) {
      this.onClickRow(row);
      return;
    }
    this.processRowClick(row);
  }

  private processRowClick(row: any): void {
    if (!this.crudDef) return;

    this.spinnerControl.show();
    const idDef = this.crudDef.grid.columnsDef.find(c => c.id);
    const idKey = idDef ? idDef.columnDef : 'id';

    if (this.crudDef.forceGetDetail) {
      this.genericHttpService.basicGet(this.crudDef.wsGetDetail, { id: row[idKey] }, undefined, { id: 'id' }).pipe(
        finalize(() => this.spinnerControl.hide())
      ).subscribe(r => {
        if (r) this.openEditOrReadDialog(r);
      });
    } else {
      this.openEditOrReadDialog(row);
      this.spinnerControl.hide();
    }
  }

  private openEditOrReadDialog(entity: any): void {
    const formUpdate = this.getFormUpdate(this.crudDef);
    const formRead = this.getFormRead(this.crudDef);
    const nameFunc = this.crudDef.name || '';
    let data: any;

    const canUpdate = this.authService.hasPermission(this.crudDef.security?.updateAccess);

    if (formUpdate && canUpdate) {
      data = {
        isEdit: true, entity: entity, formDef: formUpdate, formName: 'formUpdate',
        funcName: nameFunc, fields: this.localStorageService.clone(formUpdate.fields),
        handlerFieldSourceData: this.handlerFieldSourceData, crud: this
      };
      this.displayCrudModal(data, '-modal update-modal');
    } else if (formRead) {
      data = {
        isRead: true, entity: entity, formDef: formRead, formName: 'formRead',
        funcName: nameFunc, fields: this.localStorageService.clone(formRead.fields)
      };
      this.displayCrudModal(data, '-modal read-modal');
    } else if (this.crudDef.dialogs?.read) {
      this.displayCustomDialog(entity, nameFunc);
    }
  }

  private displayCrudModal(data: any, modalName: string): void {
    if (data) {
      data.funcName = (data.funcName || '') + modalName;
      const dialogRef = this.dialog.open(CrudModalComponent, {
        width: this.crudDef.dialogConfig?.width || '320px',
        panelClass: 'control-mat-dialog',
        data: data
      });

      dialogRef.afterClosed().subscribe((result) => {
        if (result) {
          this.findAll();
        }
      });
    }
  }

  private displayCustomDialog(entity: any, nameFunc: string): void {
    const data = {
      isEdit: false, dialog: this.crudDef.dialogs.read, entity: entity, formName: 'customFormRead',
      funcName: nameFunc,
      onSubmitActions: (actionDef: any, submittedEntity: any) => {
        const dialogRef = this.dialog.getDialogById('customDialog');
        this.actionDefService.submitAction(actionDef, submittedEntity, this.i18nComponent, this.crudDef.dialogConfig)
          .subscribe({
            next: () => this.notificationService.notifySuccess(this.translate('success_message')),
            complete: () => dialogRef?.close()
          });
      },
    };

    const dialogRef = this.dialog.open(FormGridModalComponent, {
      id: 'customDialog', width: 'auto', panelClass: 'control-mat-dialog', data: data
    });

    dialogRef.afterClosed().subscribe(() => { this.findAll(); });
  }

  private getFormRead(crudDef: CrudDef): FormDef | undefined {
    if (crudDef.forms?.read) {
      return { fields: crudDef.forms.read };
    }
    return crudDef.formsDef?.read;
  }

  private getFormUpdate(crudDef: CrudDef): FormDef | undefined {
    if (crudDef.formsDef?.update) {
      return crudDef.formsDef.update;
    }
    if (crudDef.forms?.update) {
      return { fields: crudDef.forms.update };
    }
    return undefined;
  }

  showCrudActions(): boolean {
    return this.display.selects;
  }

  executeCrudAction(action: ActionDef): void {
    if (!this.i18nComponent) return;

    const actionKey = action.actionNameKey || action.actionName || 'default';
    if (this.actionLoadingStates.get(actionKey)) return;

    this.actionLoadingStates.set(actionKey, true);
    this._cdr.markForCheck();

    const wsCall$ = action.ws ? this.genericHttpService.callWs(action.ws, this.selects) : of(undefined);

    wsCall$.pipe(
      finalize(() => {
        this.actionLoadingStates.set(actionKey, false);
        this._cdr.markForCheck();
      })
    ).subscribe(entity => {
      if (action.formDef) {
        this.callCrudDialog(action, entity);
      } else {
        this.actionDefService.submitAction(action, this.selects, this.i18nComponent, undefined).subscribe(() => {
          this.findAll();
          this.notificationService.notifySuccess(this.translate('success_message'));
        });
      }
    });
  }

  private callCrudDialog(action: ActionDef, entity: any): void {
    if (!this.i18nComponent) return;

    const dialogRef = this.dialog.open(CrudModalComponent, {
      width: this.crudDef.dialogConfig?.width ?? '500px',
      panelClass: 'control-mat-dialog',
      data: {
        entity: entity,
        translate: (key: string) => this.translate(key),
        submitActions: (actionDef: ActionDef) => {
          if (!this.i18nComponent) return;
          this.actionDefService.submitAction(actionDef, this.selects, this.i18nComponent, this.crudDef.dialogConfig)
            .pipe(finalize(() => dialogRef.close()))
            .subscribe(() => {
              this.findAll();
              this.notificationService.notifySuccess(this.translate('success_message'));
            });
        },
        formDef: this.localStorageService.clone(action.formDef),
        funcName: this.crudDef.name ?? ''
      }
    });
  }

  getCrudActions(): ActionDef[] {
    return this.actionDefService.filterActionsByCondition(this.crudDef.crudActions ?? [], this.crudDef.displayGlobalActions ?? [], this.selects);
  }

  getFormCreate(crudDef: CrudDef): Observable<FormDef> {
    const formDef: FormDef = (crudDef.formsDef?.create) ?? {
      fields: crudDef.forms?.create,
      fieldsBehavior: crudDef.forms?.createBehavior,
    };

    if (formDef.initWs?.url) {
      return this.genericHttpService.basicGet(formDef.initWs.url, null, null, {}).pipe(
        map((response: any[]) => {
          const initData = Array.isArray(response) ? response[0] : response;
          if (initData && formDef.fields) {
            Object.keys(initData).forEach(attribute => {
              const field = formDef.fields?.find(f => f.key === attribute);
              if (field) {
                field.value = initData[attribute];
              }
            });
          }
          return formDef;
        })
      );
    }
    return of(formDef);
  }

  clone(obj: any): any {
    return this.localStorageService.clone(obj);
  }

  delete(): Observable<any> {
    return this.deleteAll(this.selects).pipe(
      tap(() => {
        this.findAll();
        this.notificationService.notifySuccess(this.translate('success_message'));
      })
    );
  }

  openDeleteDialog(): void {
    const count = this.selects.length;
    let message: string;

    if (count === 1) {
      message = this.translate('modal_delete_message_single');
    } else {
      const pluralMessage = this.translate('modal_delete_message_plural');
      message = pluralMessage.replace('{0}', count.toString());
    }

    this.dialogService.showQuestionModal({
      title: this.translate('modal_delete_title'),
      message: message,
      actions: {
        confirm: {
          label: this.translate('modal_delete_button_accept'),
          color: 'warn'
        }
      },
      onSubmit: () => this.delete(),
    });
  }

  exportCsv(): void {
    const exportConfig = this.crudDef.exportCsv;
    if (!exportConfig) return;

    if (exportConfig.ws) {
      const params = this.service.getParametersToUrl(this.appliedFilterEntity);
      this.service.downloadCsv(exportConfig.ws, params)
        .subscribe((res: any) => this.fileService.downloadFileOctectStream(res));
    } else if (exportConfig.csvExportFileName) {
      const data = this.entities.map(e => {
        const reg: { [key: string]: any } = {};
        this.crudDef.grid?.columnsDef.forEach((column: any) => {
          if (e[column.columnDef] !== undefined) {
            reg[column.columnName] = e[column.columnDef];
          }
        });
        return reg;
      });
      this.fileService.downloadCsv(data, exportConfig.csvExportFileName);
    }
  }

  override getI18nName(): string {
    return this.crudDef?.i18n?.name ?? 'crud';
  }

  getCRUDName(): string {
    return this.name;
  }

  newObjectEntity(): any {
    return {};
  }

  showDeleteButton(): boolean {
    if (!this.crudDef.security?.deleteAccess) {
      return this.display.deleteButton;
    }
    return this.display.deleteButton && this.authService.hasPermission(this.crudDef.security.deleteAccess);
  }

  showAddButton(): boolean {
    const hasForm = !!this.crudDef?.forms?.create || !!this.crudDef?.formsDef?.create;
    if (!this.crudDef.security?.createAccess) return hasForm;
    return hasForm && this.authService.hasPermission(this.crudDef.security.createAccess);
  }

  handlePageChange(): void {
    if (this.crudDef?.serverPagination === true) {
      this.findAll();
    }
  }

  override translate(key: string): string {
    const word = super.translate(key);
    if (word === key && key === 'page_title' && this.title) {
      return this.title;
    }
    return word;
  }

  downloadBoleta(): void {
    const contactId = this.appliedFilterEntity?.['idContact'];
    if (contactId && this.service) {
      (this.service as any).downloadBoleta(contactId);
    } else {
      console.error("No se pudo descargar la boleta: idContact no encontrado en el filtro aplicado.");
    }
  }

  goToLink(url: string | undefined): void {
    if (url) {
      window.open(url, "_blank");
    }
  }

  override filterSearchEntity(filterEntity: any): void {
    this.hasActiveFilters = Object.values(filterEntity).some(v => v !== null && v !== undefined && v !== '');
    super.filterSearchEntity(filterEntity);
  }

  clearFilters(): void {
    if (this.searchComponent) {
      this.searchComponent.clearForm();
    }
  }
}

--- FILE: @fwk/components/crud/crud.routes.ts ---

import { Routes } from '@angular/router';
import { LegacyCrudWrapperComponent } from 'app/modules/legacy-crud-wrapper/legacy-crud-wrapper.component';

export default [
    {
        path     : '',
        component: LegacyCrudWrapperComponent,
    },
] as Routes;

--- FILE: @fwk/components/crud/html-modal/html-modal.component.html ---

﻿<div class="flex flex-col max-h-screen" [ngClass]="data.modalName ? data.modalName + '-html-modal' : ''">

    <div class="flex flex-0 items-center justify-between pl-6 pr-4 h-16 border-b">
        <h2 class="text-2xl font-semibold">{{ data.title || ('html_modal_default_title' | translate) }}</h2>
        <button
            mat-icon-button
            (click)="close()"
            [matTooltip]="'modal_button_close' | translate">
            <mat-icon [svgIcon]="'heroicons_outline:x-mark'"></mat-icon>
        </button>
    </div>

    <div mat-dialog-content class="flex-auto overflow-y-auto p-6 prose dark:prose-invert">
        <div [innerHTML]="data.html | sanitizeHtml"></div>
    </div>

    <div mat-dialog-actions class="flex items-center justify-end p-6 border-t">
        <button
            mat-flat-button
            color="accent"
            (click)="close()">
            {{ 'modal_button_close' | translate }}
        </button>
    </div>

</div>

--- FILE: @fwk/components/crud/html-modal/html-modal.component.ts ---

﻿import { Component, Inject } from '@angular/core';
import { CommonModule } from '@angular/common';
import { MatDialogRef, MAT_DIALOG_DATA, MatDialogModule } from '@angular/material/dialog';
import { MatButtonModule } from '@angular/material/button';
import { MatIconModule } from '@angular/material/icon';
import { MatTooltipModule } from '@angular/material/tooltip';
import { SanitizeHtmlPipe } from '../../../pipe/sanitize-html.pipe';
import { TranslatePipe } from '../../../pipe/translate.pipe';

export interface HtmlModalData {
    html: string;
    title?: string;
    modalName?: string;
}

@Component({
     selector: 'fwk-html-modal-component',
    templateUrl: './html-modal.component.html',
    styleUrls: ['./html-modal.component.scss'],
    standalone: true,
    imports: [
        CommonModule,
        MatDialogModule,
        MatButtonModule,
        MatIconModule,
        MatTooltipModule,
        SanitizeHtmlPipe,
        TranslatePipe
    ]
})
export class HtmlModalComponent {

    constructor(
        public dialogRef: MatDialogRef<HtmlModalComponent>,
        @Inject(MAT_DIALOG_DATA) public data: HtmlModalData
    ) {
        this.dialogRef.disableClose = false;
    }

    close(): void {
        this.dialogRef.close();
    }
}

--- FILE: @fwk/components/custom-notification/custom-notification.component.html ---

<div class="custom-notification-wrapper flex items-center p-4 w-full" [ngClass]="'notification-' + data.type">
    
    <div class="flex-shrink-0">
        <mat-icon class="icon-size-6 mt-2" [svgIcon]="icon"></mat-icon>
    </div>

    <div class="flex-1 ml-3 font-medium">
        {{ data.message }}
    </div>

    <button mat-icon-button (click)="dismiss()" class="ml-4 -mr-2">
        <mat-icon svgIcon="heroicons_solid:x-mark" class="icon-size-5"></mat-icon>
    </button>

</div>

--- FILE: @fwk/components/custom-notification/custom-notification.component.ts ---

import { Component, inject, ChangeDetectionStrategy } from '@angular/core';
import { CommonModule, NgClass } from '@angular/common';
import { MAT_SNACK_BAR_DATA, MatSnackBarRef } from '@angular/material/snack-bar';
import { MatButtonModule } from '@angular/material/button';
import { MatIconModule } from '@angular/material/icon';

export interface NotificationData {
    message: string;
    type: 'success' | 'error' | 'info';
}

@Component({
     selector: 'fwk-custom-notification',
    templateUrl: './custom-notification.component.html',
    styleUrls: ['./custom-notification.component.scss'],
    standalone: true,
    imports: [
        CommonModule,
        NgClass,
        MatButtonModule,
        MatIconModule
    ],
    changeDetection: ChangeDetectionStrategy.OnPush,
})
export class CustomNotificationComponent {
    public data: NotificationData = inject(MAT_SNACK_BAR_DATA);
    public snackBarRef = inject(MatSnackBarRef<CustomNotificationComponent>);

    get icon(): string {
        switch (this.data.type) {
            case 'success':
                return 'heroicons_solid:check-circle';
            case 'error':
                return 'heroicons_solid:x-circle';
            case 'info':
            default:
                return 'heroicons_solid:information-circle';
        }
    }

    dismiss(): void {
        this.snackBarRef.dismiss();
    }
}

--- FILE: @fwk/components/dashboard/base-widget.directive.ts ---

import { Directive, Input, Output, EventEmitter, inject } from '@angular/core';
import { of } from 'rxjs';
import { catchError, finalize, map } from 'rxjs/operators';
import { DashboardWidgetDef, StatData } from '@fwk/model/component-def/dashboard-def';
import { GenericHttpService } from '@fwk/services/generic-http-service/generic-http.service';
import { I18nService } from '@fwk/services/i18n-service/i18n.service';

@Directive({
    selector: '[fwkBaseWidget]',
    standalone: true,
})
export class BaseWidgetDirective {
    @Input() widgetDef: DashboardWidgetDef;
    @Input() i18nName: string;
    @Output() dataLoaded = new EventEmitter<void>();

    protected genericHttpService = inject(GenericHttpService);
    private i18nService = inject(I18nService);

    public initialize(): void {
        this.resolveWidgetTitle();
        this.loadData(this.widgetDef.filterConfig?.defaultOption || 'all');
    }

    private resolveWidgetTitle(): void {
        if (this.widgetDef.titleKey && this.i18nName) {
            const dictionary = this.i18nService.getDictionary(this.i18nName);
            this.widgetDef.title = dictionary?.translate?.(this.widgetDef.titleKey) || this.widgetDef.titleKey;
        }
    }

    public loadData(filterValue: string): void {
        if (!this.widgetDef || this.widgetDef.type === 'widget-group' || !this.widgetDef.ws) {
            this.dataLoaded.emit();
            return;
        }

        this.widgetDef.isLoading = true;
        this.widgetDef.hasError = false;

        const params = this.getFilterParamsForApi(filterValue);

        this.genericHttpService.httpGet(this.widgetDef.ws.url, params)
            .pipe(
                map(data => {
                    if (this.widgetDef.type === 'stat') {
                        if (Array.isArray(data) && data[0]) {
                            this.widgetDef.dataSource = [this._mapDataToStatFormat(data[0])];
                        } else if (data) {
                            this.widgetDef.dataSource = [this._mapDataToStatFormat(data)];
                        }
                    } else {
                        this.widgetDef.apexChartData = this._mapDataToApexChartsFormat(data as any[]);
                    }
                }),
                catchError(error => {
                    console.error(`[Dashboard Widget] Error cargando datos para "${this.widgetDef.title}":`, error);
                    this.widgetDef.hasError = true;
                    this.widgetDef.errorMessage = this.i18nService.getDictionary('fwk')?.translate?.('widget_error_default_message') ?? 'widget_error_default_message';
                    return of(null);
                }),
                finalize(() => {
                    this.widgetDef.isLoading = false;
                    this.dataLoaded.emit();
                })
            )
            .subscribe();
    }

    private _mapDataToStatFormat(apiData: any): StatData {
        return {
            mainStat: Number(apiData.value) || 0,
            mainStatLabel: apiData.name || '',
            title: apiData.title || '',
            secondaryStat: Number(apiData.secondaryValue) || undefined,
            secondaryStatLabel: apiData.secondaryLabel || undefined,
            color: apiData.color || 'blue'
        };
    }

    private _mapDataToApexChartsFormat(apiData: Array<{ name: string; value: string | number }>) {
        if (!apiData || apiData.length === 0) {
            return { series: [], labels: [] };
        }

        const labels = apiData.map(item => item.name);
        const data = apiData.map(item => Number(item.value));

        const chartType = this.widgetDef.type;

        if (chartType === 'pie' || chartType === 'donut' || chartType === 'polarArea') {
            return {
                series: data,
                labels: labels,
            };
        }

        return {
            series: [{
                name: this.widgetDef.title || 'Datos',
                data: data,
            }],
            xaxis: {
                categories: labels,
            },
        };
    }

    protected getFilterParamsForApi(filterValue: string): any {
        const params: { [key: string]: string } = {};
        if (filterValue && filterValue.toLowerCase() !== 'all') {
            params['filter'] = filterValue;
        }
        return params;
    }

    onFilterChanged(filterValue: string): void {
        this.loadData(filterValue);
    }
}

--- FILE: @fwk/components/dashboard/dashboard-page/dashboard-page.component.ts ---

import { Component, Input, OnInit, inject } from '@angular/core';
import { CommonModule } from '@angular/common';
import { DashboardLayoutDef, DashboardWidgetDef } from '@fwk/model/component-def/dashboard-def';
import { WidgetWrapperComponent } from '../widget-wrapper/widget-wrapper.component';
import { I18nService } from '@fwk/services/i18n-service/i18n.service';

@Component({
    selector: 'fwk-dashboard-page',
    standalone: true,
    imports: [CommonModule, WidgetWrapperComponent],
    template: `
    <div class="flex flex-col flex-auto w-full" *ngIf="layoutDef">
        <div class="flex flex-col sm:flex-row flex-0 sm:items-center sm:justify-between p-4 sm:px-6 pt-0 w-full bg-card dark:bg-transparent">
            <div class="flex-1 min-w-0">
                <div class="text-3xl font-extrabold tracking-tight leading-7 sm:leading-10 truncate">
                    {{ pageTitle }}
                </div>
            </div>
        </div>

        <div class="flex-auto p-6">
            <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-6 w-full">
                <ng-container *ngFor="let widget of layoutDef.widgets">
                    <div [ngClass]="getSizeClasses(widget.size)">
                        <fwk-widget-wrapper [widgetDef]="widget" [i18nName]="i18nName"></fwk-widget-wrapper>
                    </div>
                </ng-container>
            </div>
        </div>
    </div>
    `
})
export class DashboardPageComponent implements OnInit {
    @Input() layoutDef: DashboardLayoutDef;
    @Input() i18nName: string;

    pageTitle: string = 'Dashboard';
    private i18nService = inject(I18nService);

    ngOnInit(): void {
        const i18n = this.i18nService.getDictionary(this.i18nName);
        this.pageTitle = i18n?.translate?.('page_title') || this.layoutDef.sectionTitle || 'Dashboard';
    }

    getSizeClasses(size: string): any {
        switch (size) {
            case 'full': return 'col-span-1 sm:col-span-2 lg:col-span-4';
            case 'half': return 'col-span-1 sm:col-span-2 lg:col-span-2';
            case 'third': return 'col-span-1 sm:col-span-2 lg:col-span-2';
            case 'quarter': return 'col-span-1';
            default: return 'col-span-1';
        }
    }
}

--- FILE: @fwk/components/dashboard/widget-wrapper/widget-wrapper.component.ts ---

import { Component, Input, ViewEncapsulation } from '@angular/core';
import { CommonModule } from '@angular/common';
import { DashboardWidgetDef } from '@fwk/model/component-def/dashboard-def';
import { BarChartWidgetComponent } from '../widgets/bar-chart-widget/bar-chart-widget.component';
import { PieChartWidgetComponent } from '../widgets/pie-chart-widget/pie-chart-widget.component';
import { StatCardWidgetComponent } from '../widgets/stat-card-widget/stat-card-widget.component';
import { LineChartWidgetComponent } from '../widgets/line-chart-widget/line-chart-widget.component';
import { DoughnutChartWidgetComponent } from '../widgets/doughnut-chart-widget/doughnut-chart-widget.component';
import { PolarAreaChartWidgetComponent } from '../widgets/polar-area-chart-widget/polar-area-chart-widget.component';

@Component({
    selector: 'fwk-widget-wrapper',
    standalone: true,
    imports: [
        CommonModule,
        BarChartWidgetComponent,
        PieChartWidgetComponent,
        StatCardWidgetComponent,
        LineChartWidgetComponent,
        DoughnutChartWidgetComponent,
        PolarAreaChartWidgetComponent,
    ],
    template: `
        <ng-container [ngSwitch]="widgetDef.type">
            <fwk-bar-chart-widget *ngSwitchCase="'bar'" [widgetDef]="widgetDef" [i18nName]="i18nName"></fwk-bar-chart-widget>
            <fwk-pie-chart-widget *ngSwitchCase="'pie'" [widgetDef]="widgetDef" [i18nName]="i18nName"></fwk-pie-chart-widget>
            <fwk-stat-card-widget *ngSwitchCase="'stat'" [widgetDef]="widgetDef" [i18nName]="i18nName"></fwk-stat-card-widget>
            <fwk-line-chart-widget *ngSwitchCase="'line'" [widgetDef]="widgetDef" [i18nName]="i18nName"></fwk-line-chart-widget>
            <fwk-doughnut-chart-widget *ngSwitchCase="'donut'" [widgetDef]="widgetDef" [i18nName]="i18nName"></fwk-doughnut-chart-widget>
            <fwk-polar-area-chart-widget *ngSwitchCase="'polarArea'" [widgetDef]="widgetDef" [i18nName]="i18nName"></fwk-polar-area-chart-widget>
            
            <div *ngSwitchCase="'widget-group'" class="flex flex-col gap-6 h-full">
                <ng-container *ngFor="let childWidget of widgetDef.children">
                    <div [ngClass]="getFlexClass(childWidget.size)" class="flex">
                         <fwk-widget-wrapper [widgetDef]="childWidget" [i18nName]="i18nName"></fwk-widget-wrapper>
                    </div>
                </ng-container>
            </div>
        </ng-container>
    `,
    encapsulation: ViewEncapsulation.None
})
export class WidgetWrapperComponent {
    @Input() widgetDef: DashboardWidgetDef;
    @Input() i18nName: string;

    getFlexClass(size: string): string {
        switch (size) {
            case 'full': return 'flex-auto';
            default: return 'flex-initial';
        }
    }
}

--- FILE: @fwk/components/dashboard/widgets/bar-chart-widget/bar-chart-widget.component.ts ---

import { Component, Input, OnInit, ViewEncapsulation, inject, ChangeDetectorRef, ViewChild } from '@angular/core';
import { CommonModule } from '@angular/common';
import { BaseWidgetDirective } from '../../base-widget.directive';
import { WidgetFilterComponent } from '../widget-filter/widget-filter.component';
import { DashboardWidgetDef, ApexChartOptions } from '@fwk/model/component-def/dashboard-def';
import { WidgetSkeletonComponent } from '../widget-skeleton/widget-skeleton.component';
import { WidgetErrorStateComponent } from '../widget-error-state/widget-error-state.component';
import { WidgetEmptyStateComponent } from '../widget-empty-state/widget-empty-state.component';
import { NgApexchartsModule, ChartComponent } from 'ng-apexcharts';

@Component({
    selector: 'fwk-bar-chart-widget',
    standalone: true,
    imports: [
        CommonModule, NgApexchartsModule, WidgetFilterComponent,
        WidgetSkeletonComponent, WidgetErrorStateComponent, WidgetEmptyStateComponent,
    ],
    template: `
        <div class="bg-card flex flex-col overflow-hidden rounded-2xl p-6 shadow">
            <div class="flex items-start justify-between">
                <div class="truncate text-lg font-medium leading-6 tracking-tight">{{ widgetDef?.title }}</div>
                 <fwk-widget-filter *ngIf="widgetDef?.filterConfig?.show"
                    [options]="widgetDef.filterConfig.options"
                    [initialValue]="widgetDef.filterConfig.defaultOption"
                    (filterChange)="onFilterChanged($event)">
                </fwk-widget-filter>
            </div>
            
            <div class="relative flex-auto mt-4">
                <ng-container *ngIf="widgetDef?.isLoading">
                    <div class="relative inset-0 flex items-center justify-center">
                        <fwk-widget-skeleton [type]="widgetDef.type" class="w-full"></fwk-widget-skeleton>
                    </div>
                </ng-container>

                <ng-container *ngIf="!widgetDef.isLoading && widgetDef.hasError">
                    <div class="absolute inset-0 flex items-center justify-center">
                        <fwk-widget-error-state 
                            [title]="'widget_error_title' | translate"
                            [message]="widgetDef.errorMessage"
                            (retry)="onRetry()">
                        </fwk-widget-error-state>
                    </div>
                </ng-container>
                
                <ng-container *ngIf="!widgetDef?.isLoading">
                    <apx-chart #chart
                        *ngIf="chartOptions"
                        class="absolute inset-0"
                        [class.opacity-0]="widgetDef.isLoading || widgetDef.hasError || !hasData()"
                        [series]="chartOptions.series"
                        [chart]="chartOptions.chart"
                        [dataLabels]="chartOptions.dataLabels"
                        [plotOptions]="chartOptions.plotOptions"
                        [xaxis]="chartOptions.xaxis"
                        [yaxis]="chartOptions.yaxis"
                        [fill]="chartOptions.fill"
                        [legend]="chartOptions.legend"
                        [stroke]="chartOptions.stroke"
                        [theme]="chartOptions.theme">
                    </apx-chart>
                </ng-container>

                <ng-container *ngIf="!widgetDef.isLoading && !widgetDef.hasError && !hasData()">
                    <div class="absolute inset-0 flex items-center justify-center">
                        <fwk-widget-empty-state
                            [title]="'widget_empty_title' | translate"
                            [message]="'widget_empty_message' | translate">
                        </fwk-widget-empty-state>
                    </div>
                </ng-container>
            </div>
        </div>
    `,
    hostDirectives: [{
        directive: BaseWidgetDirective,
        inputs: ['widgetDef', 'i18nName'],
        outputs: ['dataLoaded'],
    }],
    encapsulation: ViewEncapsulation.None
})
export class BarChartWidgetComponent implements OnInit {
    @ViewChild('chart') chart: ChartComponent;
    @Input() widgetDef: DashboardWidgetDef;
    @Input() i18nName: string;

    public chartOptions: Partial<ApexChartOptions>;

    private baseDirective = inject(BaseWidgetDirective);
    private cdr = inject(ChangeDetectorRef);

    constructor() {
        this.baseDirective.dataLoaded.subscribe(() => {
            this.updateChartData();
        });
    }

    ngOnInit(): void {
        this.baseDirective.initialize();
        this.prepareChartOptions();
    }

    updateChartData(): void {
        if (this.widgetDef?.apexChartData) {
            this.chartOptions = {
                ...this.chartOptions,
                series: this.widgetDef.apexChartData.series,
                xaxis: this.widgetDef.apexChartData.xaxis,
            };
            this.cdr.markForCheck();
        }
    }

    hasData(): boolean {
        const series = this.widgetDef?.apexChartData?.series;
        if (!series || series.length === 0) {
            return false;
        }
        const firstSeries = series[0] as { data: any[] };
        if (firstSeries && firstSeries.data && Array.isArray(firstSeries.data)) {
            return firstSeries.data.some(val => val > 0);
        }
        return false;
    }

    prepareChartOptions(): void {
        this.chartOptions = {
            chart: {
                type: 'bar',
                height: 350,
                width: '100%',
                stacked: true,
                toolbar: { show: false },
                zoom: { enabled: false },
            },
            series: [],
            xaxis: {
                labels: {
                    style: { colors: 'var(--fuse-text-secondary)' },
                },
                categories: []
            },
            yaxis: {
                labels: {
                    style: { colors: 'var(--fuse-text-secondary)' },
                },
            },
            plotOptions: {
                bar: {
                    horizontal: false,
                    barHeight: '80%',
                    columnWidth: '50%',
                },
            },
            dataLabels: { enabled: false },
            legend: { show: false },
            stroke: { show: true, width: 2, colors: ['transparent'] },
            theme: {
                mode: document.body.classList.contains('dark') ? 'dark' : 'light'
            }
        };
    }

    onFilterChanged(value: string) {
        this.baseDirective.onFilterChanged(value);
    }

    onRetry(): void {
        this.onFilterChanged(this.widgetDef.filterConfig?.defaultOption || 'all');
    }
}

--- FILE: @fwk/components/dashboard/widgets/doughnut-chart-widget/doughnut-chart-widget.component.ts ---

import { Component, Input, OnInit, ViewEncapsulation, inject, ChangeDetectorRef, ViewChild } from '@angular/core';
import { CommonModule } from '@angular/common';
import { BaseWidgetDirective } from '../../base-widget.directive';
import { WidgetFilterComponent } from '../widget-filter/widget-filter.component';
import { DashboardWidgetDef, ApexChartOptions } from '@fwk/model/component-def/dashboard-def';
import { WidgetSkeletonComponent } from '../widget-skeleton/widget-skeleton.component';
import { WidgetErrorStateComponent } from '../widget-error-state/widget-error-state.component';
import { WidgetEmptyStateComponent } from '../widget-empty-state/widget-empty-state.component';
import { NgApexchartsModule, ChartComponent } from 'ng-apexcharts';

@Component({
    selector: 'fwk-doughnut-chart-widget',
    standalone: true,
    imports: [CommonModule, NgApexchartsModule, WidgetFilterComponent, WidgetSkeletonComponent, WidgetErrorStateComponent, WidgetEmptyStateComponent],
    template: `
        <div class="bg-card flex flex-col overflow-hidden rounded-2xl p-6 shadow">
            <div class="flex items-start justify-between">
                <div class="truncate text-lg font-medium leading-6 tracking-tight">{{ widgetDef?.title }}</div>
                <fwk-widget-filter *ngIf="widgetDef?.filterConfig?.show" [options]="widgetDef.filterConfig.options" [initialValue]="widgetDef.filterConfig.defaultOption" (filterChange)="onFilterChanged($event)"></fwk-widget-filter>
            </div>
            <div class="relative flex-auto mt-4">
                <ng-container *ngIf="widgetDef?.isLoading">
                     <div class="relative inset-0 flex items-center justify-center">
                        <fwk-widget-skeleton [type]="widgetDef.type" class="w-full"></fwk-widget-skeleton>
                    </div>
                </ng-container>
                <ng-container *ngIf="!widgetDef.isLoading && widgetDef.hasError">
                    <div class="absolute inset-0 flex items-center justify-center">
                        <fwk-widget-error-state 
                            [title]="'widget_error_title' | translate"
                            [message]="widgetDef.errorMessage"
                            (retry)="onRetry()">
                        </fwk-widget-error-state>
                    </div>
                </ng-container>
                
                <ng-container *ngIf="!widgetDef?.isLoading">
                    <apx-chart #chart
                        *ngIf="chartOptions"
                        class="absolute inset-0"
                        [class.opacity-0]="widgetDef.isLoading || widgetDef.hasError || !hasData()"
                        [series]="chartOptions.series"
                        [chart]="chartOptions.chart"
                        [labels]="chartOptions.labels"
                        [legend]="chartOptions.legend"
                        [responsive]="chartOptions.responsive"
                        [theme]="chartOptions.theme">
                    </apx-chart>
                </ng-container>

                <ng-container *ngIf="!widgetDef.isLoading && !widgetDef.hasError && !hasData()">
                    <div class="absolute inset-0 flex items-center justify-center">
                        <fwk-widget-empty-state
                            [title]="'widget_empty_title' | translate"
                            [message]="'widget_empty_message' | translate">
                        </fwk-widget-empty-state>
                    </div>
                </ng-container>
            </div>
        </div>
    `,
    hostDirectives: [{
        directive: BaseWidgetDirective,
        inputs: ['widgetDef', 'i18nName'],
        outputs: ['dataLoaded'],
    }],
    encapsulation: ViewEncapsulation.None
})
export class DoughnutChartWidgetComponent implements OnInit {
    @ViewChild('chart') chart: ChartComponent;
    @Input() widgetDef: DashboardWidgetDef;
    @Input() i18nName: string;

    public chartOptions: Partial<ApexChartOptions>;

    private baseDirective = inject(BaseWidgetDirective);
    private cdr = inject(ChangeDetectorRef);

    constructor() {
        this.baseDirective.dataLoaded.subscribe(() => this.updateChartData());
    }

    ngOnInit(): void {
        this.baseDirective.initialize();
        this.prepareChartOptions();
    }

    updateChartData(): void {
        if (this.widgetDef?.apexChartData) {
            this.chartOptions = {
                ...this.chartOptions,
                series: this.widgetDef.apexChartData.series,
                labels: this.widgetDef.apexChartData.labels,
            };
            this.cdr.markForCheck();
        }
    }

    hasData(): boolean {
        const series = this.widgetDef?.apexChartData?.series as number[];
        return !!(series && series.length > 0 && series.some(v => v > 0));
    }

    prepareChartOptions(): void {
        this.chartOptions = {
            chart: {
                type: 'donut',
                height: 350,
                toolbar: { show: false },
                zoom: { enabled: false },
            },
            series: [],
            labels: [],
            legend: {
                position: 'bottom',
                itemMargin: { horizontal: 10, vertical: 5 },
            },
            responsive: [{
                breakpoint: 480,
                options: {
                    chart: { width: 200 },
                    legend: { position: 'bottom' }
                }
            }],
            theme: {
                mode: document.body.classList.contains('dark') ? 'dark' : 'light'
            },
        };
    }

    onFilterChanged(value: string) {
        this.baseDirective.onFilterChanged(value);
    }

    onRetry(): void {
        this.onFilterChanged(this.widgetDef.filterConfig?.defaultOption || 'all');
    }
}

--- FILE: @fwk/components/dashboard/widgets/line-chart-widget/line-chart-widget.component.ts ---

import { Component, Input, OnInit, ViewEncapsulation, inject, ChangeDetectorRef, ViewChild } from '@angular/core';
import { CommonModule } from '@angular/common';
import { BaseWidgetDirective } from '../../base-widget.directive';
import { WidgetFilterComponent } from '../widget-filter/widget-filter.component';
import { DashboardWidgetDef, ApexChartOptions } from '@fwk/model/component-def/dashboard-def';
import { WidgetSkeletonComponent } from '../widget-skeleton/widget-skeleton.component';
import { WidgetErrorStateComponent } from '../widget-error-state/widget-error-state.component';
import { WidgetEmptyStateComponent } from '../widget-empty-state/widget-empty-state.component';
import { NgApexchartsModule, ChartComponent } from 'ng-apexcharts';

@Component({
    selector: 'fwk-line-chart-widget',
    standalone: true,
    imports: [CommonModule, NgApexchartsModule, WidgetFilterComponent, WidgetSkeletonComponent, WidgetErrorStateComponent, WidgetEmptyStateComponent],
    template: `
        <div class="bg-card flex flex-col overflow-hidden rounded-2xl p-6 shadow">
            <div class="flex items-start justify-between">
                <div class="truncate text-lg font-medium leading-6 tracking-tight">{{ widgetDef?.title }}</div>
                <fwk-widget-filter *ngIf="widgetDef?.filterConfig?.show" [options]="widgetDef.filterConfig.options" [initialValue]="widgetDef.filterConfig.defaultOption" (filterChange)="onFilterChanged($event)"></fwk-widget-filter>
            </div>
            <div class="relative flex-auto mt-4">
                <ng-container *ngIf="widgetDef?.isLoading">
                    <div class="relative inset-0 flex items-center justify-center">
                        <fwk-widget-skeleton [type]="widgetDef.type" class="w-full"></fwk-widget-skeleton>
                    </div>
                </ng-container>

                <ng-container *ngIf="!widgetDef.isLoading && widgetDef.hasError">
                    <div class="absolute inset-0 flex items-center justify-center">
                        <fwk-widget-error-state 
                            [title]="'widget_error_title' | translate"
                            [message]="widgetDef.errorMessage"
                            (retry)="onRetry()">
                        </fwk-widget-error-state>
                    </div>
                </ng-container>
                
                <ng-container *ngIf="!widgetDef?.isLoading">
                    <apx-chart #chart
                        *ngIf="chartOptions"
                        class="absolute inset-0"
                        [class.opacity-0]="widgetDef.isLoading || widgetDef.hasError || !hasData()"
                        [series]="chartOptions.series"
                        [chart]="chartOptions.chart"
                        [dataLabels]="chartOptions.dataLabels"
                        [xaxis]="chartOptions.xaxis"
                        [yaxis]="chartOptions.yaxis"
                        [fill]="chartOptions.fill"
                        [stroke]="chartOptions.stroke"
                        [theme]="chartOptions.theme">
                    </apx-chart>
                </ng-container>

                <ng-container *ngIf="!widgetDef.isLoading && !widgetDef.hasError && !hasData()">
                    <div class="absolute inset-0 flex items-center justify-center">
                        <fwk-widget-empty-state
                            [title]="'widget_empty_title' | translate"
                            [message]="'widget_empty_message' | translate">
                        </fwk-widget-empty-state>
                    </div>
                </ng-container>
            </div>
        </div>
    `,
    hostDirectives: [{
        directive: BaseWidgetDirective,
        inputs: ['widgetDef', 'i18nName'],
        outputs: ['dataLoaded'],
    }],
    encapsulation: ViewEncapsulation.None
})
export class LineChartWidgetComponent implements OnInit {
    @ViewChild('chart') chart: ChartComponent;
    @Input() widgetDef: DashboardWidgetDef;
    @Input() i18nName: string;

    public chartOptions: Partial<ApexChartOptions>;
    
    private baseDirective = inject(BaseWidgetDirective);
    private cdr = inject(ChangeDetectorRef);

    constructor() {
        this.baseDirective.dataLoaded.subscribe(() => this.updateChartData());
    }

    ngOnInit(): void {
        this.baseDirective.initialize();
        this.prepareChartOptions();
    }

    updateChartData(): void {
        if (this.widgetDef?.apexChartData) {
            this.chartOptions = {
                ...this.chartOptions,
                series: this.widgetDef.apexChartData.series,
                xaxis: this.widgetDef.apexChartData.xaxis
            };
            this.cdr.markForCheck();
        }
    }
    
    hasData(): boolean {
        const series = this.widgetDef?.apexChartData?.series;
        if (!series || series.length === 0) return false;
        const firstSeries = series[0] as { data: any[] };
        if (firstSeries && firstSeries.data && Array.isArray(firstSeries.data)) {
            return firstSeries.data.some(val => val > 0);
        }
        return false;
    }

    prepareChartOptions(): void {
        this.chartOptions = {
            chart: {
                type: 'line',
                height: 350,
                toolbar: { show: false },
                zoom: { enabled: false },
            },
            series: [],
            xaxis: {
                labels: { style: { colors: 'var(--fuse-text-secondary)' } },
                categories: []
            },
            yaxis: {
                labels: { style: { colors: 'var(--fuse-text-secondary)' } },
            },
            dataLabels: { enabled: false },
            stroke: { curve: 'smooth', width: 5 },
            fill: {
                type: 'gradient',
                gradient: {
                    shade: 'light',
                    type: 'vertical',
                    shadeIntensity: 0.7,
                    opacityFrom: 0.9,
                    opacityTo: 0,
                }
            },
            theme: {
                mode: document.body.classList.contains('dark') ? 'dark' : 'light'
            }
        };
    }

    onFilterChanged(value: string) {
        this.baseDirective.onFilterChanged(value);
    }
    
    onRetry(): void {
        this.onFilterChanged(this.widgetDef.filterConfig?.defaultOption || 'all');
    }
}

--- FILE: @fwk/components/dashboard/widgets/pie-chart-widget/pie-chart-widget.component.ts ---

import { Component, Input, OnInit, ViewEncapsulation, inject, ChangeDetectorRef, ViewChild } from '@angular/core';
import { CommonModule } from '@angular/common';
import { BaseWidgetDirective } from '../../base-widget.directive';
import { WidgetFilterComponent } from '../widget-filter/widget-filter.component';
import { DashboardWidgetDef, ApexChartOptions } from '@fwk/model/component-def/dashboard-def';
import { WidgetSkeletonComponent } from '../widget-skeleton/widget-skeleton.component';
import { WidgetErrorStateComponent } from '../widget-error-state/widget-error-state.component';
import { WidgetEmptyStateComponent } from '../widget-empty-state/widget-empty-state.component';
import { NgApexchartsModule, ChartComponent } from 'ng-apexcharts';

@Component({
    selector: 'fwk-pie-chart-widget',
    standalone: true,
    imports: [CommonModule, NgApexchartsModule, WidgetFilterComponent, WidgetSkeletonComponent, WidgetErrorStateComponent, WidgetEmptyStateComponent],
    template: `
        <div class="bg-card flex flex-col overflow-hidden rounded-2xl p-6 shadow">
            <div class="flex items-start justify-between">
                <div class="truncate text-lg font-medium leading-6 tracking-tight">{{ widgetDef?.title }}</div>
                <fwk-widget-filter *ngIf="widgetDef?.filterConfig?.show"
                    [options]="widgetDef.filterConfig.options"
                    [initialValue]="widgetDef.filterConfig.defaultOption"
                    (filterChange)="onFilterChanged($event)">
                </fwk-widget-filter>
            </div>
            <div class="relative flex-auto mt-4">
                <ng-container *ngIf="widgetDef?.isLoading">
                    <div class="relative inset-0 flex items-center justify-center">
                        <fwk-widget-skeleton [type]="widgetDef.type" class="w-full"></fwk-widget-skeleton>
                    </div>
                </ng-container>

                <ng-container *ngIf="!widgetDef.isLoading && widgetDef.hasError">
                    <div class="absolute inset-0 flex items-center justify-center">
                        <fwk-widget-error-state 
                            [title]="'widget_error_title' | translate"
                            [message]="widgetDef.errorMessage"
                            (retry)="onRetry()">
                        </fwk-widget-error-state>
                    </div>
                </ng-container>
                
                <ng-container *ngIf="!widgetDef?.isLoading">
                    <apx-chart #chart
                        *ngIf="chartOptions"
                        class="absolute inset-0"
                        [class.opacity-0]="widgetDef.isLoading || widgetDef.hasError || !hasData()"
                        [series]="chartOptions.series"
                        [chart]="chartOptions.chart"
                        [labels]="chartOptions.labels"
                        [legend]="chartOptions.legend"
                        [responsive]="chartOptions.responsive"
                        [theme]="chartOptions.theme">
                    </apx-chart>
                </ng-container>

                <ng-container *ngIf="!widgetDef.isLoading && !widgetDef.hasError && !hasData()">
                    <div class="absolute inset-0 flex items-center justify-center">
                        <fwk-widget-empty-state
                            [title]="'widget_empty_title' | translate"
                            [message]="'widget_empty_message' | translate">
                        </fwk-widget-empty-state>
                    </div>
                </ng-container>
            </div>
        </div>
    `,
    hostDirectives: [{
        directive: BaseWidgetDirective,
        inputs: ['widgetDef', 'i18nName'],
        outputs: ['dataLoaded'],
    }],
    encapsulation: ViewEncapsulation.None
})
export class PieChartWidgetComponent implements OnInit {
    @ViewChild('chart') chart: ChartComponent;
    @Input() widgetDef: DashboardWidgetDef;
    @Input() i18nName: string;

    public chartOptions: Partial<ApexChartOptions>;

    private baseDirective = inject(BaseWidgetDirective);
    private cdr = inject(ChangeDetectorRef);

    constructor() {
        this.baseDirective.dataLoaded.subscribe(() => this.updateChartData());
    }

    ngOnInit(): void {
        this.baseDirective.initialize();
        this.prepareChartOptions();
    }

    updateChartData(): void {
        if (this.widgetDef?.apexChartData) {
            this.chartOptions = {
                ...this.chartOptions,
                series: this.widgetDef.apexChartData.series,
                labels: this.widgetDef.apexChartData.labels,
            };
            this.cdr.markForCheck();
        }
    }

    hasData(): boolean {
        const series = this.widgetDef?.apexChartData?.series as number[];
        return !!(series && series.length > 0 && series.some(v => v > 0));
    }

    prepareChartOptions(): void {
        this.chartOptions = {
            chart: {
                type: 'pie',
                height: 350,
                toolbar: { show: false },
                zoom: { enabled: false },
            },
            series: [],
            labels: [],
            legend: {
                position: 'bottom',
                itemMargin: { horizontal: 10, vertical: 5 },
            },
            responsive: [{
                breakpoint: 480,
                options: {
                    chart: { width: 200 },
                    legend: { position: 'bottom' }
                }
            }],
            theme: {
                mode: document.body.classList.contains('dark') ? 'dark' : 'light'
            },
        };
    }

    onFilterChanged(value: string) {
        this.baseDirective.onFilterChanged(value);
    }

    onRetry(): void {
        this.onFilterChanged(this.widgetDef.filterConfig?.defaultOption || 'all');
    }
}

--- FILE: @fwk/components/dashboard/widgets/polar-area-chart-widget/polar-area-chart-widget.component.ts ---

import { Component, Input, OnInit, ViewEncapsulation, inject, ChangeDetectorRef, ViewChild } from '@angular/core';
import { CommonModule } from '@angular/common';
import { BaseWidgetDirective } from '../../base-widget.directive';
import { WidgetFilterComponent } from '../widget-filter/widget-filter.component';
import { DashboardWidgetDef, ApexChartOptions } from '@fwk/model/component-def/dashboard-def';
import { WidgetSkeletonComponent } from '../widget-skeleton/widget-skeleton.component';
import { WidgetErrorStateComponent } from '../widget-error-state/widget-error-state.component';
import { WidgetEmptyStateComponent } from '../widget-empty-state/widget-empty-state.component';
import { NgApexchartsModule, ChartComponent } from 'ng-apexcharts';

@Component({
    selector: 'fwk-polar-area-chart-widget',
    standalone: true,
    imports: [CommonModule, NgApexchartsModule, WidgetFilterComponent, WidgetSkeletonComponent, WidgetErrorStateComponent, WidgetEmptyStateComponent],
    template: `
        <div class="bg-card flex flex-col overflow-hidden rounded-2xl p-6 shadow">
            <div class="flex items-start justify-between">
                <div class="truncate text-lg font-medium leading-6 tracking-tight">{{ widgetDef?.title }}</div>
                <fwk-widget-filter *ngIf="widgetDef?.filterConfig?.show"
                    [options]="widgetDef.filterConfig.options"
                    [initialValue]="widgetDef.filterConfig.defaultOption"
                    (filterChange)="onFilterChanged($event)">
                </fwk-widget-filter>
            </div>
            <div class="relative flex-auto mt-4">
                <ng-container *ngIf="widgetDef?.isLoading">
                    <div class="relative inset-0 flex items-center justify-center">
                        <fwk-widget-skeleton [type]="widgetDef.type" class="w-full"></fwk-widget-skeleton>
                    </div>
                </ng-container>

                <ng-container *ngIf="!widgetDef.isLoading && widgetDef.hasError">
                    <div class="absolute inset-0 flex items-center justify-center">
                        <fwk-widget-error-state 
                            [title]="'widget_error_title' | translate"
                            [message]="widgetDef.errorMessage"
                            (retry)="onRetry()">
                        </fwk-widget-error-state>
                    </div>
                </ng-container>
                
                <ng-container *ngIf="!widgetDef?.isLoading">
                    <apx-chart #chart
                        *ngIf="chartOptions"
                        class="absolute inset-0"
                        [class.opacity-0]="widgetDef.isLoading || widgetDef.hasError || !hasData()"
                        [series]="chartOptions.series"
                        [chart]="chartOptions.chart"
                        [labels]="chartOptions.labels"
                        [stroke]="chartOptions.stroke"
                        [fill]="chartOptions.fill"
                        [responsive]="chartOptions.responsive"
                        [theme]="chartOptions.theme"
                        [legend]="chartOptions.legend">
                    </apx-chart>
                </ng-container>
                
                <ng-container *ngIf="!widgetDef.isLoading && !widgetDef.hasError && !hasData()">
                    <div class="absolute inset-0 flex items-center justify-center">
                        <fwk-widget-empty-state
                            [title]="'widget_empty_title' | translate"
                            [message]="'widget_empty_message' | translate">
                        </fwk-widget-empty-state>
                    </div>
                </ng-container>
            </div>
        </div>
    `,
    hostDirectives: [{
        directive: BaseWidgetDirective,
        inputs: ['widgetDef', 'i18nName'],
        outputs: ['dataLoaded'],
    }],
    encapsulation: ViewEncapsulation.None
})
export class PolarAreaChartWidgetComponent implements OnInit {
    @ViewChild('chart') chart: ChartComponent;
    @Input() widgetDef: DashboardWidgetDef;
    @Input() i18nName: string;
    
    public chartOptions: Partial<ApexChartOptions>;

    private baseDirective = inject(BaseWidgetDirective);
    private cdr = inject(ChangeDetectorRef);

    constructor() {
        this.baseDirective.dataLoaded.subscribe(() => this.updateChartData());
    }

    ngOnInit(): void {
        this.baseDirective.initialize();
        this.prepareChartOptions();
    }

    updateChartData(): void {
        if (this.widgetDef?.apexChartData) {
            this.chartOptions = {
                ...this.chartOptions,
                series: this.widgetDef.apexChartData.series,
                labels: this.widgetDef.apexChartData.labels,
            };
            this.cdr.markForCheck();
        }
    }
    
    hasData(): boolean {
        const series = this.widgetDef?.apexChartData?.series as number[];
        return !!(series && series.length > 0 && series.some(v => v > 0));
    }
    
    prepareChartOptions(): void {
        this.chartOptions = {
            chart: {
                type: 'polarArea',
                height: 350,
                toolbar: { show: false },
                zoom: { enabled: false },
            },
            series: [],
            labels: [],
            stroke: { colors: ['#FFFFFF'] },
            fill: { opacity: 0.8 },
            legend: { position: 'bottom' },
            theme: {
                mode: document.body.classList.contains('dark') ? 'dark' : 'light'
            },
        };
    }

    onFilterChanged(value: string) {
        this.baseDirective.onFilterChanged(value);
    }
    
    onRetry(): void {
        this.onFilterChanged(this.widgetDef.filterConfig?.defaultOption || 'all');
    }
}

--- FILE: @fwk/components/dashboard/widgets/stat-card-widget/stat-card-widget.component.ts ---

import { Component, Input, OnInit, ViewEncapsulation, inject, ChangeDetectorRef } from '@angular/core';
import { CommonModule, DecimalPipe } from '@angular/common';
import { MatCardModule } from '@angular/material/card';
import { MatIconModule } from '@angular/material/icon';
import { BaseWidgetDirective } from '../../base-widget.directive';
import { WidgetFilterComponent } from '../widget-filter/widget-filter.component';
import { DashboardWidgetDef } from '@fwk/model/component-def/dashboard-def';
import { WidgetSkeletonComponent } from '../widget-skeleton/widget-skeleton.component';
import { WidgetErrorStateComponent } from '../widget-error-state/widget-error-state.component';
import { WidgetEmptyStateComponent } from '../widget-empty-state/widget-empty-state.component';

@Component({
    selector: 'fwk-stat-card-widget',
    standalone: true,
    imports: [CommonModule, DecimalPipe, MatCardModule, MatIconModule, WidgetFilterComponent, WidgetSkeletonComponent, WidgetErrorStateComponent, WidgetEmptyStateComponent],
    template: `
        <div class="bg-card flex flex-auto flex-col overflow-hidden rounded-2xl p-6 shadow">
            <ng-container *ngIf="widgetDef?.isLoading; else content">
                <div class="truncate text-lg font-medium leading-6 tracking-tight">{{ widgetDef?.title }}</div>
                <div class="relative inset-0 flex items-center justify-center">
                        <fwk-widget-skeleton [type]="widgetDef.type" class="w-full"></fwk-widget-skeleton>
                    </div>
            </ng-container>

            <ng-template #content>
                <ng-container *ngIf="!widgetDef.isLoading && widgetDef.hasError">
                    <div class="absolute inset-0 flex items-center justify-center">
                        <fwk-widget-error-state 
                            [title]="'widget_error_title' | translate"
                            [message]="widgetDef.errorMessage"
                            (retry)="onRetry()">
                        </fwk-widget-error-state>
                    </div>
                </ng-container>

                <ng-container *ngIf="!widgetDef.hasError">
                    <div class="flex items-start justify-between">
                        <div class="truncate text-lg font-medium leading-6 tracking-tight">{{ widgetDef?.title }}</div>
                        <fwk-widget-filter *ngIf="widgetDef?.filterConfig?.show"
                            [options]="widgetDef.filterConfig.options"
                            [initialValue]="widgetDef.filterConfig.defaultOption"
                            (filterChange)="onFilterChanged($event)">
                        </fwk-widget-filter>
                    </div>

                    <div *ngIf="widgetDef.dataSource && widgetDef.dataSource.length > 0; else noData" class="mt-2 flex flex-col items-center">
                        <ng-container *ngFor="let data of widgetDef.dataSource">
                            <div class="text-7xl font-bold leading-none tracking-tight sm:text-8xl"
                                [ngClass]="{
                                    'text-blue-500': data.color === 'blue' || !data.color,
                                    'text-red-500': data.color === 'red',
                                    'text-amber-500': data.color === 'amber',
                                    'text-green-500': data.color === 'green'
                                }">
                                {{ data.mainStat | number:'1.0-0':'es' }}
                            </div>
                             <div class="text-lg font-medium"
                                [ngClass]="{
                                    'text-blue-600 dark:text-blue-500': data.color === 'blue' || !data.color,
                                    'text-red-600 dark:text-red-500': data.color === 'red',
                                    'text-amber-600 dark:text-amber-500': data.color === 'amber',
                                    'text-green-600 dark:text-green-500': data.color === 'green'
                                }">
                                {{ data.mainStatLabel }}
                            </div>
                            <div *ngIf="data.secondaryStatLabel" class="text-secondary mt-5 flex w-full items-baseline justify-center">
                                <div class="truncate text-md font-medium">{{ data.secondaryStatLabel }}</div>
                                <div class="ml-1.5 text-lg font-semibold">{{ data.secondaryStat | number }}</div>
                            </div>
                        </ng-container>
                    </div>
                </ng-container>

                <ng-template #noData>
                      <fwk-widget-empty-state
                            [title]="'widget_empty_title' | translate"
                            [message]="'widget_empty_message' | translate">
                        </fwk-widget-empty-state>
                </ng-template>
            </ng-template>
        </div>
    `,
    hostDirectives: [{
        directive: BaseWidgetDirective,
        inputs: ['widgetDef', 'i18nName'],
        outputs: ['dataLoaded'],
    }],
    encapsulation: ViewEncapsulation.None
})
export class StatCardWidgetComponent implements OnInit {
    @Input() widgetDef: DashboardWidgetDef;
    @Input() i18nName: string;

    private baseDirective = inject(BaseWidgetDirective);
    private cdr = inject(ChangeDetectorRef);

    constructor() {
        this.baseDirective.dataLoaded.subscribe(() => {
            this.cdr.markForCheck();
        });
    }

    ngOnInit(): void {
        this.baseDirective.initialize();
    }

    onFilterChanged(value: string) {
        this.baseDirective.onFilterChanged(value);
    }

    onRetry(): void {
        this.onFilterChanged(this.widgetDef.filterConfig?.defaultOption || 'all');
    }
}

--- FILE: @fwk/components/dashboard/widgets/widget-empty-state/widget-empty-state.component.ts ---

import { Component, Input, ChangeDetectionStrategy } from '@angular/core';
import { CommonModule } from '@angular/common';
import { MatIconModule } from '@angular/material/icon';

@Component({
  selector: 'fwk-widget-empty-state',
  standalone: true,
  imports: [CommonModule, MatIconModule],
  template: `
    <div class="flex flex-col items-center justify-center text-center p-4 h-full text-secondary">
      <mat-icon class="icon-size-12">heroicons_outline:chart-pie</mat-icon>
      <p class="mt-2 font-medium">{{ title }}</p>
      <p class="mt-1 text-sm">{{ message }}</p>
    </div>
  `,
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class WidgetEmptyStateComponent {
  @Input() title: string = 'Sin datos';
  @Input() message: string = 'No hay información disponible para mostrar.';
}

--- FILE: @fwk/components/dashboard/widgets/widget-error-state/widget-error-state.component.ts ---

import { Component, Input, Output, EventEmitter, ChangeDetectionStrategy } from '@angular/core';
import { CommonModule } from '@angular/common';
import { MatIconModule } from '@angular/material/icon';
import { MatButtonModule } from '@angular/material/button';
import { TranslatePipe } from '@fwk/pipe/translate.pipe';

@Component({
  selector: 'fwk-widget-error-state',
  standalone: true,
  imports: [CommonModule, MatIconModule, MatButtonModule, TranslatePipe],
  template: `
    <div class="flex flex-col items-center justify-center text-center p-4 h-full">
      <mat-icon class="icon-size-12 text-warn-500">heroicons_outline:exclamation-triangle</mat-icon>
      <p class="mt-2 font-semibold text-lg">{{ title }}</p>
      <p class="mt-1 text-sm text-secondary">{{ message }}</p>
      <button mat-stroked-button color="warn" class="mt-6" (click)="retry.emit()">
        {{ 'widget_error_retry_button' | translate }}
      </button>
    </div>
  `,
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class WidgetErrorStateComponent {
  @Input() title: string;
  @Input() message: string;
  @Output() retry = new EventEmitter<void>();
}

--- FILE: @fwk/components/dashboard/widgets/widget-filter/widget-filter.component.ts ---

import { Component, EventEmitter, Input, OnInit, Output } from '@angular/core';
import { CommonModule } from '@angular/common';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatSelectModule } from '@angular/material/select';
import { FormControl, ReactiveFormsModule } from '@angular/forms';
import { DashboardFilterOption } from '@fwk/model/component-def/dashboard-def';

@Component({
  selector: 'fwk-widget-filter',
  standalone: true,
  imports: [CommonModule, ReactiveFormsModule, MatFormFieldModule, MatSelectModule],
  template: `
    <mat-form-field class="ml-auto -mt-2 -mb-5" appearance="outline" subscriptSizing="dynamic">
        <mat-select [formControl]="filterControl">
            <mat-option *ngFor="let option of options" [value]="option.value">
                {{ option.viewValue }}
            </mat-option>
        </mat-select>
    </mat-form-field>
  `
})
export class WidgetFilterComponent implements OnInit {
  @Input() options: DashboardFilterOption[] = [];
  @Input() initialValue: string = 'all';
  @Output() filterChange = new EventEmitter<string>();
  
  filterControl: FormControl;

  ngOnInit(): void {
    this.filterControl = new FormControl(this.initialValue);
    this.filterControl.valueChanges.subscribe((value: string) => {
      this.filterChange.emit(value);
    });
  }
}

--- FILE: @fwk/components/dashboard/widgets/widget-skeleton/widget-skeleton.component.ts ---

import { Component, ChangeDetectionStrategy, Input } from '@angular/core';
import { CommonModule } from '@angular/common';

@Component({
  selector: 'fwk-widget-skeleton',
  standalone: true,
  imports: [CommonModule],
  template: `
    <div [ngSwitch]="type" class="animate-pulse flex flex-col w-full">
      
      <!-- Skeleton para STAT CARD -->
      <ng-container *ngSwitchCase="'stat'">
        <div class="flex flex-col items-center justify-center flex-auto">
            <div class="w-1/4 h-14 bg-gray-200 dark:bg-gray-700 rounded-lg"></div>
            <div class="w-2/4 h-5 mt-2 bg-gray-200 dark:bg-gray-700 rounded-md"></div>
        </div>
      </ng-container>

      <!-- Skeleton para BAR Chart -->
      <ng-container *ngSwitchCase="'bar'">
        <div class="flex flex-col justify-between">
            <div class="w-3/5 h-4 bg-gray-200 dark:bg-gray-700 rounded"></div>
            <div class="flex items-end space-x-2 mt-4 flex-auto">
                <div class="h-1/4 bg-gray-200 dark:bg-gray-700 rounded w-full"></div>
                <div class="h-1/2 bg-gray-200 dark:bg-gray-700 rounded w-full"></div>
                <div class="h-3/4 bg-gray-200 dark:bg-gray-700 rounded w-full"></div>
                <div class="h-1/3 bg-gray-200 dark:bg-gray-700 rounded w-full"></div>
                <div class="h-5/6 bg-gray-200 dark:bg-gray-700 rounded w-full"></div>
                <div class="h-2/5 bg-gray-200 dark:bg-gray-700 rounded w-full"></div>
            </div>
        </div>
      </ng-container>

      <!-- Skeleton para LINE Chart -->
      <ng-container *ngSwitchCase="'line'">
        <div class="flex flex-col justify-between">
            <div class="w-3/5 h-4 bg-gray-200 dark:bg-gray-700 rounded"></div>
            <div class="flex items-end space-x-2 mt-4 flex-auto">
                <div class="h-1/4 bg-gray-200 dark:bg-gray-700 rounded w-full"></div>
                <div class="h-1/2 bg-gray-200 dark:bg-gray-700 rounded w-full"></div>
                <div class="h-3/4 bg-gray-200 dark:bg-gray-700 rounded w-full"></div>
                <div class="h-1/3 bg-gray-200 dark:bg-gray-700 rounded w-full"></div>
                <div class="h-5/6 bg-gray-200 dark:bg-gray-700 rounded w-full"></div>
                <div class="h-2/5 bg-gray-200 dark:bg-gray-700 rounded w-full"></div>
            </div>
        </div>
      </ng-container>

      <!-- Skeleton para PIE Chart -->
      <ng-container *ngSwitchCase="'pie'">
        <div class="flex flex-col items-center justify-center flex-auto">
            <div class="w-48 h-48 bg-gray-200 dark:bg-gray-700 rounded-full"></div>
            <div class="flex items-center justify-center space-x-4 mt-6">
                <div class="w-16 h-4 bg-gray-200 dark:bg-gray-700 rounded-full"></div>
                <div class="w-16 h-4 bg-gray-200 dark:bg-gray-700 rounded-full"></div>
                <div class="w-16 h-4 bg-gray-200 dark:bg-gray-700 rounded-full"></div>
            </div>
        </div>
      </ng-container>

      <!-- Skeleton para DONUT Chart -->
      <ng-container *ngSwitchCase="'donut'">
        <div class="flex flex-col items-center justify-center flex-auto">
            <div class="w-48 h-48 bg-gray-200 dark:bg-gray-700 rounded-full"></div>
            <div class="flex items-center justify-center space-x-4 mt-6">
                <div class="w-16 h-4 bg-gray-200 dark:bg-gray-700 rounded-full"></div>
                <div class="w-16 h-4 bg-gray-200 dark:bg-gray-700 rounded-full"></div>
                <div class="w-16 h-4 bg-gray-200 dark:bg-gray-700 rounded-full"></div>
            </div>
        </div>
      </ng-container>
      
      <!-- Skeleton para POLAR AREA Chart -->
      <ng-container *ngSwitchCase="'polarArea'">
        <div class="flex flex-col items-center justify-center flex-auto">
            <div class="w-48 h-48 bg-gray-200 dark:bg-gray-700 rounded-full"></div>
            <div class="flex items-center justify-center space-x-4 mt-6">
                <div class="w-16 h-4 bg-gray-200 dark:bg-gray-700 rounded-full"></div>
                <div class="w-16 h-4 bg-gray-200 dark:bg-gray-700 rounded-full"></div>
                <div class="w-16 h-4 bg-gray-200 dark:bg-gray-700 rounded-full"></div>
            </div>
        </div>
      </ng-container>

      <!-- Skeleton por Defecto (similar a Bar) -->
      <ng-container *ngSwitchDefault>
         <div class="flex flex-col justify-between">
            <div class="w-3/5 h-4 bg-gray-200 dark:bg-gray-700 rounded"></div>
            <div class="flex items-end space-x-2 mt-4 flex-auto">
                <div class="h-1/4 bg-gray-200 dark:bg-gray-700 rounded w-full"></div>
                <div class="h-1/2 bg-gray-200 dark:bg-gray-700 rounded w-full"></div>
                <div class="h-3/4 bg-gray-200 dark:bg-gray-700 rounded w-full"></div>
                <div class="h-1/3 bg-gray-200 dark:bg-gray-700 rounded w-full"></div>
            </div>
        </div>
      </ng-container>

    </div>
  `,
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class WidgetSkeletonComponent {
  @Input() type: 'stat' | 'bar' | 'line' | 'pie' | 'donut' | 'polarArea' | 'default' = 'default';
}

--- FILE: @fwk/components/dashboard-wrapper/dashboard-wrapper.component.ts ---

import { Component, OnInit, inject, ChangeDetectorRef } from '@angular/core';
import { ActivatedRoute } from '@angular/router';
import { CommonModule } from '@angular/common';
import { CrudRegistryService } from '@fwk/services/crud-registry.service';
import { CrudDef } from '@fwk/model/component-def/crud-def';
import { DashboardLayoutDef } from '@fwk/model/component-def/dashboard-def';
import { DashboardPageComponent } from '../dashboard/dashboard-page/dashboard-page.component';
import { normalizeCrudName } from '@fwk/utils/crud-route-generator';

@Component({
  selector: 'fwk-dashboard-wrapper',
  template: `
    <fwk-dashboard-page *ngIf="dashboardLayout" [layoutDef]="dashboardLayout" [i18nName]="i18nName" class="w-full"></fwk-dashboard-page>
  `,
  standalone: true,
  imports: [CommonModule, DashboardPageComponent],
})
export class DashboardWrapperComponent implements OnInit {
  dashboardLayout: DashboardLayoutDef | null = null;
  i18nName: string = 'fwk';

  private route = inject(ActivatedRoute);
  private registry = inject(CrudRegistryService);
  private cdr = inject(ChangeDetectorRef);

  ngOnInit(): void {
    const nameFromPath = this.route.snapshot.parent?.routeConfig?.path;
    if (nameFromPath) {
      const componentName = normalizeCrudName(nameFromPath);
      
      this.registry.get(componentName).then(def => {
          const crudDef = def as CrudDef;
          if (crudDef.dashboardConfig) {
              this.dashboardLayout = crudDef.dashboardConfig;
              this.i18nName = crudDef.i18n.name;
              this.cdr.markForCheck();
          } else {
              console.error(`[DashboardWrapper] No se encontró 'dashboardConfig' en la definición para ${componentName}`);
          }
      }).catch(err => {
        console.error(`[DashboardWrapper] Error al cargar la definición para ${componentName}:`, err);
      });
    } else {
        console.warn('[DashboardWrapper] No se pudo determinar el nombre del dashboard desde la ruta.');
    }
  }
}

--- FILE: @fwk/components/dynamic-form/custom-datepicker/custom-datepicker.component.html ---

<div class="flex items-center w-full space-x-2">
    <mat-form-field *ngIf="field" class="w-full" appearance="outline">
        <mat-label>{{ field.label }}</mat-label>
        
        <input
            matInput
            [id]="field.key"
            [placeholder]="field.label"
            [ngModel]="_value"
            [ngModelOptions]="{standalone: true}"
            [disabled]="isDisabled"
            [required]="field.required"
            [errorStateMatcher]="matcher"
            readonly
            (click)="openDateModal()"
            class="cursor-pointer">
    
        <button
            *ngIf="_value && !isDisabled"
            type="button"
            matSuffix
            mat-icon-button
            class="mr-2"
            [matTooltip]="'datepicker_clear_tooltip' | translate"
            (click)="remove(); $event.stopPropagation()">
            <mat-icon [svgIcon]="'heroicons_outline:x-mark'"></mat-icon>
        </button>
    
        <button
            *ngIf="!_value && !isDisabled"
            type="button"
            matSuffix
            mat-icon-button
            class="mr-2"
            [matTooltip]="'datepicker_open_tooltip' | translate"
            (click)="openDateModal()">
            <mat-icon [svgIcon]="'heroicons_outline:calendar-days'"></mat-icon>
        </button>
        
        <mat-error *ngIf="errorMessage">{{ errorMessage }}</mat-error>
    </mat-form-field>
</div>

--- FILE: @fwk/components/dynamic-form/custom-datepicker/custom-datepicker.component.ts ---

import { Component, forwardRef, inject, ChangeDetectorRef, Input } from '@angular/core';
import { CommonModule } from '@angular/common';
import { NG_VALUE_ACCESSOR, Validator, AbstractControl, ValidationErrors, NG_VALIDATORS, FormsModule, FormControl, FormGroupDirective, NgForm } from '@angular/forms';
import { MatDialog } from '@angular/material/dialog';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatInputModule } from '@angular/material/input';
import { MatButtonModule } from '@angular/material/button';
import { MatIconModule } from '@angular/material/icon';
import { MatTooltipModule } from '@angular/material/tooltip';
import { format, parse, isValid, getYear, getMonth, getDate, getHours, getMinutes } from 'date-fns';
import { MY_FORMATS } from '@fwk/services/dynamic-form/form.validator.service';
import { DynamicFieldFormComponent } from '../dynamic-field-form/dynamic-field-form.component';
import { DatepickerOptions } from '../../../model/dynamic-form/dynamic-field-options.interface';
import { TranslatePipe } from '@fwk/pipe/translate.pipe';
import { DatePickerModalComponent } from './datepicker-modal/datepicker-modal.component';
import { ErrorStateMatcher } from '@angular/material/core';

@Component({
    selector: 'fwk-custom-datepicker',
    templateUrl: './custom-datepicker.component.html',
    standalone: true,
    imports: [
        CommonModule, FormsModule, MatFormFieldModule, MatInputModule,
        MatButtonModule, MatIconModule, MatTooltipModule, TranslatePipe
    ],
    providers: [
        { provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => CustomDatePickerComponent), multi: true },
        { provide: NG_VALIDATORS, useExisting: forwardRef(() => CustomDatePickerComponent), multi: true }
    ]
})
export class CustomDatePickerComponent extends DynamicFieldFormComponent<string> implements Validator {

    matcher = new class implements ErrorStateMatcher {
        constructor(private component: CustomDatePickerComponent) { }
        isErrorState(control: FormControl | null, form: FormGroupDirective | NgForm | null): boolean {
            return !!(this.component.errorMessage || (control?.invalid && (control?.dirty || control?.touched)));
        }
    }(this);

    onValidatorChange: () => void = () => { };

    constructor(
        private dialog: MatDialog,
        private cdr: ChangeDetectorRef
    ) {
        super();
    }

    private get datepickerOptions(): DatepickerOptions {
        return this.field?.options as DatepickerOptions;
    }

    override writeValue(value: string | null): void {
        this._value = value;
        this.cdr.markForCheck();
    }

    override setDisabledState(isDisabled: boolean): void {
        this.isDisabled = isDisabled;
        this.cdr.markForCheck();
    }

    validate(control: AbstractControl): ValidationErrors | null {
        if (this.field?.required && !control.value) {
            return { required: true };
        }
        if (control.value) {
            const dateFormat = this.getDateFormat();
            if (!isValid(parse(control.value, dateFormat, new Date()))) {
                return { invalidDate: `El formato debe ser ${dateFormat}` };
            }
        }
        return null;
    }

    registerOnValidatorChange(fn: () => void): void {
        this.onValidatorChange = fn;
    }

    private getDateFormat(): string {
        return this.datepickerOptions?.format ??
            (this.datepickerOptions?.withHourAndMin ? MY_FORMATS.parse.dateInputHours : MY_FORMATS.parse.dateInput);
    }

    openDateModal(): void {
        if (this.isDisabled) return;

        const now = new Date();
        let initialDate = {
            day: getDate(now), month: getMonth(now) + 1, year: getYear(now),
            hour: getHours(now), minute: getMinutes(now)
        };

        if (this._value) {
            const parsed = parse(this._value, this.getDateFormat(), now);
            if (isValid(parsed)) {
                initialDate = {
                    day: getDate(parsed), month: getMonth(parsed) + 1, year: getYear(parsed),
                    hour: getHours(parsed), minute: getMinutes(parsed)
                };
            }
        }

        const dialogRef = this.dialog.open(DatePickerModalComponent, {
            width: '420px',
            data: {
                initialDate: initialDate,
                withHourAndMin: this.datepickerOptions?.withHourAndMin,
                title: this.field?.label || 'Seleccionar fecha'
            }
        });

        dialogRef.afterClosed().subscribe(result => {
            if (result instanceof Date && isValid(result)) {
                const newValue = format(result, this.getDateFormat());
                this._value = newValue;
                this.onChange(newValue);
                this.onTouch();
                this.cdr.markForCheck();
            }
        });
    }

    remove(): void {
        if (!this.isDisabled) {
            this._value = null;
            this.onChange(null);
            this.onTouch();
            this.cdr.markForCheck();
        }
    }
}

--- FILE: @fwk/components/dynamic-form/custom-datepicker/datepicker-modal/datepicker-modal.component.html ---

<div class="flex flex-col max-h-screen">
    <div
        class="flex-shrink-0 flex items-center justify-between pr-4 pl-6 h-16 border-b border-gray-200 dark:border-gray-600">
        <h2 mat-dialog-title class="text-xl font-semibold truncate m-0 p-0 flex items-center">
            <button *ngIf="currentView !== 'main'" mat-icon-button (click)="changeView('main')" class="mr-2">
                <mat-icon [svgIcon]="'heroicons_outline:arrow-left'"></mat-icon>
            </button>
            <mat-icon [svgIcon]="'heroicons_outline:calendar-days'" class="text-primary-500 mr-2"></mat-icon>
            {{ data.title }}
        </h2>
        <button mat-icon-button (click)="onCancel()" matTooltip="Cerrar">
            <mat-icon [svgIcon]="'heroicons_outline:x-mark'"></mat-icon>
        </button>
    </div>

    <div mat-dialog-content class="p-6 pb-3" [formGroup]="form">
        <div [ngSwitch]="currentView">
            <div *ngSwitchCase="'main'">
                <h3 class="text-sm font-medium text-secondary mb-2">{{ 'Seleccionar fecha' }}</h3>
                <div class="flex gap-3 w-full">
                    <button type="button" (click)="changeView('day')"
                        class="flex w-1/4 flex-col items-center justify-center rounded-lg border border-gray-300 dark:border-gray-800 hover:border-gray-100 bg-gray-100 dark:bg-gray-700 hover:dark:bg-gray-900 py-2 px-3 text-center transition-colors hover:border-primary-400 hover:bg-gray-200"
                        [ngClass]="{'border-red-500': form.get('day').invalid && form.get('day').touched, 'border-gray-200': !form.get('day').invalid || !form.get('day').touched}">
                        <span class=" text-xs text-gray-500 dark:text-gray-200">{{ 'day_label' | translate }}</span>
                        <span class="text-xl font-medium text-gray-800 dark:text-white">{{ form.get('day').value || '--'
                            }}</span>
                    </button>

                    <button type="button" (click)="changeView('month')"
                        class="flex flex-grow flex-col items-center justify-center rounded-lg border border-gray-300 dark:border-gray-800 hover:border-gray-100 bg-gray-100 dark:bg-gray-700 hover:dark:bg-gray-900 py-2 px-3 text-center transition-colors hover:border-primary-400 hover:bg-gray-200">
                        <span class=" text-xs text-gray-500 dark:text-gray-200">{{ 'month_label' | translate }}</span>
                        <span class="text-xl font-medium text-gray-800 dark:text-white capitalize">{{
                            getMonthName(form.get('month').value) || '----' }}</span>
                    </button>

                    <button type="button" (click)="changeView('year')"
                        class="flex w-1/4 flex-col items-center justify-center rounded-lg border border-gray-300 dark:border-gray-800 hover:border-gray-100 bg-gray-100 dark:bg-gray-700 hover:dark:bg-gray-900 py-2 px-3 text-center transition-colors hover:border-primary-400 hover:bg-gray-200">
                        <span class=" text-xs text-gray-500 dark:text-gray-200">{{ 'year_label' | translate }}</span>
                        <span class="text-xl font-medium text-gray-800 dark:text-white">{{ form.get('year').value ||
                            '----' }}</span>
                    </button>
                </div>
                <mat-error *ngIf="form.hasError('invalidDate') && form.get('day').touched" class="mt-1 text-xs">
                    La fecha seleccionada no es válida.
                </mat-error>

                <div *ngIf="data.withHourAndMin" class="mt-4">
                    <div class="flex gap-3 w-full">
                        <button type="button" (click)="changeView('hour')"
                            class="flex w-1/2 flex-col items-center justify-center rounded-lg border border-gray-300 dark:border-gray-800 hover:border-gray-100 bg-gray-100 dark:bg-gray-700 hover:dark:bg-gray-900 py-2 px-3 text-center transition-colors hover:border-primary-400 hover:bg-gray-200">
                            <span class=" text-xs text-gray-500 dark:text-gray-200">{{ 'hour_label' | translate
                                }}</span>
                            <span class="text-xl font-medium text-gray-800 dark:text-white">{{ form.get('hour').value |
                                number: '2.0' }}</span>
                        </button>
                        <button type="button" (click)="changeView('minute')"
                            class="flex w-1/2 flex-col items-center justify-center rounded-lg border border-gray-300 dark:border-gray-800 hover:border-gray-100 bg-gray-100 dark:bg-gray-700 hover:dark:bg-gray-900 py-2 px-3 text-center transition-colors hover:border-primary-400 hover:bg-gray-200">
                            <span class=" text-xs text-gray-500 dark:text-gray-200">{{ 'minute_label' | translate
                                }}</span>
                            <span class="text-xl font-medium text-gray-800 dark:text-white">{{ form.get('minute').value
                                | number: '2.0' }}</span>
                        </button>
                    </div>
                </div>

                <div class="mt-6 pt-4 border-t border-gray-200 dark:border-gray-600">
                    <mat-checkbox formControlName="useCurrentDateTime">
                        {{ data.withHourAndMin ? 'Usar fecha y hora actual' : 'Usar fecha actual' }}
                    </mat-checkbox>
                </div>
            </div>

            <div *ngSwitchCase="'day'">
                <div class="grid grid-cols-7 gap-1 mb-2">
                    <div *ngFor="let day of weekDays" class="text-center text-sm font-bold text-gray-400">{{ day }}
                    </div>
                </div>
                <div class="grid grid-cols-7 gap-1">
                    <button *ngFor="let day of calendarDays" type="button" (click)="selectDay(day)"
                        class="flex h-10 w-full items-center justify-center rounded-lg text-sm transition-colors"
                        [ngClass]="{
                            'bg-primary-600 text-white font-semibold hover:bg-primary-700': day.day === form.get('day').value && day.isCurrentMonth,
                            'hover:bg-gray-200 dark:hover:bg-gray-700': day.isCurrentMonth && day.day !== form.get('day').value,
                            'text-gray-400 dark:text-gray-700 cursor-default': !day.isCurrentMonth
                        }">
                        {{ day.day }}
                    </button>
                </div>
            </div>

            <div *ngSwitchCase="'month'">
                <div class="grid grid-cols-3 gap-2">
                    <button *ngFor="let m of months" type="button" (click)="selectValue('month', m.value)"
                        class="flex h-12 items-center justify-center rounded-lg text-sm capitalize transition-colors"
                        [ngClass]="{
                            'bg-primary-600 text-white font-semibold hover:bg-primary-700': m.value === form.get('month').value,
                            'hover:bg-gray-200 bg-gray-50 dark:bg-gray-700 dark:hover:bg-gray-600': m.value !== form.get('month').value
                        }">
                        {{ m.label }}
                    </button>
                </div>
            </div>

            <div *ngSwitchCase="'year'">
                <div class="grid max-h-52 grid-cols-4 gap-2 overflow-y-auto pr-2">
                    <button *ngFor="let y of years" type="button" (click)="selectValue('year', y)"
                        class="flex h-10 items-center justify-center rounded-lg text-sm transition-colors" [ngClass]="{
                            'bg-primary-600 text-white font-semibold hover:bg-primary-700': y === form.get('year').value,
                            'hover:bg-gray-200 bg-gray-50 dark:bg-gray-700 dark:hover:bg-gray-600': y !== form.get('year').value
                        }">
                        {{ y }}
                    </button>
                </div>
                <mat-divider class="my-4"></mat-divider>
                <p class="text-sm text-gray-500 mb-2">O introduce un año personalizado:</p>
                <mat-form-field appearance="outline" subscriptSizing="dynamic" class="w-full">
                    <mat-label>{{ 'year_label' | translate }}</mat-label>
                    <input matInput type="number" formControlName="year" (change)="form.get('year').markAsDirty()">
                </mat-form-field>
            </div>

            <div *ngSwitchCase="'hour'">
                <div class="grid grid-cols-6 gap-2">
                    <button *ngFor="let h of hours" type="button" (click)="selectValue('hour', h)"
                        class="flex h-10 items-center justify-center rounded-lg text-sm transition-colors" [ngClass]="{
                            'bg-primary-600 text-white font-semibold hover:bg-primary-700': h === form.get('hour').value,
                            'hover:bg-gray-200 bg-gray-50 dark:bg-gray-700 dark:hover:bg-gray-600': h !== form.get('hour').value
                        }">
                        {{ h | number: '2.0' }}
                    </button>
                </div>
            </div>
            <div *ngSwitchCase="'minute'">
                <div class="grid grid-cols-4 gap-2">
                    <button *ngFor="let min of minuteOptions" type="button" (click)="selectValue('minute', min)"
                        class="flex h-10 items-center justify-center rounded-lg text-sm transition-colors" [ngClass]="{
                            'bg-primary-600 text-white font-semibold hover:bg-primary-700': min === form.get('minute').value,
                            'hover:bg-gray-200 bg-gray-50 dark:bg-gray-700 dark:hover:bg-gray-600': min !== form.get('minute').value
                        }">
                        {{ min | number: '2.0' }}
                    </button>
                </div>

                <mat-divider class="my-4"></mat-divider>
                <p class="text-sm text-gray-500 mb-2">O introduce un minuto personalizado:</p>
                <mat-form-field appearance="outline" subscriptSizing="dynamic" class="w-full">
                    <mat-label>{{ 'minute_label' | translate }}</mat-label>
                    <input matInput type="number" formControlName="minute" (change)="form.get('minute').markAsDirty()">
                </mat-form-field>
            </div>
        </div>
    </div>

    <div mat-dialog-actions
        class="flex flex-shrink-0 items-center justify-end p-6 pt-4 border-none">
        <button mat-button (click)="onCancel()">{{ 'modal_button_cancel' | translate }}</button>
        <button mat-flat-button color="accent" (click)="onSave()"
            [disabled]="form.invalid && !form.get('useCurrentDateTime').value">
            {{ 'modal_button_confirm' | translate }}
        </button>
    </div>
</div>

--- FILE: @fwk/components/dynamic-form/custom-datepicker/datepicker-modal/datepicker-modal.component.ts ---

import { Component, ChangeDetectionStrategy, inject, Inject, OnInit } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormBuilder, FormGroup, ReactiveFormsModule, ValidationErrors, ValidatorFn, Validators } from '@angular/forms';
import { MatDialogRef, MAT_DIALOG_DATA, MatDialogModule } from '@angular/material/dialog';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatInputModule } from '@angular/material/input';
import { MatButtonModule } from '@angular/material/button';
import { MatIconModule } from '@angular/material/icon';
import { MatCheckboxModule } from '@angular/material/checkbox';
import { MatDividerModule } from '@angular/material/divider';
import { TranslatePipe } from '@fwk/pipe/translate.pipe';
import { format, getDaysInMonth, startOfMonth, getDay } from 'date-fns';
import { es } from 'date-fns/locale';

export interface DatePickerModalData {
    initialDate: {
        day?: number;
        month?: number;
        year?: number;
        hour?: number;
        minute?: number;
    };
    withHourAndMin: boolean;
    title: string;
}

type PickerView = 'main' | 'day' | 'month' | 'year' | 'hour' | 'minute';

interface CalendarDay {
    day: number;
    isCurrentMonth: boolean;
}

@Component({
     selector: 'fwk-datepicker-modal',
    standalone: true,
    imports: [
        CommonModule, ReactiveFormsModule, MatDialogModule, MatFormFieldModule, MatInputModule,
        MatButtonModule, MatIconModule, MatCheckboxModule, MatDividerModule, TranslatePipe
    ],
    templateUrl: './datepicker-modal.component.html',
    changeDetection: ChangeDetectionStrategy.OnPush,
})
export class DatePickerModalComponent implements OnInit {
    private _fb = inject(FormBuilder);

    form: FormGroup;
    currentView: PickerView = 'main';

    months = Array.from({ length: 12 }, (_, i) => ({
        label: format(new Date(2000, i, 1), 'MMMM', { locale: es }),
        value: i + 1
    }));
    years = Array.from({ length: 11 }, (_, i) => 2020 + i); // 2020-2030
    hours = Array.from({ length: 24 }, (_, i) => i);
    minuteOptions = Array.from({ length: 12 }, (_, i) => i * 5);
    calendarDays: CalendarDay[] = [];
    weekDays = ['Do', 'Lu', 'Ma', 'Mi', 'Ju', 'Vi', 'Sa'];

    constructor(
        public dialogRef: MatDialogRef<DatePickerModalComponent>,
        @Inject(MAT_DIALOG_DATA) public data: DatePickerModalData,
    ) {}

    ngOnInit(): void {
        const initial = this.data.initialDate;
        
        this.form = this._fb.group({
            day: [initial.day, [Validators.required, Validators.min(1), Validators.max(31)]],
            month: [initial.month, Validators.required],
            year: [initial.year, [Validators.required, Validators.min(1900), Validators.max(2100)]],
            hour: [initial.hour, [Validators.required, Validators.min(0), Validators.max(23)]],
            minute: [initial.minute, [Validators.required, Validators.min(0), Validators.max(59)]],
            useCurrentDateTime: [false]
        }, { validators: this.dateValidator() });
        
        if (!this.data.withHourAndMin) {
            this.form.get('hour').disable();
            this.form.get('minute').disable();
        }

        this.form.get('useCurrentDateTime').valueChanges.subscribe(useCurrent => {
            const fieldsToToggle = ['day', 'month', 'year', 'hour', 'minute'];
            fieldsToToggle.forEach(fieldName => {
                const control = this.form.get(fieldName);
                if (useCurrent) {
                    control.disable();
                } else {
                    if (this.data.withHourAndMin || !['hour', 'minute'].includes(fieldName)) {
                        control.enable();
                    }
                }
            });
        });

        this.generateCalendarDays();
        this.form.get('month').valueChanges.subscribe(() => this.generateCalendarDays());
        this.form.get('year').valueChanges.subscribe(() => this.generateCalendarDays());
    }

    changeView(view: PickerView): void {
        this.currentView = view;
    }

    getMonthName(monthValue: number): string {
        return this.months.find(m => m.value === monthValue)?.label || '';
    }

    selectValue(field: string, value: number | string): void {
        this.form.get(field).setValue(value);
        this.form.get(field).markAsDirty();
        if (field === 'month' || field === 'year') {
           this.form.updateValueAndValidity();
        }
        this.changeView('main');
    }

    selectDay(day: CalendarDay): void {
        if (!day.isCurrentMonth) return;
        this.selectValue('day', day.day);
    }
    
    generateCalendarDays(): void {
        const year = this.form.get('year').value;
        const month = this.form.get('month').value - 1;
        if (year === null || month === null) return;

        const date = new Date(year, month, 1);
        const daysInMonth = getDaysInMonth(date);
        const firstDayOfMonth = startOfMonth(date);
        const startDayOfWeek = getDay(firstDayOfMonth); 

        const days: CalendarDay[] = [];
        const prevMonthDays = getDaysInMonth(new Date(year, month - 1));

        for (let i = startDayOfWeek; i > 0; i--) {
            days.push({ day: prevMonthDays - i + 1, isCurrentMonth: false });
        }
        for (let i = 1; i <= daysInMonth; i++) {
            days.push({ day: i, isCurrentMonth: true });
        }
        const remainingCells = 42 - days.length;
        for (let i = 1; i <= remainingCells; i++) {
            days.push({ day: i, isCurrentMonth: false });
        }
        this.calendarDays = days;
    }
    
    dateValidator(): ValidatorFn {
        return (group: FormGroup): ValidationErrors | null => {
            const day = group.get('day').value;
            const month = group.get('month').value;
            const year = group.get('year').value;
            if (!day || !month || !year) return null;
            const daysInMonth = getDaysInMonth(new Date(year, month - 1));
            if (day > daysInMonth) {
                group.get('day').setErrors({ invalidDate: true });
                return { invalidDate: true };
            }
            if (group.get('day').hasError('invalidDate')) {
                group.get('day').setErrors(null);
            }
            return null;
        };
    }
    
    onSave(): void {
        if (this.form.invalid && !this.form.get('useCurrentDateTime').value) {
            this.form.markAllAsTouched();
            return;
        }

        let resultDate: Date;
        if (this.form.get('useCurrentDateTime').value) {
            resultDate = new Date();
        } else {
            const formValue = this.form.getRawValue();
            resultDate = new Date(
                formValue.year,
                formValue.month - 1,
                formValue.day,
                this.data.withHourAndMin ? formValue.hour : 0,
                this.data.withHourAndMin ? formValue.minute : 0
            );
        }
        this.dialogRef.close(resultDate);
    }

    onCancel(): void {
        this.dialogRef.close();
    }
}

--- FILE: @fwk/components/dynamic-form/disclaimer/disclaimer.component.html ---

﻿<div class="flex flex-col">
    <div class="flex items-center space-x-2">
        <mat-checkbox
            [checked]="_value"
            [disabled]="isDisabled"
            [color]="errorMessage ? 'warn' : 'accent'"
            (change)="onCheckboxChange($event.checked)">
            <span class="leading-tight" [class.text-red-500]="errorMessage">{{ field?.label }}</span>
        </mat-checkbox>
    
        <a *ngIf="field?.options?.disclaimer?.label"
            href="#"
            (click)="openDisclaimer($event)"
            class="text-primary-600 dark:text-primary-400 hover:underline"
            [class.text-red-500]="errorMessage">
            {{ field.options.disclaimer.label }}
        </a>
    </div>

    <div *ngIf="errorMessage" class="text-xs text-red-500 ml-3 mt-1">
        {{ errorMessage }}
    </div>
</div>

--- FILE: @fwk/components/dynamic-form/disclaimer/disclaimer.component.ts ---

﻿import { Component, forwardRef, inject, ChangeDetectorRef, Input } from '@angular/core';
import { CommonModule } from '@angular/common';
import { ControlValueAccessor, NG_VALUE_ACCESSOR, FormsModule } from '@angular/forms';
import { MatCheckboxModule } from '@angular/material/checkbox';

import { DialogService } from '../../../services/dialog-service/dialog.service';
import { DynamicFieldFormComponent } from '../dynamic-field-form/dynamic-field-form.component';
import { DisclaimerOptions } from '../../../model/dynamic-form/dynamic-field-options.interface';
import { I18nService } from '@fwk/services/i18n-service/i18n.service';

@Component({
     selector: 'fwk-disclaimer',
    templateUrl: './disclaimer.component.html',
    standalone: true,
    imports: [
        CommonModule,
        FormsModule,
        MatCheckboxModule
    ],
    providers: [
        {
            provide: NG_VALUE_ACCESSOR,
            useExisting: forwardRef(() => DisclaimerComponent),
            multi: true
        }
    ]
})
export class DisclaimerComponent extends DynamicFieldFormComponent<boolean> implements ControlValueAccessor {

    @Input() errorMessage: string | null = null;

    private i18nService = inject(I18nService);

    constructor(
        private dialogService: DialogService,
        private cdr: ChangeDetectorRef
    ) {
        super();
    }
    
    private translate(key: string): string {
        return this.i18nService.getDictionary('fwk')?.translate?.(key) || key;
    }

    private get disclaimerOptions(): DisclaimerOptions {
        return this.field?.options as DisclaimerOptions;
    }

    override writeValue(value: any): void {
        this._value = !!value;
        this.cdr.markForCheck();
    }

    override setDisabledState(isDisabled: boolean): void {
        this.isDisabled = isDisabled;
        this.cdr.markForCheck();
    }

    onCheckboxChange(checked: boolean): void {
        if (!this.isDisabled) {
            this._value = checked;
            this.onChange(this._value);
            this.onTouch();
            this.cdr.markForCheck();
        }
    }

    openDisclaimer(event: Event): void {
        event.preventDefault();
        event.stopPropagation();

        const disclaimer = this.disclaimerOptions?.disclaimer;
        if (disclaimer?.content) {
            const data = {
                title: disclaimer.label || this.translate('terms_and_conditions_default_title'),
                html: disclaimer.content,
            };
            this.dialogService.openHtmlModal(data, { width: '80vw', maxWidth: '900px' });
        }
    }
}

--- FILE: @fwk/components/dynamic-form/dynamic-field-form/dynamic-field-form.component.ts ---

﻿import { Directive, Input } from '@angular/core';
import { ControlValueAccessor } from '@angular/forms';
import { DynamicField } from '../../../model/dynamic-form/dynamic-field';

@Directive()
export abstract class DynamicFieldFormComponent<T> implements ControlValueAccessor {

    @Input() field!: DynamicField<any>;
    @Input() errorMessage: string | null = null;
    protected _value: T | null = null;

    isDisabled: boolean = false;

    onChange: (value: T | null) => void = () => {};

    onTouch: () => void = () => {};

    writeValue(value: T | null): void {
        this._value = value;
    }

    registerOnChange(fn: (value: T | null) => void): void {
        this.onChange = fn;
    }

    registerOnTouched(fn: () => void): void {
        this.onTouch = fn;
    }

    setDisabledState(isDisabled: boolean): void {
        this.isDisabled = isDisabled;
    }

    getFloatLabel(): 'auto' | 'always' | 'never' {
        return this.field?.options?.['floatLabel'] ?? 'auto';
    }

    getRestrictionKeys(): string | undefined {
        return this.field?.options?.restrictionKeys;
    }
}

--- FILE: @fwk/components/dynamic-form/dynamic-form.component.html ---

﻿<form *ngIf="form" #formDirective="ngForm"
    class="dynamicFormDiv grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-6" [formGroup]="form" novalidate>

    <div *ngFor="let field of fields; let i = index" class="dynamicFieldDiv" [class]="field.cssClass || ''" [ngClass]="{
                'hidden': field.controlType === 'hidden',
                'sm:col-span-1 lg:col-span-1': field.colSpan === 1,
                'sm:col-span-2 lg:col-span-2': field.colSpan === 2,
                'sm:col-span-2 lg:col-span-3': field.colSpan === 3,
                'col-span-full': !field.colSpan || field.colSpan === 4
            }">

        <ng-container [ngSwitch]="field.controlType">
            <fwk-url-input *ngSwitchCase="'url_input'" class="w-full" [config]="field"
                [formControlName]="field.key"
                [errorMessage]="(form.get(field.key)?.invalid && form.get(field.key)?.touched) ? getMessageErrorValidation(field) : null"
                [cdkFocusInitial]="i === firstFocusableFieldIndex">
            </fwk-url-input>

            <fwk-custom-datepicker *ngSwitchCase="'datepicker'" class="w-full" [field]="field"
                [formControlName]="field.key"
                [errorMessage]="(form.get(field.key)?.invalid && form.get(field.key)?.touched) ? getMessageErrorValidation(field) : null"
                [cdkFocusInitial]="i === firstFocusableFieldIndex">
            </fwk-custom-datepicker>

            <fwk-custom-datepicker *ngSwitchCase="'datetimepicker'" class="w-full" [field]="field"
                [formControlName]="field.key"
                [errorMessage]="(form.get(field.key)?.invalid && form.get(field.key)?.touched) ? getMessageErrorValidation(field) : null"
                [cdkFocusInitial]="i === firstFocusableFieldIndex">
            </fwk-custom-datepicker>

            <fwk-file *ngSwitchCase="'file'" class="w-full" [field]="field" [formControlName]="field.key"
                [errorMessage]="(form.get(field.key)?.invalid && form.get(field.key)?.touched) ? getMessageErrorValidation(field) : null"
                [cdkFocusInitial]="i === firstFocusableFieldIndex">
            </fwk-file>

            <fwk-disclaimer *ngSwitchCase="'disclaimer'" class="w-full" [field]="field" [formControlName]="field.key"
                [errorMessage]="(form.get(field.key)?.invalid && form.get(field.key)?.touched) ? getMessageErrorValidation(field) : null">
            </fwk-disclaimer>

            <fwk-float *ngSwitchCase="'float'" class="w-full" [field]="field" [formControlName]="field.key"
                [errorMessage]="(form.get(field.key)?.invalid && form.get(field.key)?.touched) ? getMessageErrorValidation(field) : null"
                [cdkFocusInitial]="i === firstFocusableFieldIndex">
            </fwk-float>

            <fwk-pick-list *ngSwitchCase="'pick-list'" class="w-full" [formControlName]="field.key"
                [elementLabel]="field.options?.elementLabel" [titleFrom]="field.options?.titleFrom"
                [titleTo]="field.options?.titleTo" [allItems]="field.options?.fromData"
                [errorMessage]="(form.get(field.key)?.invalid && form.get(field.key)?.touched) ? getMessageErrorValidation(field) : null">
            </fwk-pick-list>

            <fwk-simple-pick-list *ngSwitchCase="'simple-pick-list'" class="w-full" [formControlName]="field.key"
                [elementLabel]="field.options?.elementLabel" [titleFrom]="field.options?.titleFrom"
                [errorMessage]="(form.get(field.key)?.invalid && form.get(field.key)?.touched) ? getMessageErrorValidation(field) : null"
                [allItems]="field.options?.fromData"></fwk-simple-pick-list>

            <fwk-autocomplete *ngSwitchCase="'autocomplete'" class="w-full" [formControlName]="field.key"
                [config]="field" [searchTermInterface]="searchTermInterface(field)"
                [errorMessage]="(form.get(field.key)?.invalid && form.get(field.key)?.touched) ? getMessageErrorValidation(field) : null"
                [cdkFocusInitial]="i === firstFocusableFieldIndex">
            </fwk-autocomplete>

            <fwk-autocomplete-desplegable *ngSwitchCase="'autocomplete-desplegable'" class="w-full"
                [formControlName]="field.key" [config]="field" [searchTermInterface]="searchTermInterface(field)"
                [errorMessage]="(form.get(field.key)?.invalid && form.get(field.key)?.touched) ? getMessageErrorValidation(field) : null"
                [cdkFocusInitial]="i === firstFocusableFieldIndex">
            </fwk-autocomplete-desplegable>

            <fwk-color-picker *ngSwitchCase="'color_picker'" class="w-full" [formControlName]="field.key"
                [config]="getColorPickerConfig(field)"
                [errorMessage]="(form.get(field.key)?.invalid && form.get(field.key)?.touched) ? getMessageErrorValidation(field) : null"
                [cdkFocusInitial]="i === firstFocusableFieldIndex">
            </fwk-color-picker>

            <fwk-tags *ngSwitchCase="'tags'" class="w-full" [config]="field" [formControlName]="field.key"
                [errorMessage]="(form.get(field.key)?.invalid && form.get(field.key)?.touched) ? getMessageErrorValidation(field) : null"
                [cdkFocusInitial]="i === firstFocusableFieldIndex">
            </fwk-tags>

            <fwk-icon-picker *ngSwitchCase="'icon-picker'" class="w-full" [label]="field.label"
                [namespace]="field.options?.['namespace'] || 'heroicons_outline'" [formControlName]="field.key"
                [errorMessage]="(form.get(field.key)?.invalid && form.get(field.key)?.touched) ? getMessageErrorValidation(field) : null"
                [cdkFocusInitial]="i === firstFocusableFieldIndex">
            </fwk-icon-picker>

            <div *ngSwitchCase="'radio-button'">
                <mat-label class="block text-sm font-medium text-gray-500 dark:text-gray-400 mb-1">
                    {{ field.label }}
                </mat-label>
                <mat-radio-group class="flex flex-wrap gap-x-4 pt-1" [formControlName]="field.key"
                    [cdkFocusInitial]="i === firstFocusableFieldIndex">
                    <mat-radio-button *ngFor="let option of field.options?.options" [value]="option.value"
                        class="dark:text-gray-200">
                        {{ option.label }}
                    </mat-radio-button>
                </mat-radio-group>
            </div>

            <mat-form-field *ngSwitchCase="'textarea'" class="w-full" appearance="outline">
                <mat-label>{{ field.label }}</mat-label>
                <textarea matInput [formControlName]="field.key" [id]="field.key" cdkTextareaAutosize
                    [cdkFocusInitial]="i === firstFocusableFieldIndex"></textarea>
                <mat-error *ngIf="form.get(field.key)?.invalid">{{ getMessageErrorValidation(field) }}</mat-error>
            </mat-form-field>

            <mat-form-field *ngSwitchCase="'textbox'" [floatLabel]="getFloatLabel(field)" class="w-full"
                appearance="outline">
                <mat-label>{{ field.options?.matLabel ?? field.label }}</mat-label>
                <input matInput [formControlName]="field.key" [id]="field.key" [type]="field.options?.type ?? 'text'"
                    [cdkFocusInitial]="i === firstFocusableFieldIndex">
                <mat-error *ngIf="form.get(field.key)?.invalid">{{ getMessageErrorValidation(field) }}</mat-error>
            </mat-form-field>

            <mat-form-field *ngSwitchCase="'number'" [floatLabel]="getFloatLabel(field)" class="w-full"
                appearance="outline">
                <mat-label>{{ field.options?.matLabel ?? field.label }}</mat-label>
                <input matInput [min]="field.minValue" [formControlName]="field.key" [id]="field.key" type="number"
                    [cdkFocusInitial]="i === firstFocusableFieldIndex">
                <span *ngIf="field.options?.prefix" matPrefix>{{ field.options.prefix }}&nbsp;</span>
                <mat-error *ngIf="form.get(field.key)?.invalid">{{ getMessageErrorValidation(field) }}</mat-error>
            </mat-form-field>

            <mat-form-field *ngSwitchCase="'password'" class="w-full" appearance="outline">
                <mat-label>{{ field.label }}</mat-label>
                <input matInput [formControlName]="field.key" [id]="field.key" type="password"
                    [cdkFocusInitial]="i === firstFocusableFieldIndex">
                <mat-error *ngIf="form.get(field.key)?.invalid">{{ getMessageErrorValidation(field) }}</mat-error>
            </mat-form-field>

            <mat-form-field *ngSwitchCase="'email'" class="w-full" appearance="outline">
                <mat-label>{{ field.label }}</mat-label>
                <input matInput [formControlName]="field.key" [id]="field.key" type="email"
                    [cdkFocusInitial]="i === firstFocusableFieldIndex">
                <mat-error *ngIf="form.get(field.key)?.invalid">{{ getMessageErrorValidation(field) }}</mat-error>
            </mat-form-field>

            <mat-form-field *ngSwitchCase="'date_read'" class="w-full" appearance="outline">
                <mat-label>{{ field.label }}</mat-label>
                <input matInput [formControlName]="field.key" [id]="field.key" readonly>
            </mat-form-field>

            <mat-form-field *ngSwitchCase="'date_time_read'" class="w-full" appearance="outline">
                <mat-label>{{ field.label }}</mat-label>
                <input matInput [formControlName]="field.key" [id]="field.key" readonly>
            </mat-form-field>

            <mat-form-field *ngSwitchCase="'select'" [floatLabel]="getFloatLabel(field)" class="w-full"
                appearance="outline">
                <mat-label>{{ field.options?.matLabel ?? field.label }}</mat-label>
                <mat-select [formControlName]="field.key" (selectionChange)="onChangeSelect($event)"
                    [cdkFocusInitial]="i === firstFocusableFieldIndex">
                    <mat-option *ngFor="let data of field.options?.fromData"
                        [value]="field.options?.elementValue ? data[field.options.elementValue] : data">
                        {{ field.options?.elementLabel ? data[field.options.elementLabel] : data }}
                    </mat-option>
                </mat-select>
                <mat-error *ngIf="form.get(field.key)?.invalid">{{ getMessageErrorValidation(field) }}</mat-error>
            </mat-form-field>

            <mat-checkbox *ngSwitchCase="'checkbox'" [formControlName]="field.key" [id]="field.key"
                [cdkFocusInitial]="i === firstFocusableFieldIndex">{{ field.label }}</mat-checkbox>

            <div *ngSwitchCase="'label'" class="flex items-center h-full pt-2 pb-4">
                <span class="text-gray-700 dark:text-gray-300 font-medium">
                    {{ field.label || field.value }}
                </span>
            </div>

            <div *ngSwitchCase="'header'"
                class="col-span-full text-lg font-bold text-secondary border-b bg-gray-100 dark:bg-gray-700 text-center py-1 my-2 rounded-md">
                {{ field.label }}
            </div>

            <div *ngSwitchCase="'chip_list'">
                <mat-label class="block font-medium text-secondary mb-2">{{ field.label }}</mat-label>
                <mat-chip-listbox>
                    <mat-chip *ngFor="let data of field.value">{{ data }}</mat-chip>
                </mat-chip-listbox>
            </div>

            <div *ngSwitchCase="'image_preview_src'" class="flex flex-col items-center justify-center w-full py-2">
                <!-- <label *ngIf="field.label" class="block text-sm font-medium text-secondary mb-3">
                    {{ field.label }}
                </label> -->
                <ng-container *ngIf="field.value; else noImagePreview">
                    <img [src]="'data:image/jpeg;base64,' + field.value" alt="Previsualización"
                        class="border-2 dark:border-gray-700 transition-transform hover:scale-105 duration-300"
                        [ngClass]="{
                            'rounded-full aspect-square object-cover': field.options?.shape === 'circle',
                            'rounded-xl aspect-square object-cover': field.options?.shape === 'square',
                            'rounded-md max-w-full h-auto object-contain': !field.options?.shape || field.options?.shape === 'original'
                        }" [style.width]="field.options?.width || (field.options?.shape !== 'original' ? '150px' : '100%')"
                        [style.height]="field.options?.height || (field.options?.shape !== 'original' ? '150px' : 'auto')"
                        [style.object-fit]="field.options?.objectFit || 'cover'" />
                </ng-container>

                <ng-template #noImagePreview>
                    <div class="flex flex-col items-center justify-center bg-gray-100 dark:bg-gray-800 border-2 border-dashed border-gray-300 dark:border-gray-600 text-gray-400"
                        [ngClass]="{
                            'rounded-full aspect-square': field.options?.shape === 'circle',
                            'rounded-xl aspect-square': field.options?.shape === 'square',
                            'rounded-lg w-full h-48': !field.options?.shape || field.options?.shape === 'original'
                        }" [style.width]="field.options?.width || (field.options?.shape !== 'original' ? '150px' : '100%')"
                        [style.height]="field.options?.height || (field.options?.shape !== 'original' ? '150px' : 'auto')">

                        <mat-icon class="icon-size-8 mb-1" svgIcon="heroicons_outline:photo"></mat-icon>
                        <span class="text-[10px] font-medium uppercase tracking-wider">Sin imagen</span>
                    </div>
                </ng-template>
            </div>

            <div *ngSwitchCase="'html_editor'">
                <editor apiKey="30exq1o6h95wnouv3k486ppncqum1zcx7p75i83kwg546eld" [formControlName]="field.key"
                    initialValue="{{field.value}}" [init]="{
                language: 'es',
                language_url: '/assets/tinymce/langs/es.js',
                base_url: '/tinymce',
                suffix: '.min',
                custom_elements:'style',
                allow_unsafe_link_target: true,
                allow_html_in_named_anchor: true,
                height: 300,
                promotion: false,
                menubar: true,
                plugins: 'preview importcss searchreplace autolink autosave save directionality code visualblocks visualchars fullscreen image link media codesample table charmap pagebreak nonbreaking anchor insertdatetime advlist lists wordcount help charmap quickbars emoticons',
                toolbar: 'undo redo | bold italic underline strikethrough | fontfamily fontsize blocks | alignleft aligncenter alignright alignjustify | outdent indent |  numlist bullist | forecolor backcolor removeformat | pagebreak | charmap emoticons | fullscreen  preview save print | insertfile image media link anchor codesample | ltr rtl',
                toolbar_sticky: true,
                toolbar_mode: 'sliding',        
                contextmenu: 'link image table',
                quickbars_selection_toolbar: 'bold italic | quicklink h2 h3 blockquote quickimage quicktable',
                cleanup: false,
                extended_valid_elements: '*[*]'
                }"></editor>
            </div>

        </ng-container>
    </div>
</form>

--- FILE: @fwk/components/dynamic-form/dynamic-form.component.ts ---

﻿import { Component, OnInit, Input, Output, EventEmitter, ViewChild, ChangeDetectorRef, OnDestroy, Injector, ChangeDetectionStrategy } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormGroup, FormsModule, NgForm, ReactiveFormsModule } from '@angular/forms';
import { Observable, Subscription } from 'rxjs';
import { debounceTime, distinctUntilChanged, takeUntil } from 'rxjs/operators';

import { MatFormFieldModule } from '@angular/material/form-field';
import { MatInputModule } from '@angular/material/input';
import { MatSelectModule } from '@angular/material/select';
import { MatCheckboxModule } from '@angular/material/checkbox';
import { MatRadioModule } from '@angular/material/radio';
import { MatChipsModule } from '@angular/material/chips';
import { MAT_DATE_LOCALE, MAT_DATE_FORMATS } from '@angular/material/core';
import { MatDateFnsModule } from '@angular/material-date-fns-adapter';
import { es } from 'date-fns/locale';

import { FormService } from '@fwk/services/dynamic-form/form.service';
import { AbstractComponent } from '../abstract-component.component';
import { DynamicField, CONTROL_TYPE } from '../../model/dynamic-form/dynamic-field';
import { MY_FORMATS } from '@fwk/services/dynamic-form/form.validator.service';
import { AutocompleteService } from '../autocomplete/autocomplete.service';
import { ApiAutocompleteConfiguration } from '../autocomplete/autocomplete.interface';
import { ColorPickerConfiguration } from '../color-picker/color-picker.interface';
import { ColorPickerOptions, SelectOptions } from '../../model/dynamic-form/dynamic-field-options.interface';
import { MatIconModule } from '@angular/material/icon';
import { FileComponent } from './file/file.component';
import { DisclaimerComponent } from './disclaimer/disclaimer.component';
import { FloatComponent } from './float/float.component';
import { PickListComponent } from '../pick-list/pick-list.component';
import { SimplePickListComponent } from '../simple-pick-list/simple-pick-list.component';
import { AutocompleteComponent } from '../autocomplete/autocomplete.component';
import { AutocompleteDesplegableComponent } from '../autocomplete-desplegable/autocomplete-desplegable.component';
import { ColorPickerComponent } from '../color-picker/color-picker.component';
import { TagsComponent } from '../tags/tags.component';
import { UrlInputComponent } from '../url-input/url-input.component';
import { A11yModule } from '@angular/cdk/a11y';
import { IconPickerComponent } from '../icon-picker/icon-picker.component';
import { CustomDatePickerComponent } from './custom-datepicker/custom-datepicker.component';
import { EditorModule } from '@tinymce/tinymce-angular';

@Component({
    selector: 'fwk-dynamic-form-component',
    templateUrl: './dynamic-form.component.html',
    styleUrls: ['./dynamic-form.component.scss'],
    standalone: true,
    imports: [
        CommonModule,
        FormsModule,
        ReactiveFormsModule,
        A11yModule,
        MatFormFieldModule,
        MatInputModule,
        MatSelectModule,
        MatCheckboxModule,
        MatRadioModule,
        MatChipsModule,
        MatIconModule,
        MatDateFnsModule,
        FileComponent,
        DisclaimerComponent,
        CustomDatePickerComponent,
        FloatComponent,
        PickListComponent,
        SimplePickListComponent,
        AutocompleteComponent,
        AutocompleteDesplegableComponent,
        ColorPickerComponent,
        TagsComponent,
        UrlInputComponent,
        IconPickerComponent,
        EditorModule
    ],
    providers: [
        { provide: MAT_DATE_LOCALE, useValue: es },
        { provide: MAT_DATE_FORMATS, useValue: MY_FORMATS },
    ],
    changeDetection: ChangeDetectionStrategy.OnPush,
})
export class DynamicFormComponent extends AbstractComponent implements OnInit, OnDestroy {
    @Input() fields: DynamicField<any>[] = [];
    @Input() parentForm!: FormGroup;
    @Input() entity: any = {};
    @Input() isEdit: boolean = false;
    @Input() handlerFieldSourceData?: (key: string, entity: any, injector: Injector) => Observable<any>;

    @Input() subFormName: string = DynamicFormComponent.subFormName;

    @Output() onChangeEntity = new EventEmitter<any>();
    @Output() objectModified = new EventEmitter<boolean>();
    @Output() onFieldsChanges = new EventEmitter<any>();

    @ViewChild('formDirective') private formDirective?: NgForm;

    form!: FormGroup;
    firstFocusableFieldIndex: number = -1;

    public static readonly subFormName = 'subForm';

    private initStateObject: any = {};
    private formValueChangesSub?: Subscription;
    private formService: FormService;
    private autocompleteService: AutocompleteService;
    private fieldSubscriptions: Subscription[] = [];

    constructor(
        public injector: Injector,
        private cdRef: ChangeDetectorRef
    ) {
        super(injector);
        this.formService = injector.get(FormService);
        this.autocompleteService = injector.get(AutocompleteService);
    }

    override ngOnInit(): void {
        super.ngOnInit();
        if (!this.parentForm) {
            console.error("[FWK] DynamicFormComponent requiere un [parentForm] de tipo FormGroup.");
            this.parentForm = new FormGroup({});
        }
        this.initializeForm();
    }

    override ngOnDestroy(): void {
        super.ngOnDestroy();
        this.formValueChangesSub?.unsubscribe();
        if (this.parentForm?.get(this.subFormName)) {
            this.parentForm.removeControl(this.subFormName);
        }
    }

    private initializeForm(): void {
        if (this.parentForm.get(this.subFormName)) {
            this.parentForm.removeControl(this.subFormName);
        }

        this.fields.forEach(field => {
            if (field.controlType === 'datetimepicker') {
                field.options = { ...field.options, withHourAndMin: true };
            }
        });

        this.form = this.formService.toFormGroupEntity(this.entity, this.fields, { disabled: !this.isEdit }, this.onFieldsChanges);
        this.parentForm.addControl(this.subFormName, this.form);

        this.formValueChangesSub = this.form.valueChanges
            .pipe(
                debounceTime(300),
                distinctUntilChanged()
            )
            .subscribe(() => {
                this.checkObjectModified();
            });

        this.updateInitialState();

        this.loadInitialSourceData();

        const focusableControlTypes = [
            CONTROL_TYPE.Textbox, CONTROL_TYPE.Textarea, CONTROL_TYPE.Number,
            CONTROL_TYPE.Password, CONTROL_TYPE.Email, CONTROL_TYPE.Select,
            CONTROL_TYPE.Datepicker, CONTROL_TYPE.Datetimepicker, CONTROL_TYPE.Autocomplete,
            CONTROL_TYPE.AutocompleteDesplegable, CONTROL_TYPE.Float, CONTROL_TYPE.ColorPicker,
            CONTROL_TYPE.Tags, CONTROL_TYPE.UrlInput, CONTROL_TYPE.File
        ];

        this.firstFocusableFieldIndex = this.fields.findIndex(
            field => focusableControlTypes.includes(field.controlType as CONTROL_TYPE) && !field.disabled
        );

        this.cdRef.detectChanges();
    }

    private loadInitialSourceData(): void {
        this.fields.forEach((field) => {
            if (field.options?.handlerSourceData && this.handlerFieldSourceData) {
                this.handlerFieldSourceData(field.key, this.entity, this.injector).subscribe(data => {
                    if (field.controlType === CONTROL_TYPE.Hidden) {
                        this.form.get(field.key)?.setValue(data);
                    } else if (field.options) {
                        (field.options as SelectOptions).fromData = data;
                    }
                    this.cdRef.markForCheck();
                });
            }
        });
    }

    public updateInitialState(): void {
        this.initStateObject = this.form.getRawValue();
        this.checkObjectModified();
    }

    public resetForm(entity: any): void {
        this.entity = entity;
        this.form.patchValue(entity);
        this.updateInitialState();
    }

    public searchTermInterface(field: ApiAutocompleteConfiguration) {
        return {
            search: (term: string) => this.autocompleteService.autocompleteSearch(this.form, field, term)
        };
    }

    getMessageErrorValidation(field: DynamicField<any>): string {
        return this.formService.getMessageErrorValidation(this.form, field);
    }

    onFormValuesChanged(): void {
        this.checkObjectModified();
    }

    private checkObjectModified(): void {
        const currentValues = this.form.getRawValue();
        const isModified = JSON.stringify(this.initStateObject) !== JSON.stringify(currentValues);
        this.objectModified.emit(isModified);
    }

    getRestrictionKeys(field: DynamicField<any>): string {
        return field.options?.restrictionKeys || (field.controlType === CONTROL_TYPE.Number ? '[0-9]' : '');
    }

    getFloatLabel(field: DynamicField<any>): 'auto' | 'always' | 'never' {
        return field.options?.['floatLabel'] ?? 'auto';
    }

    onChangeSelect(event: any): void {
        // 
    }

    getOptionsWidth(options: any[]): string {
        return (!options || options.length === 0) ? '100%' : `${Math.floor(100 / options.length) - 3}%`;
    }

    public getColorPickerConfig(field: DynamicField<any>): ColorPickerConfiguration {
        return {
            key: field.key,
            label: field.label,
            required: field.required,
            disabled: field.disabled,
            value: field.value,
            options: field.options as ColorPickerOptions
        };
    }
}

--- FILE: @fwk/components/dynamic-form/file/file.component.html ---

﻿<div class="w-full flex flex-col gap-2">
    <label *ngIf="field?.label" class="block text-sm font-medium text-secondary">
        {{ field.label }} <span *ngIf="field.required" class="text-red-500">*</span>
    </label>

    <input type="file" #fileInput [accept]="acceptTypes" (change)="onFileChange($event)" class="hidden" [disabled]="isDisabled">

    <div class="relative group w-full min-h-[90px] rounded-xl border-2 border-dashed transition-all duration-200 ease-in-out cursor-pointer overflow-hidden"
         [ngClass]="{
            'border-primary-500 bg-primary-50/50 dark:bg-primary-900/20': isDragging,
            'border-gray-300 dark:border-gray-600 hover:border-primary-400 hover:bg-gray-50 dark:hover:bg-gray-800': !isDragging && !hasError && !fileName && !errorMessage,
            'border-red-500 bg-red-50 dark:bg-red-900/10': hasError || errorMessage,
            'border-solid border-gray-200 dark:border-gray-700 bg-card': fileName && !hasError && !errorMessage,
            'opacity-60 cursor-not-allowed': isDisabled
         }"
         (click)="triggerFileInput()">

        <div *ngIf="isLoading" class="absolute inset-0 z-20 flex flex-col items-center justify-center bg-white/90 dark:bg-gray-900/90 backdrop-blur-sm p-6">
            <mat-progress-bar mode="indeterminate" class="w-full max-w-[200px] rounded-full"></mat-progress-bar>
            <span class="mt-3 text-xs font-bold text-primary-600 uppercase tracking-wider">Procesando imagen...</span>
        </div>

        <div *ngIf="!fileName && !isLoading" class="flex flex-col items-center justify-center py-6 px-4 text-center h-full">
            <div class="text-primary-600 group-hover:scale-110 transition-transform">
                <mat-icon class="icon-size-6" svgIcon="heroicons_outline:cloud-arrow-up"></mat-icon>
            </div>
            <div class="text-sm font-medium text-gray-600 dark:text-gray-300">
                <span class="text-primary-600 font-semibold hover:underline">Sube un archivo</span> o arrástralo aquí
            </div>
            <p class="text-xs text-gray-400 mt-1" *ngIf="acceptTypes">
                {{ acceptTypes.replace(',', ', ') | uppercase }}
            </p>
        </div>

        <div *ngIf="fileName && !isLoading" class="flex items-center p-4 h-full">
            <div class="flex-none flex items-center justify-center w-12 h-12 rounded-lg"
                 [ngClass]="(hasError || errorMessage) ? 'bg-red-100 text-red-600' : 'bg-green-100 text-green-600 dark:bg-green-900/30'">
                <mat-icon class="icon-size-6" [svgIcon]="(hasError || errorMessage) ? 'heroicons_outline:exclamation-circle' : 'heroicons_outline:document-check'"></mat-icon>
            </div>

            <div class="flex-auto ml-4 min-w-0">
                <div class="text-sm font-semibold truncate" [ngClass]="(hasError || errorMessage) ? 'text-red-600' : 'text-gray-800 dark:text-gray-100'">
                    {{ fileName }}
                </div>
                <div class="text-xs text-gray-500 flex items-center gap-2 mt-0.5" *ngIf="!hasError && fileSize">
                    <span>{{ fileSize }}</span>
                    <span class="w-1 h-1 rounded-full bg-gray-300"></span>
                    <span class="text-green-600 font-medium">Listo</span>
                </div>
                <div class="text-xs text-red-500 font-medium mt-0.5" *ngIf="hasError">
                    Error en el archivo
                </div>
            </div>

            <button *ngIf="!isDisabled" mat-icon-button type="button" color="warn" (click)="removeFile($event)" matTooltip="Quitar archivo">
                <mat-icon class="icon-size-5" svgIcon="heroicons_outline:trash"></mat-icon>
            </button>
        </div>
    </div>

    <div *ngIf="errorMessage" class="text-xs text-red-500 ml-1">
        {{ errorMessage }}
    </div>
</div>

--- FILE: @fwk/components/dynamic-form/file/file.component.ts ---

﻿import { Component, Input, forwardRef, ElementRef, ViewChild, ChangeDetectorRef, Optional, Host, SkipSelf, HostListener } from '@angular/core';
import { CommonModule } from '@angular/common';
import { ControlValueAccessor, NG_VALUE_ACCESSOR, Validator, AbstractControl, ValidationErrors, NG_VALIDATORS, FormsModule, ControlContainer, FormGroup } from '@angular/forms';
import { MatButtonModule } from '@angular/material/button';
import { MatIconModule } from '@angular/material/icon';
import { MatTooltipModule } from '@angular/material/tooltip';
import { MatProgressBarModule } from '@angular/material/progress-bar';
import { TranslatePipe } from '../../../pipe/translate.pipe';

@Component({
     selector: 'fwk-file',
    templateUrl: './file.component.html',
    styleUrls: ['./file.component.scss'],
    standalone: true,
    imports: [
        CommonModule,
        FormsModule,
        MatButtonModule,
        MatIconModule,
        MatTooltipModule,
        MatProgressBarModule,
        TranslatePipe
    ],
    providers: [
        {
            provide: NG_VALUE_ACCESSOR,
            useExisting: forwardRef(() => FileComponent),
            multi: true
        },
        {
            provide: NG_VALIDATORS,
            useExisting: forwardRef(() => FileComponent),
            multi: true
        }
    ],
    viewProviders: [
        {
            provide: ControlContainer,
            useFactory: (container: ControlContainer) => container,
            deps: [[new Optional(), new SkipSelf(), ControlContainer]]
        }
    ]
})
export class FileComponent implements ControlValueAccessor, Validator {

    @Input() field!: any;
    @Input() errorMessage: string | null = null; 
    
    @ViewChild('fileInput') fileInput!: ElementRef<HTMLInputElement>;

    fileName: string | null = null;
    fileSize: string | null = null;
    
    isDisabled: boolean = false;
    isDragging: boolean = false;
    isLoading: boolean = false;
    hasError: boolean = false;

    onChange: (value: any) => void = () => {};
    onTouch: () => void = () => {};
    onValidatorChange: () => void = () => {};

    constructor(
        private cdr: ChangeDetectorRef,
        @Optional() @Host() @SkipSelf() private controlContainer: ControlContainer
    ) {}

    @HostListener('dragover', ['$event']) onDragOver(evt: any) {
        evt.preventDefault();
        evt.stopPropagation();
        if (!this.isDisabled) this.isDragging = true;
    }

    @HostListener('dragleave', ['$event']) onDragLeave(evt: any) {
        evt.preventDefault();
        evt.stopPropagation();
        this.isDragging = false;
    }

    @HostListener('drop', ['$event']) onDrop(evt: any) {
        evt.preventDefault();
        evt.stopPropagation();
        this.isDragging = false;
        if (this.isDisabled) return;

        const files = evt.dataTransfer.files;
        if (files.length > 0) {
            this.processFile(files[0]);
        }
    }

    writeValue(value: any): void {
        if (!value) {
            this.clearState();
        } else {
            this.fileName = "Archivo actual en memoria";
            this.fileSize = null;
        }
        this.cdr.markForCheck();
    }

    registerOnChange(fn: any): void { this.onChange = fn; }
    registerOnTouched(fn: any): void { this.onTouch = fn; }
    
    setDisabledState(isDisabled: boolean): void { 
        this.isDisabled = isDisabled;
        this.cdr.markForCheck();
    }

    validate(control: AbstractControl): ValidationErrors | null {
        if (this.field?.required && !control.value) { 
            return { required: true }; 
        }
        if (this.hasError) {
            return { invalidFile: true };
        }
        return null;
    }

    onFileChange(event: Event): void {
        const input = event.target as HTMLInputElement;
        if (input.files && input.files.length > 0) {
            this.processFile(input.files[0]);
        }
    }

    processFile(file: File): void {
        if (this.acceptTypes && !this.checkFileType(file)) {
            this.handleError('Tipo de archivo no permitido. Solo ' + this.acceptTypes);
            return;
        }

        this.isLoading = true;
        this.hasError = false;
        this.fileName = file.name;
        this.fileSize = this.formatBytes(file.size);
        
        const reader = new FileReader();
        
        reader.onload = () => {
            const base64Result = reader.result as string;
            
            const rawBase64 = base64Result.split(',')[1];

            const byteArray = this.base64ToByteArray(rawBase64);
            this.onChange(byteArray); 

            this.updatePreview(rawBase64);
            
            this.isLoading = false;
            this.cdr.markForCheck();
        };

        reader.onerror = () => {
            this.isLoading = false;
            this.handleError('Error al leer el archivo');
        };

        reader.readAsDataURL(file);
        this.onTouch();
    }

    private base64ToByteArray(base64: string): number[] {
        const binaryString = window.atob(base64);
        const len = binaryString.length;
        const bytes = new Array(len);
        for (let i = 0; i < len; i++) {
            bytes[i] = binaryString.charCodeAt(i);
        }
        return bytes;
    }

    private updatePreview(value: string | null): void {
        const previewFieldName = this.field?.options?.['previewField'];
        
        if (previewFieldName && this.controlContainer && this.controlContainer.control) {
            const formGroup = this.controlContainer.control as FormGroup;
            const previewControl = formGroup.get(previewFieldName);
            
            if (previewControl) {
                previewControl.setValue(value);
                previewControl.markAsDirty();
            }
        }
    }

    private checkFileType(file: File): boolean {
        if (!this.acceptTypes) return true;
        const accepted = this.acceptTypes.split(',').map(t => t.trim().toLowerCase());
        const ext = '.' + file.name.split('.').pop()?.toLowerCase();
        const type = file.type.toLowerCase();
        return accepted.some(acc => acc === ext || type.match(new RegExp(acc.replace('*', '.*'))));
    }

    removeFile(event: Event): void {
        event.stopPropagation();
        this.clearState();
        this.onChange(null);
        this.updatePreview(null);
        this.onTouch();
        if (this.fileInput) this.fileInput.nativeElement.value = '';
    }

    private clearState(): void {
        this.fileName = null;
        this.fileSize = null;
        this.hasError = false;
        this.isLoading = false;
        this.cdr.markForCheck();
    }

    private handleError(msg: string): void {
        this.hasError = true;
        this.fileName = msg;
        this.fileSize = null;
        this.onChange(null);
        this.cdr.markForCheck();
    }

    triggerFileInput(): void {
        if (!this.isDisabled) {
            this.fileInput.nativeElement.click();
        }
    }

    private formatBytes(bytes: number, decimals = 2): string {
        if (bytes === 0) return '0 Bytes';
        const k = 1024;
        const dm = decimals < 0 ? 0 : decimals;
        const sizes = ['Bytes', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
    }

    get acceptTypes(): string {
        return this.field?.options?.acceptTypes ?? '';
    }
}

--- FILE: @fwk/components/dynamic-form/float/float.component.html ---

﻿<mat-form-field
    *ngIf="field"
    [floatLabel]="getFloatLabel()"
    appearance="outline"
    class="w-full">

    <mat-label *ngIf="!field.options?.matLabel">{{ field.label }}</mat-label>
    <mat-label *ngIf="field.options?.matLabel">{{ field.options.matLabel }}</mat-label>

    <input
        matInput
        [placeholder]="field.label"
        [ngModel]="_value"
        [ngModelOptions]="{standalone: true}"
        (ngModelChange)="onValueChange($event)"
        (blur)="onBlur()"
        [disabled]="isDisabled"
        [required]="field.required"
        [restrictionKeys]="restrictionKeys"
        [errorStateMatcher]="matcher">

    <span *ngIf="field.options?.prefix" matPrefix>{{ field.options.prefix }}&nbsp;</span>

    <mat-error *ngIf="errorMessage">{{ errorMessage }}</mat-error>

</mat-form-field>

--- FILE: @fwk/components/dynamic-form/float/float.component.ts ---

﻿import { Component, OnInit, forwardRef, ChangeDetectorRef, Input } from '@angular/core';
import { CommonModule } from '@angular/common';
import { NG_VALUE_ACCESSOR, NG_VALIDATORS, Validator, AbstractControl, ValidationErrors, FormsModule, FormControl, FormGroupDirective, NgForm } from '@angular/forms';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatInputModule } from '@angular/material/input';
import { ErrorStateMatcher } from '@angular/material/core';
import { DynamicFieldFormComponent } from '../dynamic-field-form/dynamic-field-form.component';
import { RestrictionKeysDirective } from '../../../directive/restriction-keys.directive';
import { FloatOptions } from '../../../model/dynamic-form/dynamic-field-options.interface';

@Component({
   selector: 'fwk-float',
  templateUrl: './float.component.html',
  styleUrls: ['./float.component.scss'],
  standalone: true,
  imports: [
    CommonModule,
    FormsModule,
    MatFormFieldModule,
    MatInputModule,
    RestrictionKeysDirective
  ],
  providers: [
    {
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => FloatComponent),
      multi: true
    },
    {
      provide: NG_VALIDATORS,
      useExisting: forwardRef(() => FloatComponent),
      multi: true
    }
  ]
})
export class FloatComponent extends DynamicFieldFormComponent<string> implements Validator, OnInit {

  @Input() errorMessage: string | null = null; 

  matcher = new class implements ErrorStateMatcher {
    constructor(private component: FloatComponent) { }
    isErrorState(control: FormControl | null, form: FormGroupDirective | NgForm | null): boolean {
      return !!(this.component.errorMessage || (control?.invalid && (control?.dirty || control?.touched)));
    }
  }(this);

  private decimalMaxLength: number = 2;
  private delim: string = ',';
  onValidatorChange: () => void = () => { };

  private get floatOptions(): FloatOptions {
    return this.field?.options as FloatOptions;
  }

  constructor(private cdr: ChangeDetectorRef) {
      super();
  }

  ngOnInit(): void {
    const options = this.floatOptions;
    if (options) {
      this.delim = options.delim ?? ',';
      this.decimalMaxLength = options.decimalMaxLength ?? 2;
    }
  }

  override writeValue(value: string | null): void {
    this._value = value;
    this.cdr.markForCheck();
  }

  override setDisabledState(isDisabled: boolean): void {
    this.isDisabled = isDisabled;
    this.cdr.markForCheck();
  }

  validate(control: AbstractControl): ValidationErrors | null {
    const value = control.value;
    if (this.field?.required && !value) {
      return { required: true };
    }

    if (value && typeof value === 'string') {
      const parts = value.split(this.delim);
      if (value.includes(this.delim)) {
        if (parts.length > 2 || parts.some(p => p.length === 0)) {
          return { floatFormat: `El formato decimal es incorrecto.` };
        }
        const decimalPart = parts[1];
        if (decimalPart.length > this.decimalMaxLength) {
          return { floatDecimalLength: `Debe contener un máximo de ${this.decimalMaxLength} decimales.` };
        }
      }
    }
    return null;
  }

  registerOnValidatorChange(fn: () => void): void {
    this.onValidatorChange = fn;
  }

  onInput(event: Event): void {
    const value = (event.target as HTMLInputElement).value;
    this.onValueChange(value);
  }

  onValueChange(newValue: string): void {
    const valueToEmit = newValue || null;
    if (this._value !== valueToEmit) {
      this._value = valueToEmit;
      this.onChange(valueToEmit);
    }
  }

  onBlur(): void {
    this.onTouch();
  }
}

--- FILE: @fwk/components/dynamic-url/dynamic-url.component.html ---

<a *ngIf="fullURL"
   [href]="fullURL"
   target="_blank"
   mat-icon-button
   [matTooltip]="'Ir a ' + fullURL">
    <mat-icon [svgIcon]="'heroicons_outline:link'"></mat-icon>
</a>

--- FILE: @fwk/components/dynamic-url/dynamic-url.component.ts ---

﻿import { Component, OnInit, OnDestroy, ChangeDetectionStrategy, ChangeDetectorRef } from '@angular/core';
import { CommonModule } from '@angular/common';
import { ActivatedRoute } from '@angular/router';
import { Subscription } from 'rxjs';
import { environment } from 'environments/environment';

import { MatButtonModule } from '@angular/material/button';
import { MatIconModule } from '@angular/material/icon';
import { MatTooltipModule } from '@angular/material/tooltip';

@Component({
    selector: 'dynamic-url',
    templateUrl: './dynamic-url.component.html',
    styleUrls: ['./dynamic-url.component.scss'],
    standalone: true,
    imports: [
        CommonModule,
        MatButtonModule,
        MatIconModule,
        MatTooltipModule
    ],
    changeDetection: ChangeDetectionStrategy.OnPush,
})
export class DynamicUrlComponent implements OnInit, OnDestroy {

    fullURL: string | null = null;
    private queryParamsSub?: Subscription;

    constructor(
        private activatedRoute: ActivatedRoute,
        private _cdr: ChangeDetectorRef,
    ) {}

    ngOnInit(): void {
        this.queryParamsSub = this.activatedRoute.queryParams.subscribe(params => {
            if (params && params['seName']) {
                try {
                    const decodedSeName = decodeURIComponent(params['seName']);
                    this.fullURL = environment.SITE_DOMAIN_WEB + decodedSeName;
                } catch (e) {
                    console.error('Error decoding seName parameter:', e);
                    this.fullURL = null;
                }
            } else {
                this.fullURL = null;
            }
            this._cdr.markForCheck();
        });
    }

    ngOnDestroy(): void {
        this.queryParamsSub?.unsubscribe();
    }
}

--- FILE: @fwk/components/form-grid-dialog/form-grid.dialog.component.html ---

﻿<div class="{{ data.dialog?.modalKey }}-modal {{ getUrl() }}-modal">
    <div class="clear-div">
        <button (click)="onNoClick()" mat-icon-button class="mat-icon-button_">
            <mat-icon aria-label="clear">clear</mat-icon>
        </button>
    </div>

    <h1 mat-dialog-title *ngIf="titleLabel">{{ titleLabel }}</h1>

    <div mat-dialog-content class='basic-modal-content' *ngIf="data.dialog?.form?.fields">
      <fwk-dynamic-form-component 
            [entity]="entity"    
            [isEdit]="isEdit"
            [fields]="data.dialog.form.fields"
            [subFormName]="formKey"
            [parentForm]="form"
            (objectModified)="objectModified($event)"
            (onChangeEntity)="onChangeEntity($event)">
      </fwk-dynamic-form-component>
      
      <div *ngFor="let grid of data.dialog?.grids" class="styleBox_dialog-grids">
        <h2 *ngIf="grid.title" class="styleText_gird-title">{{ grid.title }}</h2>
        <fwk-crud-table 
              [datasource]="getDataSource(grid, entity)" 
              [grid]="grid">
        </fwk-crud-table>
      </div>
    </div>

    <div mat-dialog-actions>
      <div *ngIf="data.dialog" class="custom-actions">
        <button mat-button *ngFor="let action of data.dialog.actions" (click)="submitAction(action)" class="modal-component_button-a">
          {{ action.actionName }}
        </button>
        <button mat-button 
                *ngIf="isAdd || isEdit" 
                type="submit" 
                (click)="onSubmit()" 
                [disabled]="!isObjectModified || form.invalid || submitting" 
                cdkFocusInitial>
                {{ submitLabel }}
        </button>
      </div>
    </div>
</div>

--- FILE: @fwk/components/form-grid-dialog/form-grid.dialog.component.ts ---

﻿import { Component, Inject, OnInit, ChangeDetectionStrategy, forwardRef, inject } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormGroup, ReactiveFormsModule } from '@angular/forms';
import { MatDialogRef, MAT_DIALOG_DATA, MatDialogModule } from '@angular/material/dialog';
import { MatTableDataSource } from '@angular/material/table';
import { ActivatedRoute } from '@angular/router';
import { MatButtonModule } from '@angular/material/button';
import { MatIconModule } from '@angular/material/icon';
import { MatTooltipModule } from '@angular/material/tooltip';

import { Entity } from '../../model/entity';
import { GridDef } from '../../model/component-def/grid-def';
import { ActionDef } from '../../model/component-def/action-def';
import { ActionDefService } from '../../services/action-def-service/action-def.service';
import { DynamicField } from '../../model/dynamic-form/dynamic-field';
import { I18n } from '../../model/i18n';
import { I18nService } from '@fwk/services/i18n-service/i18n.service';

import { DynamicFormComponent } from '../dynamic-form/dynamic-form.component';
import { CrudTableComponent } from '../crud/crud-table/crud-table.component';

interface FormGridDialogData {
    entity?: Entity;
    isEdit?: boolean;
    dialog: {
        modalKey?: string;
        modalName?: string;
        form?: {
            fields: DynamicField<any>[];
        };
        grids?: GridDef[];
        actions?: ActionDef[];
    };
    i18n: I18n;
    onSubmitActions?: (action: ActionDef, entity: Entity) => void;
}

@Component({
     selector: 'fwk-form-grid-modal-component',
    templateUrl: './form-grid.dialog.component.html',
    styleUrls: ['./form-grid.dialog.component.scss'],
    standalone: true,
    imports: [
        CommonModule,
        ReactiveFormsModule,
        MatDialogModule,
        MatButtonModule,
        MatIconModule,
        MatTooltipModule,
        DynamicFormComponent,
        forwardRef(() => CrudTableComponent),
    ],
    changeDetection: ChangeDetectionStrategy.OnPush,
})
export class FormGridModalComponent implements OnInit {

    entity: Entity;
    form: FormGroup;
    isEdit: boolean;

    formKey: string = 'subForm';
    isAdd: boolean = false;
    submitLabel: string;
    isObjectModified: boolean = false;
    submitting: boolean = false;

    private i18nService = inject(I18nService);

    constructor(
        public dialogRef: MatDialogRef<FormGridModalComponent>,
        @Inject(MAT_DIALOG_DATA) public data: FormGridDialogData,
        private activatedRoute: ActivatedRoute,
        private actionDefService: ActionDefService,
    ) {
        this.dialogRef.disableClose = true;
        this.isEdit = this.data.isEdit ?? false;
        this.entity = this.data.entity ?? new Entity();
        this.form = new FormGroup({});
        this.submitLabel = this.translate('modal_button_save');
    }

    ngOnInit(): void { }

    private translate(key: string): string {
        return this.i18nService.getDictionary('fwk')?.translate?.(key) || key;
    }

    getDataSource(grid: GridDef, entity: Entity | undefined): MatTableDataSource<any> {
        const dataArray = (grid.fromArrayField && entity) ? (entity as any)[grid.fromArrayField] : [];
        return new MatTableDataSource<any>(Array.isArray(dataArray) ? dataArray : []);
    }

    onNoClick(): void {
        this.dialogRef.close();
    }

    getUrl(): string {
        return this.activatedRoute.snapshot.firstChild?.routeConfig?.path ?? '';
    }

    submitAction(action: ActionDef): void {
        if (this.data.onSubmitActions) {
            this.data.onSubmitActions(action, this.entity);
        } else {
            this.actionDefService.submitAction(action, this.entity, this.data.i18n, undefined).subscribe();
        }
    }

    get titleLabel(): string {
        return this.data.dialog?.modalName ?? this.translate('grid_modal_default_title');
    }

    objectModified(event: any): void {
        this.isObjectModified = true;
    }

    onChangeEntity(event: any): void {
        this.entity = event;
    }

    onSubmit(): void {
        if (this.form.invalid) {
            return;
        }
        this.dialogRef.close(this.entity);
    }
}

--- FILE: @fwk/components/grid-modal/grid-modal.component.html ---

﻿<div class="flex flex-col max-h-screen">

    <div class="flex flex-0 items-center justify-between pl-6 pr-4 h-16 border-b">
        <h2 class="text-2xl font-semibold">{{ data.title || ('grid_modal_default_title' | translate) }}</h2>
        <button
            mat-icon-button
            (click)="onNoClick()"
            [matTooltip]="'modal_button_close' | translate">
            <mat-icon [svgIcon]="'heroicons_outline:x-mark'"></mat-icon>
        </button>
    </div>

    <div mat-dialog-content class="flex-auto overflow-y-auto p-6">
        <div class="relative overflow-hidden rounded-2xl shadow bg-card">
            <fwk-crud-table
                *ngIf="dataSource"
                [datasource]="dataSource"
                [grid]="data.gridDef">
            </fwk-crud-table>
        </div>
    </div>

    <div mat-dialog-actions class="flex items-center justify-end p-6 border-t">
        <button
            mat-flat-button
            color="accent"
            (click)="onNoClick()">
            {{ 'modal_button_close' | translate }}
        </button>
    </div>

</div>

--- FILE: @fwk/components/grid-modal/grid-modal.component.ts ---

﻿import { Component, Inject, OnInit, ChangeDetectionStrategy } from '@angular/core';
import { CommonModule } from '@angular/common';
import { MatDialogRef, MAT_DIALOG_DATA, MatDialogModule } from '@angular/material/dialog';
import { MatTableDataSource } from '@angular/material/table';
import { MatButtonModule } from '@angular/material/button';
import { MatIconModule } from '@angular/material/icon';
import { MatTooltipModule } from '@angular/material/tooltip';

import { GridDef } from '../../model/component-def/grid-def';
import { CrudTableComponent } from '../crud/crud-table/crud-table.component';
import { TranslatePipe } from '../../pipe/translate.pipe'; 

export interface GridModalData {
    title?: string;
    entities: any[];
    gridDef: GridDef;
}

@Component({
     selector: 'fwk-grid-modal-component',
    templateUrl: './grid-modal.component.html',
    styleUrls: ['./grid-modal.component.scss'],
    standalone: true,
    imports: [
        CommonModule,
        MatDialogModule,
        MatButtonModule,
        MatIconModule,
        MatTooltipModule,
        CrudTableComponent,
        TranslatePipe
    ],
    changeDetection: ChangeDetectionStrategy.OnPush,
})
export class GridModalComponent implements OnInit {

    dataSource: MatTableDataSource<any>;

    constructor(
        public dialogRef: MatDialogRef<GridModalComponent>,
        @Inject(MAT_DIALOG_DATA) public data: GridModalData
    ) {
        this.dataSource = new MatTableDataSource<any>();
    }

    ngOnInit(): void {
        if (this.data && Array.isArray(this.data.entities)) {
            this.dataSource = new MatTableDataSource<any>(this.data.entities);
        }
    }

    onNoClick(): void {
        this.dialogRef.close();
    }
}

--- FILE: @fwk/components/icon-picker/icon-picker.component.html ---

<mat-form-field class="w-full" appearance="outline" subscriptSizing="dynamic">
    <mat-label>{{ label }}</mat-label>
    
    <mat-select [value]="_value" (selectionChange)="onSelectionChange($event.value)" [disabled]="isDisabled" [errorStateMatcher]="matcher">
        
        <mat-select-trigger *ngIf="_value">
            <div class="flex items-center gap-2">
                <mat-icon [svgIcon]="namespace + ':' + _value"></mat-icon>
                <span class="font-mono text-sm">{{ _value }}</span>
            </div>
        </mat-select-trigger>

        <div class="px-3 pt-2 sticky top-0 bg-white dark:bg-gray-700 z-10">
            <input matInput #searchInput [formControl]="searchControl" [placeholder]="'icon_picker_search_placeholder' | translate" class="w-full" (keydown)="$event.stopPropagation()">
        </div>

        <mat-option [value]="null">
            <div class="flex items-center gap-2 h-full">
                <mat-icon class="text-secondary" svgIcon="heroicons_outline:x-circle"></mat-icon>
                {{ 'icon_picker_none_option' | translate }}
            </div>
        </mat-option>
        
        <mat-option *ngFor="let icon of filteredIcons$ | async" [value]="icon">
            <div class="flex items-center gap-2 h-full">
                <mat-icon [svgIcon]="namespace + ':' + icon"></mat-icon>
                <span class="font-mono text-sm">{{ icon }}</span>
            </div>
        </mat-option>

    </mat-select>

    <button *ngIf="_value && showClearButton && !isDisabled"
        mat-icon-button
        matSuffix
        (click)="clearSelection($event)"
        [matTooltip]="'icon_picker_clear_tooltip' | translate">
        <mat-icon svgIcon="heroicons_outline:x-mark"></mat-icon>
    </button>

    <mat-error *ngIf="errorMessage">{{ errorMessage }}</mat-error>
</mat-form-field>

--- FILE: @fwk/components/icon-picker/icon-picker.component.ts ---

import { Component, ChangeDetectionStrategy, Input, forwardRef, OnInit, inject, ChangeDetectorRef } from '@angular/core';
import { CommonModule } from '@angular/common';
import { ControlValueAccessor, FormControl, FormGroupDirective, NG_VALUE_ACCESSOR, NgForm, ReactiveFormsModule } from '@angular/forms';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatSelectModule } from '@angular/material/select';
import { MatIconModule } from '@angular/material/icon';
import { MatInputModule } from '@angular/material/input';
import { MatButtonModule } from '@angular/material/button';
import { MatTooltipModule } from '@angular/material/tooltip';
import { Observable, combineLatest, map, startWith } from 'rxjs';
import { IconListService } from '@fwk/services/icon-list/icon-list.service';
import { TranslatePipe } from '@fwk/pipe/translate.pipe';
import { ErrorStateMatcher } from '@angular/material/core';

@Component({
    selector: 'fwk-icon-picker',
    standalone: true,
    imports: [CommonModule, ReactiveFormsModule, MatFormFieldModule, MatSelectModule, MatIconModule, MatInputModule, MatButtonModule, MatTooltipModule, TranslatePipe],
    templateUrl: './icon-picker.component.html',
    providers: [
        {
            provide: NG_VALUE_ACCESSOR,
            useExisting: forwardRef(() => IconPickerComponent),
            multi: true,
        },
    ],
    changeDetection: ChangeDetectionStrategy.OnPush,
})
export class IconPickerComponent implements ControlValueAccessor, OnInit {
    @Input() label: string = 'Icono';
    @Input() namespace: string = 'heroicons_outline';
    @Input() showClearButton: boolean = true;
    @Input() errorMessage: string | null = null;

    private _iconListService = inject(IconListService);
    private _cdr = inject(ChangeDetectorRef);

    _value: string | null = null;
    isDisabled = false;

    allIcons$: Observable<string[]>;
    filteredIcons$: Observable<string[]>;
    searchControl = new FormControl('');

    matcher = new class implements ErrorStateMatcher {
        constructor(private component: IconPickerComponent) { }
        isErrorState(control: FormControl | null, form: FormGroupDirective | NgForm | null): boolean {
            return !!(this.component.errorMessage || (control?.invalid && (control?.dirty || control?.touched)));
        }
    }(this);

    onChange: (value: string | null) => void = () => { };
    onTouched: () => void = () => { };

    ngOnInit(): void {
        this.allIcons$ = this._iconListService.getIconNames(this.namespace);
        this.filteredIcons$ = combineLatest([
            this.allIcons$,
            this.searchControl.valueChanges.pipe(startWith('')),
        ]).pipe(
            map(([icons, searchTerm]) => {
                if (!searchTerm) {
                    return icons;
                }
                return icons.filter(icon => icon.toLowerCase().includes(searchTerm.toLowerCase()));
            })
        );
    }

    writeValue(value: string | null): void {
        let cleanValue = value;
        const wasCorrected = value && value.startsWith(`${this.namespace}:`);

        if (wasCorrected) {
            cleanValue = value.split(':')[1];
        }

        this._value = cleanValue;

        if (wasCorrected) {
            this.onChange(cleanValue);
        }

        this._cdr.markForCheck();
    }

    registerOnChange(fn: any): void { this.onChange = fn; }
    registerOnTouched(fn: any): void { this.onTouched = fn; }
    setDisabledState?(isDisabled: boolean): void {
        this.isDisabled = isDisabled;
        isDisabled ? this.searchControl.disable() : this.searchControl.enable();
        this._cdr.markForCheck();
    }

    onSelectionChange(value: string | null): void {
        this._value = value;
        this.onChange(this._value);
        this.onTouched();
    }

    clearSelection(event: MouseEvent): void {
        event.stopPropagation();
        this.onSelectionChange(null);
    }
}

--- FILE: @fwk/components/legacy-crud-wrapper/legacy-crud-wrapper.component.ts ---

import { Component, OnInit, ChangeDetectorRef, inject } from '@angular/core';
import { ActivatedRoute } from '@angular/router';
import { CommonModule } from '@angular/common';
import { CrudComponent } from '@fwk/components/crud/crud.component';
import { CrudDef } from '@fwk/model/component-def/crud-def';
import { BaseCrudService } from '@fwk/services/base-crud-service/base.crud.service';
import { GenericHttpService } from '@fwk/services/generic-http-service/generic-http.service';

@Component({
  selector: 'fwk-legacy-crud-wrapper',
  template: `
  <div class="flex flex-col flex-auto min-w-0" *ngIf="crudDef">
    <div class="bg-white dark:bg-transparent flex-auto">
      <fwk-crud 
        [componentName]="crudDef.name"
        [crudDefinition]="crudDef"> 
      </fwk-crud>
    </div>
  </div>
  `,
  standalone: true,
  imports: [CommonModule, CrudComponent],
  providers: [GenericHttpService, BaseCrudService]
})
export class LegacyCrudWrapperComponent implements OnInit {

  crudDef: CrudDef | null = null;

  private route = inject(ActivatedRoute);
  private cdr = inject(ChangeDetectorRef);

  ngOnInit(): void {
    this.crudDef = this.route.snapshot.data['definition'];

    if (!this.crudDef) {
      console.error('[LegacyCrudWrapper] No se pudo obtener CrudDef desde los datos de la ruta. Asegúrate de que el resolver esté configurado.');
    }

    this.cdr.markForCheck();
  }
}

--- FILE: @fwk/components/legacy-crud-wrapper/legacy-crud-wrapper.routes.ts ---

import { Routes } from '@angular/router';
import { LegacyCrudWrapperComponent } from './legacy-crud-wrapper.component';

export default [
    {
        path     : '',
        component: LegacyCrudWrapperComponent,
    },
] as Routes;

--- FILE: @fwk/components/modal-preview/modal-preview.component.html ---

﻿<div class="flex flex-col w-full h-full max-h-[90vh] bg-card rounded-2xl overflow-hidden shadow-2xl">
    <div class="flex items-center justify-between px-6 py-4 border-b bg-white dark:bg-gray-900 z-10">
        <div class="flex items-center min-w-0 gap-4">
            <div
                class="flex items-center justify-center w-10 h-10 rounded-full bg-primary-50 dark:bg-primary-900/20 text-primary-600">
                <mat-icon [svgIcon]="fileIcon"></mat-icon>
            </div>

            <div class="flex flex-col min-w-0">
                <h2 class="text-lg font-semibold leading-tight truncate" [matTooltip]="data.fileName">
                    {{ data.fileName }}
                </h2>
                <div class="flex items-center text-sm text-secondary truncate" *ngIf="data.fileUsername">
                    <mat-icon class="icon-size-3.5 mr-1" svgIcon="heroicons_outline:user"></mat-icon>
                    <span>Subido por {{ data.fileUsername }}</span>
                </div>
            </div>
        </div>

        <button mat-icon-button (click)="closeModal()"
            class="ml-4 text-secondary hover:text-primary-500 transition-colors">
            <mat-icon svgIcon="heroicons_outline:x-mark"></mat-icon>
        </button>
    </div>

    <div class="flex-auto relative overflow-hidden bg-gray-50 dark:bg-gray-950 flex items-center justify-center w-[80vh] h-[65vh]">

        <div *ngIf="isLoading"
            class="absolute inset-0 flex flex-col items-center justify-center z-20 bg-gray-50/80 dark:bg-gray-900/80 backdrop-blur-sm">
            <mat-spinner [diameter]="40"></mat-spinner>
            <span class="mt-3 text-sm font-medium text-secondary animate-pulse">Cargando vista previa...</span>
        </div>

        <div *ngIf="hasError" class="flex flex-col items-center text-center p-6 text-secondary">
            <mat-icon class="icon-size-16 text-red-400 mb-4" svgIcon="heroicons_outline:exclamation-circle"></mat-icon>
            <p class="text-lg font-semibold text-gray-800 dark:text-gray-200">No se pudo cargar el archivo</p>
            <p class="text-sm">El formato no es compatible o el archivo está dañado.</p>
        </div>

        <ng-container *ngIf="!hasError">
            <div *ngIf="isImageUrl; else iframeView"
                class="w-full h-full flex items-center justify-center p-4 overflow-auto">
                <div class="relative shadow-lg rounded bg-white image-checkerboard">
                    <img [src]="sanitizedUrl" class="max-w-full max-h-[65vh] object-contain rounded block"
                        alt="Vista previa" [class.opacity-0]="isLoading">
                </div>
            </div>

            <ng-template #iframeView>
                <iframe [src]="sanitizedUrl" class="w-full h-full border-0" (load)="onIframeLoad()">
                </iframe>
            </ng-template>
        </ng-container>
    </div>

    <div class="flex items-center justify-between px-6 py-4 border-t bg-white dark:bg-gray-900">

        <div class="hidden sm:flex flex-col text-xs text-secondary">
            <span *ngIf="fileSize" class="font-medium">Tamaño: {{ fileSize }}</span>
            <span *ngIf="imageMeta" class="mt-0.5">Dimensiones: {{ imageMeta.width }} x {{ imageMeta.height }} px</span>
        </div>

        <div class="flex items-center gap-3 ml-auto">
            <button mat-stroked-button (click)="closeModal()" class="hidden sm:inline-flex">
                Cerrar
            </button>
            <a [href]="sanitizedDownloadUrl" [download]="data.fileName" target="_blank">
                <button mat-flat-button color="accent">
                    <mat-icon class="icon-size-5 mr-2" svgIcon="heroicons_outline:arrow-down-tray"></mat-icon>
                    Descargar
                </button>
            </a>
        </div>
    </div>
</div>

--- FILE: @fwk/components/modal-preview/modal-preview.component.ts ---

﻿import { Component, Inject, OnInit, ChangeDetectionStrategy, ChangeDetectorRef, ViewEncapsulation } from '@angular/core';
import { CommonModule } from '@angular/common';
import { MAT_DIALOG_DATA, MatDialogRef, MatDialogModule } from '@angular/material/dialog';
import { DomSanitizer, SafeResourceUrl, SafeUrl } from '@angular/platform-browser';
import { MatButtonModule } from '@angular/material/button';
import { MatIconModule } from '@angular/material/icon';
import { MatTooltipModule } from '@angular/material/tooltip';
import { MatProgressBarModule } from '@angular/material/progress-bar';
import { TranslatePipe } from '@fwk/pipe/translate.pipe';

export interface FilePreviewData {
    url: string;
    fileName: string;
    fileUsername?: string;
}

@Component({
     selector: 'fwk-modal-preview',
    templateUrl: './modal-preview.component.html',
    styleUrls: ['./modal-preview.component.scss'],
    standalone: true,
    imports: [
        CommonModule,
        MatDialogModule,
        MatButtonModule,
        MatIconModule,
        MatTooltipModule,
        MatProgressBarModule,
        TranslatePipe
    ],
    changeDetection: ChangeDetectionStrategy.OnPush,
    encapsulation: ViewEncapsulation.None
})
export class ModalPreviewComponent implements OnInit {
    sanitizedUrl!: SafeUrl | SafeResourceUrl;
    sanitizedDownloadUrl!: SafeUrl;
    
    isImageUrl: boolean = false;
    isLoading: boolean = true;
    hasError: boolean = false;

    imageMeta: { width: number; height: number } | null = null;
    fileSize: string = '';
    fileIcon: string = 'heroicons_outline:document';

    constructor(
        @Inject(MAT_DIALOG_DATA) public data: FilePreviewData,
        private sanitizer: DomSanitizer,
        private dialogRef: MatDialogRef<ModalPreviewComponent>,
        private cdr: ChangeDetectorRef
    ) {}

    ngOnInit(): void {
        if (!this.data?.url) {
            this.hasError = true;
            this.isLoading = false;
            return;
        }

        this.determineFileIcon();
        this.calculateFileSize();

        this.isImageUrl = this.checkIfImage(this.data.fileName);
        this.sanitizedDownloadUrl = this.sanitizer.bypassSecurityTrustUrl(this.data.url);

        if (this.isImageUrl) {
            this.sanitizedUrl = this.sanitizer.bypassSecurityTrustUrl(this.data.url);
            this.preloadImage(this.data.url);
        } else {
            this.sanitizedUrl = this.sanitizer.bypassSecurityTrustResourceUrl(this.data.url);
            setTimeout(() => {
                this.isLoading = false;
                this.cdr.markForCheck();
            }, 1000);
        }
    }

    private checkIfImage(fileName: string): boolean {
        if (!fileName) return false;
        return /\.(jpg|jpeg|png|gif|svg|webp|bmp|ico)$/i.test(fileName);
    }

    private determineFileIcon(): void {
        const ext = this.data.fileName.split('.').pop()?.toLowerCase();
        switch (ext) {
            case 'pdf': this.fileIcon = 'heroicons_outline:document-text'; break;
            case 'jpg': case 'jpeg': case 'png': case 'gif': this.fileIcon = 'heroicons_outline:photo'; break;
            case 'zip': case 'rar': this.fileIcon = 'heroicons_outline:archive-box'; break;
            default: this.fileIcon = 'heroicons_outline:document'; break;
        }
    }

    private async calculateFileSize(): Promise<void> {
        try {
            if (this.data.url.startsWith('blob:')) {
                const response = await fetch(this.data.url);
                const blob = await response.blob();
                this.fileSize = this.formatBytes(blob.size);
            } 
            else if (this.data.url.includes('base64,')) {
                const base64Length = this.data.url.split(',')[1].length;
                const sizeInBytes = Math.ceil(base64Length * 3 / 4);
                this.fileSize = this.formatBytes(sizeInBytes);
            }
            this.cdr.markForCheck();
        } catch (e) {
            console.warn('No se pudo calcular el tamaño del archivo');
        }
    }

    private formatBytes(bytes: number, decimals = 2): string {
        if (bytes === 0) return '0 Bytes';
        const k = 1024;
        const sizes = ['Bytes', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(decimals)) + ' ' + sizes[i];
    }

    private preloadImage(url: string): void {
        const img = new Image();
        img.src = url;
        img.onload = () => {
            this.imageMeta = { width: img.width, height: img.height };
            this.isLoading = false;
            this.cdr.markForCheck();
        };
        img.onerror = () => {
            this.hasError = true;
            this.isLoading = false;
            this.cdr.markForCheck();
        };
    }

    onIframeLoad(): void {
        this.isLoading = false;
        this.cdr.markForCheck();
    }

    closeModal(): void {
        this.dialogRef.close();
    }
}

--- FILE: @fwk/components/page-component-wrapper/page-component-wrapper.component.html ---

<div class="flex flex-col flex-auto min-w-0" *ngIf="definition">
    <div class="flex flex-col items-center justify-center border-b bg-card dark:bg-transparent ">
        <div class="flex flex-col sm:flex-row flex-0 sm:items-center sm:justify-between p-4 sm:px-6 pt-2 w-full">
            <div class="flex-1 min-w-0">
                <div class="flex items-center gap-2">
                    <div class="text-3xl font-extrabold tracking-tight leading-7 sm:leading-10 truncate">
                        {{ pageTitle || ('page_title_default' | translate) }}
                    </div>
                    <back-button *ngIf="definition.backButton" color="accent"></back-button>
                </div>
                <div class="text-lg text-secondary" *ngIf="parentTitle">
                    {{ parentTitle }}
                </div>
                <div class="mt-2 text-lg text-secondary" *ngIf="!parentTitle && definition['subtitleKey']">
                    {{ definition['subtitleKey'] | translate:definition.i18n?.name }}
                </div>
            </div>

            <div class="flex shrink-0 items-center mt-6 sm:mt-0 sm:ml-4 space-x-2 print:hidden">
                <button *ngFor="let action of getVisibleActions()" mat-stroked-button color="accent"
                    [matTooltip]="action.actionName" (click)="executeAction(action)">
                    <mat-icon *ngIf="action.icon" [svgIcon]="action.icon"></mat-icon>
                    <span class="ml-2">{{ action.actionName }}</span>
                </button>
            </div>
        </div>
    </div>

    <div class="flex-auto">
        <div class="relative overflow-hidden">
            <ng-template #contentContainer></ng-template>
        </div>
    </div>
</div>

--- FILE: @fwk/components/page-component-wrapper/page-component-wrapper.component.ts ---

import {
    Component, OnInit, ViewChild, ViewContainerRef,
    Injector, ChangeDetectorRef, OnDestroy, inject, AfterViewInit
} from '@angular/core';
import { CommonModule } from '@angular/common';
import { ActivatedRoute } from '@angular/router';
import { MatIconModule } from '@angular/material/icon';
import { MatButtonModule } from '@angular/material/button';
import { MatTooltipModule } from '@angular/material/tooltip';
import { MatProgressSpinnerModule } from '@angular/material/progress-spinner';
import { Subject, takeUntil } from 'rxjs';

import { PageComponentDef } from '@fwk/model/component-def/page-component-def';
import { ActionDef } from '@fwk/model/component-def/action-def';
import { CustomPageComponent } from '@fwk/model/page-component.interface';
import { TranslatePipe } from '@fwk/pipe/translate.pipe';
import { BackButtonComponent } from '@fwk/components/back-button/backbutton.component';
import { AuthService } from '@fwk/auth/auth.service';
import { I18nService } from '@fwk/services/i18n-service/i18n.service';

@Component({
    selector: 'fwk-page-component-wrapper',
    standalone: true,
    imports: [
        CommonModule, MatButtonModule, MatIconModule,
        MatTooltipModule, MatProgressSpinnerModule,
        TranslatePipe, BackButtonComponent
    ],
    templateUrl: './page-component-wrapper.component.html'
})
export class PageComponentWrapperComponent implements OnInit, AfterViewInit, OnDestroy {
    @ViewChild('contentContainer', { read: ViewContainerRef })
    contentContainer!: ViewContainerRef;

    definition: PageComponentDef;
    pageTitle: string;
    parentTitle: string | null = null;
    actionLoadingStates = new Map<string, boolean>();

    private destroy$ = new Subject<void>();
    private componentInstance: CustomPageComponent | null = null;

    private route = inject(ActivatedRoute);
    private cdr = inject(ChangeDetectorRef);
    private authService = inject(AuthService);
    private i18nService = inject(I18nService);
    private injector = inject(Injector);

    ngOnInit(): void {
        this.definition = this.route.snapshot.data['definition'];
        if (!this.definition) {
            console.error('[PageComponentWrapper] No se encontró la definición de página en los datos de la ruta.');
            return;
        }

        const i18n = this.i18nService.getDictionary(this.definition.i18n.name);
        this.pageTitle = i18n?.translate?.('page_title') || this.definition.name;

        if (i18n && this.definition.actions) {
            this.definition.actions.forEach(action => {
                if (action.actionNameKey) {
                    action.actionName = i18n.translate?.(action.actionNameKey) ?? action.actionNameKey;
                }
            });
        }

        this.route.queryParams
            .pipe(takeUntil(this.destroy$))
            .subscribe(params => {
                this.parentTitle = params['parentTitle'] || null;
                this.cdr.markForCheck();
            });
    }

    ngAfterViewInit(): void {
        if (!this.contentContainer) {
            console.error("CRITICAL: contentContainer no se encontró en ngAfterViewInit.");
            return;
        }
        setTimeout(() => this.loadDynamicComponent(), 0);
    }

    private loadDynamicComponent(): void {
        if (!this.definition || !this.definition.component || !this.contentContainer) {
            console.error("No se puede cargar el componente dinámico: falta definición, componente o contenedor.");
            return;
        }

        this.contentContainer.clear();
        const componentRef = this.contentContainer.createComponent(this.definition.component, {
            injector: this.injector
        });

        if (componentRef.instance && typeof componentRef.instance.onAction === 'function') {
            this.componentInstance = componentRef.instance;
        } else {
            console.warn(`El componente ${this.definition.component.name} no parece implementar la interfaz 'CustomPageComponent' con el método 'onAction'. Las acciones del header podrían no funcionar.`);
        }

        this.cdr.detectChanges();
    }

    ngOnDestroy(): void {
        this.destroy$.next();
        this.destroy$.complete();
    }

    getVisibleActions(): ActionDef[] {
        if (!this.definition.actions) {
            return [];
        }
        return this.definition.actions.filter(action =>
            this.authService.hasPermission(action.actionSecurity)
        );
    }

    executeAction(action: ActionDef): void {
        if (this.componentInstance) {
            this.componentInstance.onAction(action);
        } else {
            console.error("No se puede ejecutar la acción porque la instancia del componente hijo no es válida o no implementa 'onAction'.");
        }
    }
}

--- FILE: @fwk/components/pick-list/pick-list.component.html ---

﻿<div class="flex flex-col w-full">
    
    <div class="flex flex-col sm:flex-row w-full gap-4">
        <mat-card class="flex-1 flex flex-col min-w-0" [ngClass]="{'!border-red-500 border': errorMessage}">
            <mat-card-header class="border-b pb-3">
                <mat-card-title class="text-lg font-extrabold" [ngClass]="{'text-red-500': errorMessage}">{{ titleFrom }}</mat-card-title>
            </mat-card-header>

            <div class="p-4">
                <mat-form-field class="w-full" appearance="outline">
                    <mat-label>{{ 'picklist_filter_placeholder' | translate }}</mat-label>
                    <input
                        matInput
                        [value]="filterValue"
                        (keyup)="applyFilter($event)"
                        [disabled]="isDisabled"
                        placeholder="{{ 'picklist_filter_placeholder' | translate }}">
                    <mat-icon matSuffix [svgIcon]="'heroicons_outline:magnifying-glass'"></mat-icon>
                </mat-form-field>
            </div>

            <mat-card-content class="flex-auto overflow-y-auto max-h-[40vh]">
                <mat-selection-list #from [(ngModel)]="fromDataSelected" [disabled]="isDisabled">
                    <mat-list-option checkboxPosition="before" *ngFor="let data of availableItems" [value]="data">
                        {{ getNameElementList(data) }}
                    </mat-list-option>
                </mat-selection-list>
            </mat-card-content>
        </mat-card>

        <div class="flex flex-row sm:flex-col items-center justify-center gap-2 p-2">
            <button type="button" (click)="transferToAll()" mat-icon-button [disabled]="isDisabled || availableItems.length === 0" [matTooltip]="'picklist_add_all_tooltip' | translate">
                <mat-icon [svgIcon]="'heroicons_outline:chevron-double-right'"></mat-icon>
            </button>
            <button type="button" (click)="transferTo()" mat-icon-button [disabled]="isDisabled || fromDataSelected.length === 0" [matTooltip]="'picklist_add_selected_tooltip' | translate">
                <mat-icon [svgIcon]="'heroicons_outline:chevron-right'"></mat-icon>
            </button>
            <button type="button" (click)="transferFrom()" mat-icon-button [disabled]="isDisabled || toDataSelected.length === 0" [matTooltip]="'picklist_remove_selected_tooltip' | translate">
                <mat-icon [svgIcon]="'heroicons_outline:chevron-left'"></mat-icon>
            </button>
            <button type="button" (click)="transferFromAll()" mat-icon-button [disabled]="isDisabled || selectedItems.length === 0" [matTooltip]="'picklist_remove_all_tooltip' | translate">
                <mat-icon [svgIcon]="'heroicons_outline:chevron-double-left'"></mat-icon>
            </button>
        </div>

        <mat-card class="flex-1 flex flex-col min-w-0" [ngClass]="{'!border-red-500 border': errorMessage}">
            <mat-card-header class="border-b pb-3">
                <mat-card-title class="text-lg font-extrabold" [ngClass]="{'text-red-500': errorMessage}">{{ titleTo }}</mat-card-title>
            </mat-card-header>

            <mat-card-content class="flex-auto overflow-y-auto max-h-[40vh]">
                <mat-selection-list #to [(ngModel)]="toDataSelected" [disabled]="isDisabled">
                    <mat-list-option checkboxPosition="before" *ngFor="let data of selectedItems" [value]="data">
                        {{ getNameElementList(data) }}
                    </mat-list-option>
                </mat-selection-list>
            </mat-card-content>
        </mat-card>
    </div>

    <div *ngIf="errorMessage" class="text-xs text-red-500 mt-1 pl-1">
        {{ errorMessage }}
    </div>

</div>

--- FILE: @fwk/components/pick-list/pick-list.component.ts ---

﻿import { Component, Input, forwardRef, OnInit, Injector, ChangeDetectorRef, OnChanges, SimpleChanges } from '@angular/core';
import { CommonModule } from '@angular/common';
import { ControlValueAccessor, NG_VALUE_ACCESSOR, FormsModule } from '@angular/forms';
import { MatCardModule } from '@angular/material/card';
import { MatListModule } from '@angular/material/list';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatInputModule } from '@angular/material/input';
import { MatButtonModule } from '@angular/material/button';
import { MatIconModule } from '@angular/material/icon';
import { MatTooltipModule } from '@angular/material/tooltip';
import { TranslatePipe } from '../../pipe/translate.pipe';
import { AbstractComponent } from '../abstract-component.component';

@Component({
     selector: 'fwk-pick-list',
    templateUrl: './pick-list.component.html',
    styleUrls: ['./pick-list.component.scss'],
    standalone: true,
    imports: [
        CommonModule, FormsModule, MatCardModule, MatListModule, MatFormFieldModule,
        MatInputModule, MatButtonModule, MatIconModule, MatTooltipModule, TranslatePipe
    ],
    providers: [
        { provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => PickListComponent), multi: true }
    ]
})
export class PickListComponent extends AbstractComponent implements ControlValueAccessor, OnInit, OnChanges {

    @Input() elementLabel: string = 'name';
    @Input() titleFrom: string;
    @Input() titleTo: string;
    @Input() allItems: any[] = [];
    
    @Input() errorMessage: string | null = null; 

    private _masterAllItemsMap = new Map<any, any>();

    availableItems: any[] = [];
    selectedItems: any[] = [];

    fromDataSelected: any[] = [];
    toDataSelected: any[] = [];

    isDisabled: boolean = false;
    filterValue: string = '';

    onChange: (value: any[] | null) => void = () => { };
    onTouch: () => void = () => { };

    constructor(injector: Injector, private cdr: ChangeDetectorRef) {
        super(injector);
    }

    ngOnChanges(changes: SimpleChanges): void {
        if (changes['allItems']) {
            this.mergeIntoMasterList(changes['allItems'].currentValue);
            this.updateLists();
        }
    }

    override ngOnInit(): void {
        super.ngOnInit();
        if (!this.titleFrom) this.titleFrom = this.translate('picklist_available_title');
        if (!this.titleTo) this.titleTo = this.translate('picklist_selected_title');
    }

    override getI18nName(): string { return 'fwk'; }

    writeValue(value: any[] | null): void {
        this.selectedItems = Array.isArray(value) ? [...value] : [];
        this.mergeIntoMasterList(this.selectedItems);
        this.updateLists();
        this.cdr.markForCheck();
    }

    private mergeIntoMasterList(items: any[]): void {
        if (!Array.isArray(items)) return;

        items.forEach(item => {
            const id = this.getItemId(item);
            if (!this._masterAllItemsMap.has(id)) {
                this._masterAllItemsMap.set(id, item);
            }
        });
    }

    registerOnChange(fn: (value: any[] | null) => void): void { this.onChange = fn; }
    registerOnTouched(fn: () => void): void { this.onTouch = fn; }
    setDisabledState(isDisabled: boolean): void {
        this.isDisabled = isDisabled;
        this.cdr.markForCheck();
    }

    private updateLists(): void {
        const masterList = Array.from(this._masterAllItemsMap.values());
        if (masterList.length === 0) {
            this.availableItems = [];
            return;
        }

        const selectedIds = new Set((this.selectedItems || []).map(item => this.getItemId(item)));
        const available = masterList.filter(item => !selectedIds.has(this.getItemId(item)));

        const filterText = this.filterValue.trim().toLowerCase();
        if (filterText) {
            this.availableItems = available.filter(item =>
                this.getNameElementList(item).toLowerCase().includes(filterText)
            );
        } else {
            this.availableItems = available;
        }
    }

    private notifyChanges(): void {
        const valueToEmit = this.selectedItems.length > 0 ? this.selectedItems : null;
        this.onChange(valueToEmit);
        this.onTouch();
    }

    transferTo(): void {
        this.selectedItems = [...this.selectedItems, ...this.fromDataSelected];
        this.fromDataSelected = [];
        this.updateLists();
        this.notifyChanges();
    }

    transferFrom(): void {
        const toTransferIds = new Set(this.toDataSelected.map(item => this.getItemId(item)));
        this.selectedItems = this.selectedItems.filter(item => !toTransferIds.has(this.getItemId(item)));
        this.toDataSelected = [];
        this.updateLists();
        this.notifyChanges();
    }

    transferToAll(): void {
        this.selectedItems = Array.from(this._masterAllItemsMap.values());
        this.fromDataSelected = [];
        this.updateLists();
        this.notifyChanges();
    }

    transferFromAll(): void {
        this.selectedItems = [];
        this.toDataSelected = [];
        this.updateLists();
        this.notifyChanges();
    }

    applyFilter(event?: Event): void {
        if (event) this.filterValue = (event.target as HTMLInputElement).value;
        this.updateLists();
    }

    getNameElementList(el: any): string {
        return el && this.elementLabel ? el[this.elementLabel] : '';
    }

    private getItemId(item: any): any {
        return item?.id ?? JSON.stringify(item);
    }
}

--- FILE: @fwk/components/question-modal/question-modal.component.html ---

﻿<div class="flex flex-col">
    <div mat-dialog-title class="flex items-center">
        <mat-icon *ngIf="data.icon?.show" [svgIcon]="data.icon.name!" [ngClass]="{
                'text-primary': data.icon.color === 'primary',
                'text-accent': data.icon.color === 'accent',
                'text-warn': data.icon.color === 'warn',
                'text-green-600': data.icon.color === 'success',
                'text-blue-600': data.icon.color === 'info'
            }">
        </mat-icon>
        <span class="ml-2 text-2xl font-semibold">{{ data.title }}</span>
    </div>

    <div mat-dialog-content class="py-6 text-secondary">
        {{ data.message }}
    </div>

    <div mat-dialog-actions class="flex items-center justify-end space-x-2">
        <button *ngIf="data.actions?.cancel?.show" mat-button [disabled]="isSubmitting" (click)="onReject()">
            {{ data.actions?.cancel?.label || ('modal_button_cancel' | translate) }}
        </button>
        <button *ngIf="data.actions?.confirm?.show" mat-flat-button [color]="data.actions?.confirm?.color"
            [disabled]="isSubmitting" (click)="onSubmit()">
            <span *ngIf="!isSubmitting">{{ data.actions?.confirm?.label || ('modal_button_confirm' | translate)
                }}</span>
            <mat-progress-spinner *ngIf="isSubmitting" [diameter]="24" mode="indeterminate"></mat-progress-spinner>
        </button>
    </div>
</div>

--- FILE: @fwk/components/question-modal/question-modal.component.ts ---

﻿import { Component, Inject, ChangeDetectorRef, ChangeDetectionStrategy } from '@angular/core';
import { CommonModule } from '@angular/common';
import { MatDialogRef, MAT_DIALOG_DATA, MatDialogModule } from '@angular/material/dialog';
import { MatButtonModule } from '@angular/material/button';
import { MatIconModule } from '@angular/material/icon';
import { MatProgressSpinnerModule } from '@angular/material/progress-spinner';
import { Observable, finalize } from 'rxjs';
import { TranslatePipe } from '../../pipe/translate.pipe';

export interface QuestionModalData {
    title: string;
    message: string;
    icon?: {
        show?: boolean;
        name?: string;
        color?: 'primary' | 'accent' | 'warn' | 'basic' | 'info' | 'success';
    };
    actions?: {
        confirm?: {
            show?: boolean;
            label?: string;
            color?: 'primary' | 'accent' | 'warn';
        };
        cancel?: {
            show?: boolean;
            label?: string;
        };
    };
    onReject?: () => void;
    onSubmit: () => Observable<any> | void;
}

@Component({
     selector: 'fwk-question-modal-component',
    templateUrl: './question-modal.component.html',
    styleUrls: ['./question-modal.component.scss'],
    standalone: true,
    imports: [
        CommonModule,
        MatDialogModule,
        MatButtonModule,
        MatIconModule,
        MatProgressSpinnerModule,
        TranslatePipe
    ],
    changeDetection: ChangeDetectionStrategy.OnPush,
})
export class QuestionModalComponent {

    data: QuestionModalData;
    isSubmitting: boolean = false;

    constructor(
        public dialogRef: MatDialogRef<QuestionModalComponent>,
        @Inject(MAT_DIALOG_DATA) data: QuestionModalData,
        private _cdr: ChangeDetectorRef,
    ) {
        this.data = this.mergeWithDefaults(data);
    }

    private mergeWithDefaults(data: QuestionModalData): QuestionModalData {
        const defaults: QuestionModalData = {
            title: '',
            message: '',
            onSubmit: () => { },
            icon: {
                show: true,
                name: 'heroicons_outline:question-mark-circle',
                color: 'warn'
            },
            actions: {
                confirm: {
                    show: true,
                    color: 'primary'
                },
                cancel: {
                    show: true
                }
            }
        };

        const finalData = {
            ...defaults,
            ...data,
            icon: {
                ...defaults.icon,
                ...data.icon
            },
            actions: {
                confirm: {
                    ...defaults.actions?.confirm,
                    ...data.actions?.confirm
                },
                cancel: {
                    ...defaults.actions?.cancel,
                    ...data.actions?.cancel
                }
            }
        };

        return finalData;
    }

    onReject(): void {
        if (this.data.onReject) {
            this.data.onReject();
        }
        this.dialogRef.close('rejected');
    }

    onSubmit(): void {
        if (this.data.onSubmit) {
            const result = this.data.onSubmit();

            if (result instanceof Observable) {
                this.isSubmitting = true;
                this._cdr.markForCheck();

                result.pipe(
                    finalize(() => {
                        this.isSubmitting = false;
                        this._cdr.markForCheck();
                        this.dialogRef.close('confirmed');
                    })
                ).subscribe();
            } else {
                this.dialogRef.close('confirmed');
            }
        } else {
            this.dialogRef.close('confirmed');
        }
    }
}

--- FILE: @fwk/components/simple-pick-list/simple-pick-list.component.html ---

﻿
<mat-card class="flex flex-col w-full h-full min-w-0"
        [class.border-red-500]="errorMessage"
        [class.border-2]="errorMessage"
        [class.border-solid]="errorMessage">
    
    <mat-card-header class="flex items-center justify-end p-4 border-b flex-row-reverse">
        <mat-checkbox
            class="mr-2"
            [checked]="isAllSelected()"
            [disabled]="isDisabled"
            (change)="toggleSelectAll()"
            [matTooltip]="'table_select_all_tooltip' | translate">
        </mat-checkbox>
        <mat-card-title class="text-lg font-extrabold m-0">{{ titleFrom }}</mat-card-title>
    </mat-card-header>

    <mat-card-content class="flex-auto overflow-y-auto px-2 max-h-[40vh]">
        <mat-selection-list
            #list
            [compareWith]="compareFn"
            [disabled]="isDisabled"
            (selectionChange)="onSelectionChange()">
            <mat-list-option
                *ngFor="let item of allItems"
                [value]="item"
                [selected]="selectedItems | some:compareFn:item"
                checkboxPosition="before"
                class="h-auto">
                {{ getNameElementList(item) }}
            </mat-list-option>
        </mat-selection-list>
    </mat-card-content>

    <div *ngIf="errorMessage" class="px-4 pb-2 pt-0">
        <span class="text-xs text-red-500 font-medium">{{ errorMessage }}</span>
    </div>
</mat-card>

--- FILE: @fwk/components/simple-pick-list/simple-pick-list.component.ts ---

﻿import { Component, Input, ViewChild, forwardRef, Injector, OnInit, ChangeDetectorRef } from '@angular/core';
import { CommonModule } from '@angular/common';
import { ControlValueAccessor, NG_VALUE_ACCESSOR, FormsModule } from '@angular/forms';
import { MatCardModule } from '@angular/material/card';
import { MatListModule, MatSelectionList } from '@angular/material/list';
import { MatCheckboxModule } from '@angular/material/checkbox';
import { MatTooltipModule } from '@angular/material/tooltip';
import { TranslatePipe } from '../../pipe/translate.pipe';

import { AbstractComponent } from '../abstract-component.component';
import { SomePipe } from '../../pipe/some.pipe';

@Component({
     selector: 'fwk-simple-pick-list',
    templateUrl: './simple-pick-list.component.html',
    styleUrls: ['./simple-pick-list.component.scss'],
    standalone: true,
    imports: [
        CommonModule,
        FormsModule,
        MatCardModule,
        MatListModule,
        MatCheckboxModule,
        SomePipe,
        TranslatePipe,
        MatTooltipModule,
    ],
    providers: [
        {
            provide: NG_VALUE_ACCESSOR,
            useExisting: forwardRef(() => SimplePickListComponent),
            multi: true
        }
    ]
})
export class SimplePickListComponent extends AbstractComponent implements ControlValueAccessor, OnInit {

    @Input() elementLabel: string = 'name';
    @Input() titleFrom: string;
    @Input() allItems: any[] = [];
    
    @Input() errorMessage: string | null = null; 

    @ViewChild('list') list!: MatSelectionList;

    selectedItems: any[] = [];
    isDisabled: boolean = false;

    onChange: (value: any[] | null) => void = () => { };
    onTouch: () => void = () => { };

    constructor(
        injector: Injector,
        private cdr: ChangeDetectorRef 
    ) {
        super(injector);
    }

    override ngOnInit(): void {
        super.ngOnInit();
        if (!this.titleFrom) {
            this.titleFrom = this.translate('simple_picklist_default_title');
        }
    }

    override getI18nName(): string {
        return 'fwk';
    }

    writeValue(value: any[] | null): void {
        this.selectedItems = Array.isArray(value) ? [...value] : [];
        this.cdr.markForCheck(); 
    }

    registerOnChange(fn: (value: any[] | null) => void): void {
        this.onChange = fn;
    }

    registerOnTouched(fn: () => void): void {
        this.onTouch = fn;
    }

    setDisabledState(isDisabled: boolean): void {
        this.isDisabled = isDisabled;
        this.cdr.markForCheck(); 
    }

    onSelectionChange(): void {
        this.selectedItems = this.list.selectedOptions.selected.map(option => option.value);
        this.onChange(this.selectedItems.length > 0 ? this.selectedItems : null);
        this.onTouch();
    }

    toggleSelectAll(): void {
        if (this.isAllSelected()) {
            this.list.deselectAll();
        } else {
            this.list.selectAll();
        }
        this.onSelectionChange();
    }

    isAllSelected(): boolean {
        return this.allItems?.length > 0 && this.selectedItems?.length === this.allItems.length;
    }

    getNameElementList(element: any): string {
        return element && this.elementLabel ? element[this.elementLabel] : '';
    }

    compareFn(c1: any, c2: any): boolean {
        return c1 && c2 ? (c1.id === c2.id) : (c1 === c2);
    }
}

--- FILE: @fwk/components/tags/tags.component.html ---

﻿<mat-form-field
    class="w-full"
    [style.width]="config.options?.width"
    appearance="outline">

    <mat-label>{{ config.label || ('tags' | translate) }}</mat-label>

    <mat-chip-grid #chipGrid aria-label="Ingreso de etiquetas" [errorStateMatcher]="matcher">
        <mat-chip-row
            *ngFor="let item of items"
            [removable]="!isDisabled"
            (removed)="remove(item)"
            (click)="copyToClipboard(item)"
            [matTooltip]="'tags_copy_tooltip' | translate:{value: item}"
            [class.cursor-pointer]="!isDisabled"
            [class.cursor-default]="isDisabled">
            {{ item }}
            <button matChipRemove [disabled]="isDisabled" *ngIf="!isDisabled">
                <mat-icon>cancel</mat-icon>
            </button>
        </mat-chip-row>
    </mat-chip-grid>

    <input
        [placeholder]="config.options?.inputPlaceholder || ('tags_add_placeholder' | translate)"
        [matChipInputFor]="chipGrid"
        [matChipInputSeparatorKeyCodes]="separatorKeysCodes"
        [matChipInputAddOnBlur]="true"
        (matChipInputTokenEnd)="add($event)"
        [disabled]="isDisabled"/>

    <mat-error *ngIf="errorMessage">{{ errorMessage }}</mat-error>

</mat-form-field>

--- FILE: @fwk/components/tags/tags.component.ts ---

﻿import { Component, Input, forwardRef, HostBinding, inject, ChangeDetectorRef } from '@angular/core';
import { CommonModule } from '@angular/common';
import { ControlValueAccessor, FormControl, FormGroupDirective, NG_VALUE_ACCESSOR, NgForm } from '@angular/forms';
import { MatChipInputEvent, MatChipsModule } from '@angular/material/chips';
import { MatIconModule } from '@angular/material/icon';
import { MatFormFieldModule } from '@angular/material/form-field';
import { COMMA, ENTER } from '@angular/cdk/keycodes';
import { MatSnackBar, MatSnackBarModule } from '@angular/material/snack-bar';
import { TagsConfiguration } from './tags.interface';
import { TranslatePipe } from '../../pipe/translate.pipe';
import { I18nService } from '@fwk/services/i18n-service/i18n.service';
import { ErrorStateMatcher } from '@angular/material/core';

@Component({
     selector: 'fwk-tags',
    templateUrl: './tags.component.html',
    styleUrls: ['./tags.component.scss'],
    standalone: true,
    imports: [
        CommonModule,
        MatChipsModule,
        MatIconModule,
        MatFormFieldModule,
        MatSnackBarModule,
        TranslatePipe
    ],
    providers: [
        {
            provide: NG_VALUE_ACCESSOR,
            useExisting: forwardRef(() => TagsComponent),
            multi: true
        }
    ]
})
export class TagsComponent implements ControlValueAccessor {

    @Input() config: TagsConfiguration = {
        required: false,
        disabled: false,
        options: {},
        label: ''
    };
    @Input() errorMessage: string | null = null;

    @HostBinding('style.opacity')
    get opacity() {
        return this.isDisabled ? 0.5 : 1;
    }

    items: string[] = [];
    isDisabled: boolean = false;
    
    matcher = new class implements ErrorStateMatcher {
        constructor(private component: TagsComponent) { }
        isErrorState(control: FormControl | null, form: FormGroupDirective | NgForm | null): boolean {
            return !!(this.component.errorMessage || (control?.invalid && (control?.dirty || control?.touched)));
        }
    }(this);

    onChange: (value: string[] | null) => void = () => {};
    onTouch: () => void = () => {};

    readonly separatorKeysCodes: number[] = [ENTER, COMMA];
    private _translatePipe = new TranslatePipe(inject(I18nService));
    private _cdr = inject(ChangeDetectorRef);

    constructor(private snackBar: MatSnackBar) {}

    writeValue(value: string[] | string | null): void {
        if (typeof value === 'string' && value) {
            this.items = value.split(',').map(item => item.trim()).filter(Boolean);
        } else if (Array.isArray(value)) {
            this.items = value.filter(Boolean);
        } else {
            this.items = [];
        }
        this._cdr.markForCheck();
    }

    registerOnChange(fn: (value: string[] | null) => void): void {
        this.onChange = fn;
    }

    registerOnTouched(fn: () => void): void {
        this.onTouch = fn;
    }

    setDisabledState(isDisabled: boolean): void {
        this.isDisabled = isDisabled;
        this._cdr.markForCheck();
    }

    add(event: MatChipInputEvent): void {
        const value = (event.value || '').trim();

        if (value && !this.items.includes(value)) {
            this.items.push(value);
            this.updateChanges();
        }

        if (event.chipInput) {
            event.chipInput.clear();
        }

        this.onTouch();
    }

    remove(item: string): void {
        const index = this.items.indexOf(item);
        if (index >= 0) {
            this.items.splice(index, 1);
            this.updateChanges();
        }
        this.onTouch();
    }

    private updateChanges(): void {
        const valueToEmit = this.items.length > 0 ? this.items : null;
        this.onChange(valueToEmit);
        this._cdr.markForCheck();
    }

    copyToClipboard(item: string): void {
        if (this.isDisabled) return;
        const formattedText = `%${item}%`;
        navigator.clipboard.writeText(formattedText).then(() => {
            this.snackBar.open(this._translatePipe.transform('tags_copied_message', formattedText), this._translatePipe.transform('action_close'), {
                duration: 2000,
                horizontalPosition: 'center',
                verticalPosition: 'bottom',
            });
        }).catch(() => {
            this.snackBar.open(this._translatePipe.transform('tags_copy_error'), this._translatePipe.transform('action_close'), {
                duration: 3000,
            });
        });
    }
}

--- FILE: @fwk/components/tags/tags.interface.ts ---

﻿export interface TagsConfiguration {
    label: string;
    required?: boolean;
    disabled?: boolean;
    value?: string;
    options?: TagsInvalidOptions;
}

export interface TagsInvalidOptions {
    requiredMessage?: string;
    invalidValueMessage?: string;
    width?: string;
    placeholder?: string;
    inputPlaceholder?: string;
}


export interface TagsOptions {
    width?: string;
    placeholder?: string;
    inputPlaceholder?: string;
}

--- FILE: @fwk/components/url-input/url-input.component.html ---

﻿<div class="flex items-center w-full space-x-2">
    <mat-form-field class="flex-auto" appearance="outline">
        <mat-label>{{ config.label }}</mat-label>
        
        <input
            matInput
            [ngModel]="_value" 
            [ngModelOptions]="{standalone: true}"
            (ngModelChange)="onValueChange($event)"
            (blur)="onTouch()"
            [required]="config.required"
            [disabled]="isDisabled"
            [placeholder]="config.label"
            [errorStateMatcher]="matcher">

        <button
            *ngIf="config.showPreview"
            matSuffix
            mat-icon-button
            type="button"
            class="mr-2"
            (click)="clickOpenUrl(); $event.stopPropagation()"
            [disabled]="isDisabled || !isUrlValid" 
            [matTooltip]="'url_input_preview_tooltip' | translate">
            <mat-icon [svgIcon]="config.iconOpenUrl || 'heroicons_outline:eye'"></mat-icon>
        </button>
        <mat-error *ngIf="errorMessage">{{ errorMessage }}</mat-error>

    </mat-form-field>
    
</div>

--- FILE: @fwk/components/url-input/url-input.component.ts ---

﻿import { Component, forwardRef, ChangeDetectorRef, Input } from '@angular/core';
import { CommonModule } from '@angular/common';
import { NG_VALUE_ACCESSOR, Validator, AbstractControl, ValidationErrors, NG_VALIDATORS, FormsModule, FormControl, FormGroupDirective, NgForm } from '@angular/forms';
import { ErrorStateMatcher } from '@angular/material/core';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatInputModule } from '@angular/material/input';
import { MatButtonModule } from '@angular/material/button';
import { MatIconModule } from '@angular/material/icon';
import { MatTooltipModule } from '@angular/material/tooltip';
import { UrlInputConfiguration } from './url-input.interface';
import { DynamicFieldFormComponent } from '../dynamic-form/dynamic-field-form/dynamic-field-form.component';
import { TranslatePipe } from '../../pipe/translate.pipe';

@Component({
  selector: 'fwk-url-input',
  templateUrl: './url-input.component.html',
  styleUrls: ['./url-input.component.scss'],
  standalone: true,
  imports: [
    CommonModule,
    FormsModule,
    MatFormFieldModule,
    MatInputModule,
    MatButtonModule,
    MatIconModule,
    MatTooltipModule,
    TranslatePipe
  ],
  providers: [
    {
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => UrlInputComponent),
      multi: true
    },
    {
      provide: NG_VALIDATORS,
      useExisting: forwardRef(() => UrlInputComponent),
      multi: true
    }
  ]
})
export class UrlInputComponent extends DynamicFieldFormComponent<string> implements Validator {

  @Input() config: UrlInputConfiguration = { label: '', options: { requiredMessage: '', invalidValueMessage: '' } };

  matcher = new class implements ErrorStateMatcher {
    constructor(private component: UrlInputComponent) { }
    isErrorState(control: FormControl | null, form: FormGroupDirective | NgForm | null): boolean {
      return !!(this.component.errorMessage || (control?.invalid && (control?.dirty || control?.touched)));
    }
  }(this);

  onValidatorChange: () => void = () => { };

  private readonly protocolPattern = /^(https?:\/\/)/i;
  private readonly urlPattern = /^https?:\/\/\S+/i;

  constructor(private cdr: ChangeDetectorRef) {
    super();
  }

  get isUrlValid(): boolean {
    if (!this._value) return false;
    return this.urlPattern.test(this._value);
  }

  override writeValue(value: string | null): void {
    this._value = value;
    this.cdr.markForCheck();
  }

  override setDisabledState(isDisabled: boolean): void {
    this.isDisabled = isDisabled;
    this.cdr.markForCheck();
  }

  validate(control: AbstractControl): ValidationErrors | null {
    const value = control.value;

    if (this.config.required && !value) {
      return { required: true };
    }

    if (value) {
      if (!this.protocolPattern.test(value)) {
        return { invalidProtocol: true };
      }

      if (!this.urlPattern.test(value)) {
        return { invalidUrlFormat: true };
      }
    }

    return null;
  }

  registerOnValidatorChange(fn: () => void): void {
    this.onValidatorChange = fn;
  }

  onInput(event: Event): void {
    const value = (event.target as HTMLInputElement).value;
    this.onValueChange(value);
  }

  onValueChange(newValue: string): void {
    const valueToEmit = newValue || null;
    if (this._value !== valueToEmit) {
      this._value = valueToEmit;
      this.onChange(valueToEmit);
      if (this.onValidatorChange) this.onValidatorChange();
    }
  }

  clickOpenUrl(): void {
    if (!this.isUrlValid) {
      return;
    }
    window.open(this._value!, '_blank')?.focus();
  }
}

--- FILE: @fwk/components/url-input/url-input.interface.ts ---

﻿export interface UrlInputConfiguration {
    label: string;
    required?: boolean;
    disabled?: boolean;
    value?: string;
    options?: UrlInputOptions;
    icon?: string;
    iconOpenUrl?: string;
    showPreview?: boolean;
}


export interface UrlInputOptions {
    requiredMessage?: string;
    invalidValueMessage?: string;
    resourceType?: string;
}


--- FILE: @fwk/directive/restriction-keys.directive.ts ---

﻿import { Directive, HostListener, ElementRef, Input } from '@angular/core';

@Directive({
    selector: '[restrictionKeys]',
    standalone: true
})
export class RestrictionKeysDirective {
    @Input('restrictionKeys') inputType: string = '';

    constructor(public el: ElementRef) { }

    @HostListener('keypress', ['$event'])
    onInput(event: KeyboardEvent): void {
        if (this.inputType) {
            const inputChar = event.key;
            const regex = new RegExp(this.inputType);

            if (!regex.test(inputChar)) {
                event.preventDefault();
            }
        }
    }
}

--- FILE: @fwk/i18n/fwk.i18n.ts ---

/**
 * Diccionario centralizado para todas las traducciones genéricas del framework (FWK).
 * Este archivo es la única fuente de verdad para los textos utilizados en componentes
 * reutilizables como modales, tablas, formularios, etc.
 *
 * Se registra globalmente en AppComponent para estar disponible en toda la aplicación.
 */
export const FWK_I18N_DEF = {
  name: 'fwk',
  lang: 'es',
  words: {
    // --- Generales y Acciones Comunes ---
    action_close: 'Cerrar',
    add_button: 'Agregar',
    and: 'y',
    back_button_tooltip: 'Volver',
    day_label: 'Día',
    generic_error_try_again: 'Algo salió mal, por favor intenta de nuevo.',
    go_to_link: 'Ir a',
    hour_label: 'Hora (0-23)',
    minute_label: 'Min (0-59)',
    month_label: 'Mes',
    return_to: 'Volver a',
    success_message: '¡Operación exitosa!',
    year_label: 'Año',

    // --- Autenticación y Seguridad ---
    auth_email_not_specified: 'Email no especificado',
    guard_no_permission: 'No tienes permiso para acceder a esta sección.',
    interceptor_session_expired_no_renew: 'La sesión ha expirado y no se pudo renovar.',
    interceptor_session_expired_relogin: 'Su sesión ha expirado. Por favor, inicie sesión de nuevo.',

    // --- Página: Iniciar Sesión (Sign-in) ---
    password_label: 'Contraseña',
    password_required_error: 'La contraseña es requerida',
    sign_in_button: 'Ingresar',
    sign_in_error_message: 'Usuario o contraseña incorrectos. Inténtelo de nuevo.',
    sign_in_link: 'Iniciar Sesión',
    sign_in_title: 'Iniciar Sesión',
    sign_in_welcome_subtitle: 'Bienvenido al panel de administración. Desde aquí podrás gestionar todo el contenido del sitio web y las comunicaciones.',
    sign_in_welcome_title_1: 'Administrador de',
    sign_in_welcome_title_2: 'Contenidos PREMEC',
    username_label: 'Usuario',
    username_required_error: 'El usuario es requerido',

    // --- Página: Cerrar Sesión (Sign-out) ---
    sign_out_button: 'Cerrar Sesión',
    sign_out_redirect_countdown: 'Redirigiendo en {{countdown}} segundos...',
    sign_out_redirecting_now: 'Estás siendo redirigido a la pantalla de inicio de sesión',
    sign_out_title: 'Cerraste Sesión',

    // --- Página: Registrarse (Sign-up) ---
    agreements_required_error: 'Debes aceptar los términos y la política de privacidad',
    already_have_account: '¿Ya tienes una cuenta?',
    company_label: 'Compañía',
    create_free_account_button: 'Crea tu cuenta gratuita',
    full_name_label: 'Nombre completo',
    full_name_required_error: 'El nombre completo es requerido',
    i_agree_with: 'Estoy de acuerdo con',
    privacy_policy: 'Política de Privacidad',
    sign_up_title: 'Regístrate',
    terms: 'Términos',

    // --- Páginas: Recuperar y Resetear Contraseña ---
    email_address_invalid_error: 'Por favor, introduce una dirección de email válida',
    email_address_label: 'Dirección de email',
    email_address_required_error: 'La dirección de email es requerida',
    forgot_password_error_message: '¡Correo electrónico no encontrado! ¿Estás seguro de que ya eres miembro?',
    forgot_password_subtitle: 'Rellena el formulario para restablecer tu contraseña',
    forgot_password_success_message: '¡Restablecimiento de contraseña enviado! Recibirás un correo electrónico si estás registrado en nuestro sistema.',
    forgot_password_title: '¿Olvidaste tu contraseña?',
    password_confirm_label: 'Contraseña (Confirmar)',
    password_confirm_required_error: 'La confirmación de la contraseña es requerida',
    passwords_must_match_error: 'Las contraseñas deben coincidir',
    reset_password_error_message: 'Algo salió mal, por favor intenta de nuevo.',
    reset_password_subtitle: 'Crea una nueva contraseña para tu cuenta',
    reset_password_success_message: 'Tu contraseña ha sido restablecida.',
    reset_password_title: 'Restablece tu contraseña',
    reset_your_password_button: 'Restablecer contraseña',
    send_reset_link_button: 'Enviar enlace de restablecimiento',

    // --- Páginas: Otras de Autenticación ---
    confirmation_required_subtitle: 'Se ha enviado un correo de confirmación con instrucciones a tu dirección de correo electrónico. Sigue esas instrucciones para confirmar tu dirección de correo electrónico y activar tu cuenta.',
    confirmation_required_title: 'Confirmación requerida',
    i_am_not: 'No soy',
    unlock_session_button: 'Desbloquear tu sesión',
    unlock_session_invalid_password: 'Contraseña inválida',
    unlock_session_subtitle: 'Tu sesión está bloqueada por inactividad',
    unlock_session_title: 'Desbloquear sesión',

    // --- Módulo CRUD: Generales y Acciones de Cabecera ---
    crud_delete_button: 'Eliminar',
    crud_download_boleta_tooltip: 'Descargar Boleta',
    crud_open_link_default_tooltip: 'Abrir enlace',
    delete_selected_tooltip: 'Eliminar seleccionados',
    export_csv_tooltip: 'Exportar a CSV',
    page_title_default: 'Gestión',

    // --- Módulo CRUD: Buscador (Search) y Búsqueda Global ---
    search_button_label: 'Buscar Página',
    search_modal_title: 'Búsqueda Rápida',
    search_placeholder_modal: 'Escribe para buscar una página...',
    search_no_results: 'No se encontraron resultados',
    search_no_results_subtitle: 'Intenta con un término de búsqueda diferente.',
    search_advanced_filters_button: 'Avanzados',
    search_advanced_filters_tooltip: 'Más filtros',
    search_clear_button: 'Limpiar',
    search_clear_tooltip: 'Limpiar filtros',
    search_columns_button: 'Columnas',
    search_columns_title: 'Mostrar Columnas',
    search_columns_tooltip: 'Mostrar/Ocultar columnas',
    search_columns_tooltip_altered: 'Visibilidad de columnas modificada',
    search_filter_count_plural: '# filtros aplicados',
    search_filter_count_singular: '# filtro aplicado',
    search_modal_title_advanced: 'Filtros Avanzados',
    search_panel_placeholder: 'Aplicar filtros',
    search_submit_button: 'Buscar',
    search_submit_tooltip: 'Aplicar filtros de búsqueda',
    search_title: 'Búsqueda',

    // --- Módulo CRUD: Tabla (Grid) ---
    boolean_false: 'No',
    boolean_true: 'Sí',
    table_action_button: 'Acciones',
    table_clear_filters_button: 'Limpiar filtros',
    table_empty_state_subtitle: '¡Crea el primero para empezar!',
    table_empty_state_title: 'Aún no hay registros',
    table_initial_search_prompt_title: 'Realice una búsqueda para comenzar',
    table_initial_search_prompt_subtitle: 'Utilice los filtros superiores para encontrar registros.',
    table_items_per_page: 'Items por página',
    table_no_records_found_subtitle: 'Intenta con otros filtros de búsqueda.',
    table_no_records_found_title: 'No se encontraron resultados',
    table_select_all_tooltip: 'Seleccionar todo',

    // --- Modales: Generales y de Confirmación ---
    modal_add_title: 'Nuevo registro',
    modal_button_cancel: 'Cancelar',
    modal_button_close: 'Cerrar',
    modal_button_confirm: 'Confirmar',
    modal_button_save: 'Guardar',
    modal_button_save_and_continue: 'Guardar y Continuar',
    modal_close_warning_cancel: 'No, continuar editando',
    modal_close_warning_confirm: 'Sí, cerrar',
    modal_close_warning_message: '¿Estás seguro de que deseas cerrar? Perderás los cambios no guardados.',
    modal_close_warning_title: 'Confirmación',
    modal_confirm_operation_title: 'Confirmar Operación',
    modal_delete_button_accept: 'Sí, eliminar',
    modal_delete_message_plural: '¿Estás seguro de que deseas eliminar {0} registro/s?',
    modal_delete_message_single: '¿Estás seguro de que deseas eliminar este registro?',
    modal_delete_title: 'Confirmar Eliminación',
    modal_edit_title: 'Editar registro',
    modal_view_title: 'Detalle del registro',

    // --- Modales: Específicos de Contenido ---
    grid_modal_default_title: 'Detalles',
    html_modal_default_title: 'Información',

    // --- Formularios: Errores de Validación Genéricos ---
    form_error_correct_errors: 'Por favor, corrige los errores en el formulario.',
    form_error_custom: 'El campo {0} es inválido.',
    form_error_date_format: 'El formato debe ser {0}',
    form_error_email: 'El formato del email para el campo {0} no es válido.',
    form_error_length: 'El campo {0} debe tener una longitud de {1} caracteres.',
    form_error_max: 'El campo {0} debe tener un valor máximo de {1}.',
    form_error_maxlength: 'El campo {0} no debe exceder los {1} caracteres.',
    form_error_min: 'El campo {0} debe tener un valor mínimo de {1}.',
    form_error_minlength: 'El campo {0} debe tener al menos {1} caracteres.',
    form_error_not_found: 'Mensaje de error no definido.',
    form_error_pattern: 'El campo {0} tiene un formato inválido.',
    form_error_required: 'El campo {0} es requerido.',
    form_error_url: 'El campo {0} debe ser una URL válida (http:// o https://).',

    // --- Formularios: Componentes Específicos ---
    autocomplete_required_error: 'Este campo es requerido.',
    autocomplete_select_or_clean_error: 'Debes seleccionar un elemento o limpiar el campo.',
    autocomplete_show_options_tooltip: 'Mostrar opciones',
    color_picker_invalid: 'El valor debe ser un color hexadecimal válido (ej: #FF0000).',
    color_picker_required: 'Este campo es requerido.',
    color_picker_tooltip: 'Seleccionar color',
    datepicker_clear_tooltip: 'Borrar fecha',
    datepicker_open_tooltip: 'Abrir calendario',
    datepicker_time_clear_tooltip: 'Borrar fecha y hora',
    file_attach_tooltip: 'Adjuntar archivo',
    icon_picker_clear_tooltip: 'Limpiar selección',
    icon_picker_none_option: '(Ninguno)',
    icon_picker_search_placeholder: 'Buscar icono...',
    url_input_preview_tooltip: 'Previsualizar',
    url_input_select_file_tooltip: 'Seleccionar archivo',
    url_input_select_image_tooltip: 'Seleccionar imagen',
    picklist_add_all_tooltip: 'Añadir todos',
    picklist_add_selected_tooltip: 'Añadir seleccionados',
    picklist_available_title: 'Disponibles',
    picklist_filter_placeholder: 'Filtrar disponibles',
    picklist_remove_all_tooltip: 'Quitar todos',
    picklist_remove_selected_tooltip: 'Quitar seleccionados',
    picklist_selected_title: 'Seleccionados',
    simple_picklist_default_title: 'Seleccionar',
    tags: 'Etiquetas',
    tags_add_placeholder: 'Añadir y presionar Enter...',
    tags_copied_message: 'Copiado: {0}',
    tags_copy_error: 'Error al copiar',
    tags_copy_tooltip: 'Clic para copiar %{value}%',
    terms_and_conditions_default_title: 'Términos y Condiciones',

    // --- Errores de Conectividad y HTTP ---
    http_error_0: 'No se pudo conectar con el servidor. Verifique su conexión a internet.',
    http_error_400: 'La solicitud es inválida. Por favor, revise los datos enviados.',
    http_error_403: 'Acción no autorizada. No tiene los permisos necesarios.',
    http_error_404: 'El recurso solicitado no se pudo encontrar en el servidor (Error 404).',
    http_error_5xx: 'Ocurrió un problema en el servidor. Nuestro equipo ha sido notificado. Por favor, intente más tarde.',
    http_error_generic: 'Ocurrió un error inesperado. Por favor, intente de nuevo más tarde.',
    http_error_no_download: 'No se pudo descargar el archivo.',

    // --- Layout: Menú de Usuario y Temas ---
    settings_layout_centered: 'Centrado',
    settings_layout_classic: 'Clásico',
    settings_layout_classy: 'Elegante',
    settings_layout_compact: 'Compacto',
    settings_layout_dense: 'Denso',
    settings_layout_empty: 'Vacío',
    settings_layout_enterprise: 'Empresarial',
    settings_layout_futuristic: 'Futurista',
    settings_layout_material: 'Material',
    settings_layout_modern: 'Moderno',
    settings_layout_thin: 'Delgado',
    settings_layout_title: 'DISEÑO',
    settings_scheme_auto: 'Automático',
    settings_scheme_auto_tooltip: 'Ajusta el esquema automáticamente según la preferencia de color del sistema operativo.',
    settings_scheme_dark: 'Oscuro',
    settings_scheme_light: 'Claro',
    settings_scheme_title: 'ESQUEMA',
    settings_theme_title: 'TEMA',
    settings_title: 'Configuración',
    theme_auto_tooltip: 'Tema Automático',
    theme_dark_tooltip: 'Tema Oscuro',
    theme_light_tooltip: 'Tema Claro',
    user_menu_tooltip: 'Opciones de Usuario',

    // --- Páginas de Error (403, 404) ---
    error_403_subtitle: 'No tienes los permisos necesarios para acceder a esta página. Aquí tienes algunos enlaces útiles:',
    error_403_title: 'Permiso Denegado',
    error_404_subtitle: 'La página que estás buscando no existe. Aquí tienes algunos enlaces útiles:',
    error_404_title: 'Página no encontrada',
    error_button_go_back: 'Volver atrás',
    error_button_go_home: 'Ir al inicio',

    // --- Widgets de Dashboard ---
    widget_empty_message: 'No hay información disponible para mostrar.',
    widget_empty_title: 'Sin datos',
    widget_error_default_message: 'No pudimos cargar los datos en este momento.',
    widget_error_retry_button: 'Reintentar',
    widget_error_title: '¡Oops! Algo salió mal',

    // --- Herramientas de Desarrollo (Dev Tools) ---
    dev_tools_add_action_button: 'Añadir Acción',
    dev_tools_add_column_button: 'Añadir Columna',
    dev_tools_add_field_button: 'Añadir Campo',
    dev_tools_add_option_button: 'Añadir Opción',
    dev_tools_add_widget_button: 'Añadir Widget',
    dev_tools_back_button: 'Atrás',
    dev_tools_card_next: 'Acceder',
    dev_tools_crud_gen_desc: 'Crea una página completa de Administración (CRUD) a partir de un endpoint de la API.',
    dev_tools_crud_gen_step1_endpoint_label: 'Endpoint Principal (GET)',
    dev_tools_crud_gen_step1_label: 'Origen de Datos',
    dev_tools_crud_gen_step1_subtitle: 'Introduce la URL del endpoint de la API para obtener la lista de datos. Esto nos permitirá autogenerar los campos.',
    dev_tools_crud_gen_step1_title: 'Origen de los Datos',
    dev_tools_crud_gen_step2_forms_title: 'Formularios a generar:',
    dev_tools_crud_gen_step2_icon_label: 'Ícono del Menú (Opcional)',
    dev_tools_crud_gen_step2_label: 'Información General',
    dev_tools_crud_gen_step2_name_error: 'Debe ser en formato PascalCase (ej. MiCrud).',
    dev_tools_crud_gen_step2_name_label: 'Nombre del CRUD (PascalCase)',
    dev_tools_crud_gen_step2_navgroup_label: 'Grupo de Navegación',
    dev_tools_crud_gen_step2_plural_label: 'Nombre en Plural para Títulos',
    dev_tools_crud_gen_step2_showinmenu_check: 'Mostrar en el menú de navegación',
    dev_tools_crud_gen_step2_showinmenu_subtitle: 'Si está activo, aparecerá un enlace en el menú lateral principal.',
    dev_tools_crud_gen_step2_subtitle: 'Define el nombre, la ubicación en el menú y los formularios que se generarán para tu nuevo CRUD.',
    dev_tools_crud_gen_step2_title: 'Información del CRUD',
    dev_tools_crud_gen_step3_auto_message: 'Se generarán permisos automáticamente con el prefijo {prefix}_ (ej: {prefix}_READ).',
    dev_tools_crud_gen_step3_customize_subtitle: 'Desactívalo para usar nombres de permisos generados automáticamente.',
    dev_tools_crud_gen_step3_customize_toggle: 'Personalizar nombres de permisos',
    dev_tools_crud_gen_step3_hint: 'Si dejas un campo vacío, se generará como null (sin seguridad para esa acción).',
    dev_tools_crud_gen_step3_label: 'Seguridad y Permisos',
    dev_tools_crud_gen_step3_subtitle: 'Define los permisos necesarios para cada acción del CRUD.',
    dev_tools_crud_gen_step3_title: 'Seguridad y Permisos',
    dev_tools_crud_gen_step4_col_key: 'Campo API',
    dev_tools_crud_gen_step4_col_label: 'Etiqueta UI',
    dev_tools_crud_gen_step4_col_options: 'Opciones',
    dev_tools_crud_gen_step4_col_type: 'Tipo de Control',
    dev_tools_crud_gen_step4_label: 'Configuración de Campos',
    dev_tools_crud_gen_step4_opt_basefilter: 'Filtro Base',
    dev_tools_crud_gen_step4_opt_filter: 'En Filtro',
    dev_tools_crud_gen_step4_opt_grid: 'En Grilla',
    dev_tools_crud_gen_step4_opt_req: 'Requerido',
    dev_tools_crud_gen_step4_subtitle: 'Define cómo se comportará cada campo en la UI. Las etiquetas y tipos de control son sugerencias.',
    dev_tools_crud_gen_step4_title: 'Configuración de Campos',
    dev_tools_crud_gen_step4_tooltip_advanced_options: 'Opciones avanzadas del campo',
    dev_tools_crud_gen_step4_tooltip_dynamic_behaviors: 'Definir comportamientos dinámicos',
    dev_tools_crud_gen_step5_action_confirm_message_label: 'Mensaje de confirmación',
    dev_tools_crud_gen_step5_action_condition_comparator_label: 'Comparador',
    dev_tools_crud_gen_step5_action_condition_field_label: 'Campo de la fila',
    dev_tools_crud_gen_step5_action_condition_no_condition: '-- Sin condición --',
    dev_tools_crud_gen_step5_action_condition_value_label: 'Valor',
    dev_tools_crud_gen_step5_action_display_condition_title: 'Condición de visualización (Opcional)',
    dev_tools_crud_gen_step5_action_general_info_title: 'Información General',
    dev_tools_crud_gen_step5_action_icon: 'Ícono',
    dev_tools_crud_gen_step5_action_modal_config_title: 'Configuración del Modal',
    dev_tools_crud_gen_step5_action_modal_define_form: 'Definir Formulario del Modal',
    dev_tools_crud_gen_step5_action_modal_fields: 'campos',
    dev_tools_crud_gen_step5_action_modal_show_save_continue: 'Mostrar botón "Guardar y Continuar"',
    dev_tools_crud_gen_step5_action_name: 'Nombre Acción',
    dev_tools_crud_gen_step5_action_new_name: 'Nueva Acción',
    dev_tools_crud_gen_step5_action_permission_label: 'Permiso (Opcional)',
    dev_tools_crud_gen_step5_action_qs_add_button: 'Añadir Parámetro',
    dev_tools_crud_gen_step5_action_qs_param_name_label: 'Nombre del Parámetro',
    dev_tools_crud_gen_step5_action_qs_param_value_label: 'Valor (Campo de la Fila)',
    dev_tools_crud_gen_step5_action_qs_remove_tooltip: 'Eliminar parámetro',
    dev_tools_crud_gen_step5_action_qs_title: 'Parámetros de URL (Querystring)',
    dev_tools_crud_gen_step5_action_redirect_open_tab: 'Abrir en nueva pestaña',
    dev_tools_crud_gen_step5_action_redirect_options_title: 'Opciones de Redirección',
    dev_tools_crud_gen_step5_action_redirect_url_hint: 'Si se deja vacío, por defecto irá a la vista de edición.',
    dev_tools_crud_gen_step5_action_redirect_url_label: 'URL de Destino',
    dev_tools_crud_gen_step5_action_requires_confirm_check: 'Requiere confirmación antes de ejecutar',
    dev_tools_crud_gen_step5_action_type: 'Tipo',
    dev_tools_crud_gen_step5_action_ws_config_modal_title: 'Configuración del Web Service (para el Submit del Modal)',
    dev_tools_crud_gen_step5_action_ws_config_title: 'Configuración del Web Service',
    dev_tools_crud_gen_step5_action_ws_endpoint_label: 'Endpoint',
    dev_tools_crud_gen_step5_action_ws_method_label: 'Método HTTP',
    dev_tools_crud_gen_step5_action_ws_relative_path: 'Ruta Relativa a la API',
    dev_tools_crud_gen_step5_custom_actions_title: 'Acciones Personalizadas por Fila',
    dev_tools_crud_gen_step5_delete_subtitle: 'Habilita el borrado masivo e individual en la grilla.',
    dev_tools_crud_gen_step5_delete_toggle: 'Habilitar borrado (masivo y por fila)',
    dev_tools_crud_gen_step5_general_options_title: 'Opciones Generales',
    dev_tools_crud_gen_step5_group_actions_subtitle: 'Muestra un único botón con menú para las acciones de cada fila.',
    dev_tools_crud_gen_step5_group_actions_title: 'Agrupar acciones en menú',
    dev_tools_crud_gen_step5_label: 'Acciones de la Grilla',
    dev_tools_crud_gen_step5_subtitle: 'Define las acciones globales y por fila para tu grilla.',
    dev_tools_crud_gen_step5_title: 'Acciones de la Grilla',
    dev_tools_crud_gen_step6_action_cell_class_label: 'Clase CSS para Celda de Acción',
    dev_tools_crud_gen_step6_dialog_width_label: 'Ancho del Modal',
    dev_tools_crud_gen_step6_export_csv_label: 'Exportar a CSV',
    dev_tools_crud_gen_step6_export_csv_opt_client: 'Habilitar (desde cliente)',
    dev_tools_crud_gen_step6_export_csv_opt_none: 'Deshabilitado',
    dev_tools_crud_gen_step6_export_csv_opt_server: 'Habilitar (desde servidor)',
    dev_tools_crud_gen_step6_label: 'Configuración Avanzada',
    dev_tools_crud_gen_step6_mem_filter: 'Filtrado en Memoria (Frontend)',
    dev_tools_crud_gen_step6_mem_filter_tooltip: 'El filtrado se realizará en el frontend (solo para pocos datos y sin paginación de servidor).',
    dev_tools_crud_gen_step6_no_init_search: 'No buscar al cargar la página',
    dev_tools_crud_gen_step6_no_init_search_tooltip: 'Evita que la grilla se cargue automáticamente al entrar a la página.',
    dev_tools_crud_gen_step6_pagesize: 'Tamaño de página por defecto',
    dev_tools_crud_gen_step6_server_pag: 'Paginación en Servidor',
    dev_tools_crud_gen_step6_server_pag_tooltip: 'La paginación se manejará en el backend (recomendado para grandes volúmenes de datos).',
    dev_tools_crud_gen_step6_subtitle: 'Ajustes finales sobre el comportamiento de la grilla y los modales.',
    dev_tools_crud_gen_step6_title: 'Configuración Avanzada',
    dev_tools_crud_gen_step7_actions_title: 'Acciones y Características',
    dev_tools_crud_gen_step7_auto_perms: 'Permisos generados automáticamente:',
    dev_tools_crud_gen_step7_base_filter_fields: 'Filtros Base Visibles:',
    dev_tools_crud_gen_step7_create_fields: 'Campos en Formulario de Alta:',
    dev_tools_crud_gen_step7_create_fields_desc: 'campos (todos excepto \'id\')',
    dev_tools_crud_gen_step7_custom_actions: 'Acciones Personalizadas:',
    dev_tools_crud_gen_step7_dialog_width_review: 'Ancho de Modal',
    dev_tools_crud_gen_step7_dynamic_behaviors: 'Comportamientos Dinámicos',
    dev_tools_crud_gen_step7_enable_delete: 'Habilitar Borrado:',
    dev_tools_crud_gen_step7_export_csv_review: 'Exportar a CSV',
    dev_tools_crud_gen_step7_filter_fields: 'Campos en Filtro:',
    dev_tools_crud_gen_step7_grid_fields: 'Campos en Grilla:',
    dev_tools_crud_gen_step7_label: 'Revisar y Generar',
    dev_tools_crud_gen_step7_main_endpoint: 'Endpoint Principal:',
    dev_tools_crud_gen_step7_main_title: 'Título Principal:',
    dev_tools_crud_gen_step7_name: 'Nombre del CRUD:',
    dev_tools_crud_gen_step7_read_fields: 'Campos en Vista de Lectura:',
    dev_tools_crud_gen_step7_read_fields_desc: 'Campos (todos)',
    dev_tools_crud_gen_step7_subtitle: 'Verifica que toda la configuración sea correcta antes de generar los archivos del CRUD.',
    dev_tools_crud_gen_step7_title: 'Revisión Final y Generación',
    dev_tools_crud_gen_step7_total_fields: 'Total de campos escaneados:',
    dev_tools_crud_gen_step7_update_fields: 'Campos en Formulario de Edición:',
    dev_tools_crud_gen_step7_update_fields_desc: 'Campos (todos)',
    dev_tools_crud_gen_title: 'Generador de CRUD',
    dev_tools_dash_gen_desc: 'Construye un nuevo dashboard con widgets de estadísticas y gráficos.',
    dev_tools_dash_gen_step1_label: 'Información General',
    dev_tools_dash_gen_step1_name_error: 'Debe ser en formato kebab-case (ej. mi-dashboard).',
    dev_tools_dash_gen_step1_name_label: 'Nombre del Módulo (kebab-case)',
    dev_tools_dash_gen_step1_next_button: 'Configurar Seguridad',
    dev_tools_dash_gen_step1_showinmenu_subtitle: 'Si está activo, aparecerá en el menú lateral principal.',
    dev_tools_dash_gen_step1_subtitle: 'Define los detalles básicos de tu nuevo dashboard y su ubicación en el menú.',
    dev_tools_dash_gen_step1_title: 'Información del Dashboard',
    dev_tools_dash_gen_step1_title_label: 'Título de la Página',
    dev_tools_dash_gen_step2_customize_subtitle: 'Desactívalo para usar un nombre de permiso generado automáticamente.',
    dev_tools_dash_gen_step2_hint: 'Si se deja vacío, el dashboard será público para usuarios logueados.',
    dev_tools_dash_gen_step2_label: 'Seguridad',
    dev_tools_dash_gen_step2_next_button: 'Configurar Widgets',
    dev_tools_dash_gen_step2_subtitle: 'Define el permiso necesario para ver este dashboard.',
    dev_tools_dash_gen_step3_label: 'Configuración de Widgets',
    dev_tools_dash_gen_step3_subtitle: 'Añade y configura cada widget que aparecerá en tu dashboard.',
    dev_tools_dash_gen_step3_title: 'Configuración de Widgets',
    dev_tools_dash_gen_step3_widget_add_filters_subtitle: 'Permite al usuario cambiar el rango de fechas o la agrupación de datos.',
    dev_tools_dash_gen_step3_widget_add_filters_toggle: 'Añadir filtros a este widget',
    dev_tools_dash_gen_step3_widget_data_source_title: 'Fuente de Datos',
    dev_tools_dash_gen_step3_widget_endpoint_hint_prefix: 'El prefijo',
    dev_tools_dash_gen_step3_widget_endpoint_hint_suffix: 'se añadirá automáticamente.',
    dev_tools_dash_gen_step3_widget_endpoint_label: 'Endpoint (sin el prefijo de estadísticas)',
    dev_tools_dash_gen_step3_widget_filter_remove_tooltip: 'Eliminar opción',
    dev_tools_dash_gen_step3_widget_filter_text_column: 'Texto (Visible para el usuario)',
    dev_tools_dash_gen_step3_widget_filter_text_placeholder: 'Ej: Últimos 7 días',
    dev_tools_dash_gen_step3_widget_filter_value_column: 'Valor (para la API)',
    dev_tools_dash_gen_step3_widget_filter_value_placeholder: 'Ej: 7DIAS / Dejar vacío para mostrar todo',
    dev_tools_dash_gen_step3_widget_general_config_title: 'Configuración General',
    dev_tools_dash_gen_step3_widget_list_title: 'Widgets',
    dev_tools_dash_gen_step3_widget_new_name: 'Nuevo Widget',
    dev_tools_dash_gen_step3_widget_remove_tooltip: 'Eliminar Widget',
    dev_tools_dash_gen_step3_widget_size_label: 'Tamaño',
    dev_tools_dash_gen_step3_widget_title_label: 'Título del Widget',
    dev_tools_dash_gen_step3_widget_type_label: 'Tipo',
    dev_tools_dash_gen_step4_label: 'Revisar y Generar',
    dev_tools_dash_gen_step4_review_endpoint: 'Endpoint:',
    dev_tools_dash_gen_step4_review_filename: 'Nombre de Archivos:',
    dev_tools_dash_gen_step4_review_filter_api_label: 'API:',
    dev_tools_dash_gen_step4_review_filters: 'Filtros:',
    dev_tools_dash_gen_step4_review_navgroup: 'Grupo de Navegación:',
    dev_tools_dash_gen_step4_review_navicon: 'Ícono del Menú:',
    dev_tools_dash_gen_step4_review_pagetitle: 'Título de Página:',
    dev_tools_dash_gen_step4_review_public_permission: 'Público',
    dev_tools_dash_gen_step4_review_read_permission: 'Permiso de Lectura (READ):',
    dev_tools_dash_gen_step4_review_showinmenu: 'Visible en Menú:',
    dev_tools_dash_gen_step4_review_size: 'Tamaño:',
    dev_tools_dash_gen_step4_review_subtitle: 'Verifica que la configuración sea correcta antes de generar los archivos.',
    dev_tools_dash_gen_step4_review_title: 'Revisión Final',
    dev_tools_dash_gen_step4_review_type: 'Tipo:',
    dev_tools_dash_gen_step4_review_widget_type: 'Tipo:',
    dev_tools_dash_gen_step4_review_widget_size: 'Tamaño:',
    dev_tools_dash_gen_step4_review_widget_endpoint: 'Endpoint:',
    dev_tools_dash_gen_step4_section_general_title: 'Información General',
    dev_tools_dash_gen_step4_section_security_title: 'Seguridad',
    dev_tools_dash_gen_step4_section_widgets_title: 'Widgets a Generar',
    dev_tools_dash_gen_title: 'Generador de Dashboard',
    dev_tools_def_editor_back_to_overview_tooltip: 'Volver a la vista general',
    dev_tools_def_editor_behaviors_add_action_button: 'Añadir Acción',
    dev_tools_def_editor_behaviors_add_condition_button: 'Añadir Condición (Y)',
    dev_tools_def_editor_behaviors_add_rule_button: 'Añadir Nueva Regla (O)',
    dev_tools_def_editor_behaviors_if_comparator_label: 'Comparador',
    dev_tools_def_editor_behaviors_if_field_label: 'Campo',
    dev_tools_def_editor_behaviors_if_title: 'SI el valor de...',
    dev_tools_def_editor_behaviors_if_value_label: 'Valor',
    dev_tools_def_editor_behaviors_if_value_placeholder: 'Ej: true, PENDIENTE, 100',
    dev_tools_def_editor_behaviors_remove_action_tooltip: 'Eliminar Acción',
    dev_tools_def_editor_behaviors_remove_condition_tooltip: 'Eliminar Condición',
    dev_tools_def_editor_behaviors_remove_rule_tooltip: 'Eliminar Comportamiento',
    dev_tools_def_editor_behaviors_rule_title: 'Regla de Comportamiento #',
    dev_tools_def_editor_behaviors_then_control_type_label: 'Cambiar Tipo de Control',
    dev_tools_def_editor_behaviors_then_control_type_no_change: '(No cambiar)',
    dev_tools_def_editor_behaviors_then_disabled_check: 'Deshabilitado',
    dev_tools_def_editor_behaviors_then_required_check: 'Requerido',
    dev_tools_def_editor_behaviors_then_set_value_label: 'Establecer Valor',
    dev_tools_def_editor_behaviors_then_target_field_label: 'Campo a Modificar',
    dev_tools_def_editor_behaviors_then_title: 'ENTONCES...',
    dev_tools_def_editor_behaviors_title: 'Comportamientos para',
    dev_tools_def_editor_crud_config_desc: 'Ajustes generales como paginación, filtros y exportación.',
    dev_tools_def_editor_crud_config_title: 'Configuración CRUD',
    dev_tools_def_editor_crud_data_behavior_title: 'Comportamiento de Datos',
    dev_tools_def_editor_crud_enable_delete: 'Habilitar borrado',
    dev_tools_def_editor_crud_enable_delete_tooltip: 'Permite el borrado individual y masivo.',
    dev_tools_def_editor_crud_enable_export: 'Habilitar exportación a CSV',
    dev_tools_def_editor_crud_enable_export_tooltip: 'Muestra el botón para exportar a CSV.',
    dev_tools_def_editor_crud_enable_sort: 'Habilitar ordenamiento',
    dev_tools_def_editor_crud_enable_sort_tooltip: 'Permite ordenar por todas las columnas.',
    dev_tools_def_editor_crud_export_filename_label: 'Nombre del Archivo (sin .csv)',
    dev_tools_def_editor_crud_export_opt_client: 'Habilitar (desde cliente)',
    dev_tools_def_editor_crud_export_opt_disabled: 'Deshabilitado',
    dev_tools_def_editor_crud_export_opt_server: 'Habilitar (desde servidor)',
    dev_tools_def_editor_crud_export_title: 'Exportación',
    dev_tools_def_editor_crud_export_ws_endpoint_hint: 'Ej: venta/export',
    dev_tools_def_editor_crud_export_ws_endpoint_label: 'Endpoint del WS (sin prefijo)',
    dev_tools_def_editor_crud_filter_memory: 'Filtrado en Memoria',
    dev_tools_def_editor_crud_filter_memory_tooltip: 'El filtrado se realizará en el frontend.',
    dev_tools_def_editor_crud_no_search: 'No buscar al cargar',
    dev_tools_def_editor_crud_no_search_tooltip: 'Evita que la grilla se cargue al entrar a la página.',
    dev_tools_def_editor_crud_pag_server: 'Paginación en Servidor',
    dev_tools_def_editor_crud_pag_server_tooltip: 'La paginación se manejará en el backend.',
    dev_tools_def_editor_crud_pagesize: 'Tamaño de página',
    dev_tools_def_editor_crud_save_button: 'Guardar Configuración CRUD',
    dev_tools_def_editor_crud_ui_presentation_title: 'Presentación y UI',
    dev_tools_def_editor_dash_config_title: 'Configuración del Dashboard',
    dev_tools_def_editor_dash_save_button: 'Guardar Dashboard',
    dev_tools_def_editor_dash_widget_add_filters: 'Añadir filtros a este widget',
    dev_tools_def_editor_dash_widget_data_source_title: 'Fuente de Datos (Web Service)',
    dev_tools_def_editor_dash_widget_endpoint: 'Endpoint',
    dev_tools_def_editor_dash_widget_endpoint_placeholder: 'PREFIX_STATS_API + \'mi-endpoint\'',
    dev_tools_def_editor_dash_widget_filter_options: 'Opciones de Filtro',
    dev_tools_def_editor_dash_widget_filter_text: 'Texto',
    dev_tools_def_editor_dash_widget_filter_text_column: 'Texto',
    dev_tools_def_editor_dash_widget_filter_text_placeholder: 'Ej: Hace 7 Días',
    dev_tools_def_editor_dash_widget_filter_value: 'Valor API',
    dev_tools_def_editor_dash_widget_filter_value_column: 'Valor API',
    dev_tools_def_editor_dash_widget_filter_value_placeholder: 'Ej: 7DIAS / Dejar vacío para mostrar todo',
    dev_tools_def_editor_dash_widget_general_config_title: 'Configuración General',
    dev_tools_def_editor_dash_widget_new_name: 'Nuevo Widget',
    dev_tools_def_editor_dash_widget_size: 'Tamaño',
    dev_tools_def_editor_dash_widget_title: 'Widget #{0}',
    dev_tools_def_editor_dash_widget_title_label: 'Título del Widget',
    dev_tools_def_editor_dash_widget_type: 'Tipo',
    dev_tools_def_editor_dash_widget_ws_key: 'Clave del WS (Key)',
    dev_tools_def_editor_dash_widget_ws_key_placeholder: 'EJEMPLO_URL',
    dev_tools_def_editor_desc: 'Modifica visualmente los archivos de configuración de cada módulo.',
    dev_tools_def_editor_dialog_add_col_exists_error: 'La columna \'{0}\' ya existe.',
    dev_tools_def_editor_dialog_add_col_label: 'ID (Key) de la nueva columna',
    dev_tools_def_editor_dialog_add_col_title: 'Añadir Columna',
    dev_tools_def_editor_dialog_add_field_label: 'Selecciona un campo existente',
    dev_tools_def_editor_dialog_add_field_title: 'Añadir Campo a {0}',
    dev_tools_def_editor_dialog_discard_confirm: 'Sí, descartar',
    dev_tools_def_editor_dialog_discard_message: 'Tienes cambios sin guardar. ¿Estás seguro de que quieres descartarlos y seleccionar otro módulo?',
    dev_tools_def_editor_dialog_discard_title: 'Descartar Cambios',
    dev_tools_def_editor_dialog_edit_col_cell_class: 'Clase CSS (Celda)',
    dev_tools_def_editor_dialog_edit_col_header_class: 'Clase CSS (Cabecera)',
    dev_tools_def_editor_dialog_edit_col_i18n: 'Clave de Traducción (i18n)',
    dev_tools_def_editor_dialog_edit_col_id: 'ID (Key)',
    dev_tools_def_editor_dialog_edit_col_label: 'Etiqueta (Texto visible)',
    dev_tools_def_editor_dialog_edit_col_title: 'Editando Columna: {0}',
    dev_tools_def_editor_error_load_detail: 'Error al cargar la definición de {{ name }}.',
    dev_tools_def_editor_error_load_list: 'No se pudieron cargar las definiciones.',
    dev_tools_def_editor_forms_basefilter_tooltip: 'Mostrar este filtro por defecto en la UI.',
    dev_tools_def_editor_forms_col_basefilter: 'Filtro Base',
    dev_tools_def_editor_forms_col_mapping_query: 'Mapeo Query',
    dev_tools_def_editor_forms_config_title: 'Configuración de Formularios',
    dev_tools_def_editor_forms_field_behaviors_tooltip: 'Definir comportamientos dinámicos',
    dev_tools_def_editor_forms_field_options_tooltip: 'Opciones avanzadas del campo',
    dev_tools_def_editor_forms_mapping_query_tooltip: 'Inicializar valor desde query param de URL',
    dev_tools_def_editor_forms_no_fields: 'Este formulario no tiene campos definidos.',
    dev_tools_def_editor_forms_save_button: 'Guardar Formularios',
    dev_tools_def_editor_grid_action_cell_class_label: 'Clase CSS para Celda de Acción',
    dev_tools_def_editor_grid_action_cell_class_placeholder: 'ej: justify-start',
    dev_tools_def_editor_grid_action_confirm_check: 'Requiere confirmación antes de ejecutar',
    dev_tools_def_editor_grid_action_confirm_message_label: 'Mensaje de confirmación',
    dev_tools_def_editor_grid_action_confirm_message_placeholder: '¿Está seguro?',
    dev_tools_def_editor_grid_action_condition_comparator_label: 'Comparador',
    dev_tools_def_editor_grid_action_condition_field_label: 'Campo de la fila',
    dev_tools_def_editor_grid_action_condition_no_condition: '-- Sin condición --',
    dev_tools_def_editor_grid_action_condition_value_label: 'Valor',
    dev_tools_def_editor_grid_action_condition_value_placeholder: 'Ej: ACTIVO, true, 10',
    dev_tools_def_editor_grid_action_define_form_button: 'Definir Formulario del Modal',
    dev_tools_def_editor_grid_action_display_condition_title: 'Condición de visualización (Opcional)',
    dev_tools_def_editor_grid_action_fields_label: 'campos',
    dev_tools_def_editor_grid_action_name: 'Nombre de la Acción',
    dev_tools_def_editor_grid_action_new_name: 'Nueva Acción',
    dev_tools_def_editor_grid_action_permission: 'Permiso (actionSecurity)',
    dev_tools_def_editor_grid_action_permission_placeholder: 'EJEMPLO_ACTION_PERMISSION',
    dev_tools_def_editor_grid_action_qs_add_button: 'Añadir Parámetro',
    dev_tools_def_editor_grid_action_qs_name_label: 'Nombre del Parámetro',
    dev_tools_def_editor_grid_action_qs_remove_tooltip: 'Eliminar parámetro',
    dev_tools_def_editor_grid_action_qs_title: 'Parámetros de URL (Querystring)',
    dev_tools_def_editor_grid_action_qs_value_label: 'Valor (Campo de la Fila)',
    dev_tools_def_editor_grid_action_redirect_new_tab: 'Abrir en nueva pestaña',
    dev_tools_def_editor_grid_action_redirect_url: 'URL de Destino',
    dev_tools_def_editor_grid_action_redirect_url_placeholder: '/mi-ruta',
    dev_tools_def_editor_grid_action_show_save_continue: 'Mostrar "Guardar y Continuar"',
    dev_tools_def_editor_grid_action_type: 'Tipo de Acción',
    dev_tools_def_editor_grid_action_ws_config_modal_title: 'Configuración del Web Service (para el Submit del Modal)',
    dev_tools_def_editor_grid_action_ws_config_title: 'Configuración del Web Service',
    dev_tools_def_editor_grid_action_ws_endpoint_label: 'Endpoint',
    dev_tools_def_editor_grid_action_ws_method_label: 'Método HTTP',
    dev_tools_def_editor_grid_action_ws_relative_path_label: 'Ruta Relativa a la API',
    dev_tools_def_editor_grid_action_ws_relative_path_tooltip: 'Si está activado, se antepondrá el prefijo de la API (PREFIX_DOMAIN_API).',
    dev_tools_def_editor_grid_actions_title: 'Acciones de la Grilla',
    dev_tools_def_editor_grid_col_key: 'Campo (key)',
    dev_tools_def_editor_grid_col_label: 'Etiqueta (i18n)',
    dev_tools_def_editor_grid_cols_def: 'Definición de Columnas',
    dev_tools_def_editor_grid_cols_visible: 'Columnas Visibles y Orden',
    dev_tools_def_editor_grid_config_title: 'Configuración de la Grilla',
    dev_tools_def_editor_grid_general_options_section_title: 'Opciones Generales de la Grilla',
    dev_tools_def_editor_grid_group_actions_toggle: 'Agrupar acciones en menú',
    dev_tools_def_editor_grid_group_actions_tooltip: 'Muestra un único botón con un menú desplegable para las acciones de cada fila.',
    dev_tools_def_editor_grid_no_actions: 'No hay acciones personalizadas definidas.',
    dev_tools_def_editor_grid_no_cols: 'No hay columnas definidas.<br>Añade una en el panel de la izquierda.',
    dev_tools_def_editor_grid_save_button: 'Guardar Configuración de Grilla',
    dev_tools_def_editor_grid_redirect_title: 'Opciones de Redirección',
    dev_tools_def_editor_grid_redirect_url: 'URL de Destino',
    dev_tools_def_editor_grid_redirect_url_placeholder: '/mi-ruta',
    dev_tools_def_editor_grid_redirect_new_tab: 'Abrir en nueva pestaña',
    dev_tools_def_editor_header_no_selection: 'Selecciona un módulo de la lista para comenzar',
    dev_tools_def_editor_loading: 'Cargando definición...',
    dev_tools_def_editor_nav_group: 'Grupo de Navegación',
    dev_tools_def_editor_nav_group_error: 'El grupo es requerido',
    dev_tools_def_editor_nav_icon: 'Ícono',
    dev_tools_def_editor_nav_menu_title: 'Título en Menú',
    dev_tools_def_editor_nav_menu_title_error: 'El título es requerido',
    dev_tools_def_editor_nav_page_title: 'Título de la Página',
    dev_tools_def_editor_nav_page_title_error: 'El título de la página es requerido',
    dev_tools_def_editor_nav_save_button: 'Guardar Navegación',
    dev_tools_def_editor_nav_show_in_menu: 'Mostrar en Menú de Navegación',
    dev_tools_def_editor_nav_show_in_menu_subtitle: 'Si está desactivado, el módulo será accesible por URL pero no aparecerá en el menú de navegación.',
    dev_tools_def_editor_nav_title: 'Navegación',
    dev_tools_def_editor_panel_hide_tooltip: 'Ocultar panel',
    dev_tools_def_editor_panel_show_tooltip: 'Mostrar panel',
    dev_tools_def_editor_saving: 'Guardando cambios y recargando...',
    dev_tools_def_editor_section_crud_config_desc: 'Ajustes generales como paginación, filtros y exportación.',
    dev_tools_def_editor_section_crud_config_title: 'Configuración CRUD',
    dev_tools_def_editor_section_dashboard_desc: 'Configura los widgets, gráficos y diseño de la página del dashboard.',
    dev_tools_def_editor_section_dashboard_title: 'Dashboard',
    dev_tools_def_editor_section_edit_button: 'Editar',
    dev_tools_def_editor_section_forms_desc: 'Define los campos y comportamientos para los formularios de alta, edición y filtro.',
    dev_tools_def_editor_section_forms_title: 'Formularios',
    dev_tools_def_editor_section_grid_desc: 'Configura las columnas, orden y acciones disponibles en la tabla.',
    dev_tools_def_editor_section_grid_title: 'Grilla',
    dev_tools_def_editor_section_nav_desc: 'Gestiona la visibilidad y apariencia del módulo en el menú principal.',
    dev_tools_def_editor_section_nav_title: 'Navegación',
    dev_tools_def_editor_section_overview_title: 'Vista General',
    dev_tools_def_editor_section_security_desc: 'Define los permisos necesarios para acceder y realizar acciones.',
    dev_tools_def_editor_section_security_title: 'Seguridad',
    dev_tools_def_editor_sections_menu_tooltip: 'Secciones de edición',
    dev_tools_def_editor_security_dashboard_info: 'Los dashboards solo tienen permisos de lectura.',
    dev_tools_def_editor_security_save_button: 'Guardar Seguridad',
    dev_tools_def_editor_security_subtitle: 'Define los permisos para cada acción. Deja un campo vacío para no aplicar seguridad.',
    dev_tools_def_editor_security_title: 'Seguridad y Permisos',
    dev_tools_def_editor_sidebar_loading: 'Cargando módulos...',
    dev_tools_def_editor_sidebar_no_results_subtitle: 'Intenta con otro término de búsqueda.',
    dev_tools_def_editor_sidebar_no_results_title: 'No se encontraron módulos',
    dev_tools_def_editor_sidebar_search: 'Buscar módulo...',
    dev_tools_def_editor_sidebar_subtitle: 'Selecciona un módulo para editar.',
    dev_tools_def_editor_sidebar_title: 'Definiciones de Módulos',
    dev_tools_def_editor_title: 'Editor de Definiciones',
    dev_tools_delete_tooltip: 'Eliminar',
    dev_tools_discard_button: 'Descartar',
    dev_tools_edit_tooltip: 'Editar',
    dev_tools_error_required: 'Este campo es requerido.',
    dev_tools_form_create: 'Alta (Create)',
    dev_tools_form_read: 'Lectura (Read-only)',
    dev_tools_form_update: 'Edición (Update)',
    dev_tools_generate_button: 'Generar CRUD',
    dev_tools_generate_dashboard_button: 'Generar Dashboard',
    dev_tools_gen_success_default_message: '¡Generado con éxito!',
    dev_tools_gen_success_subtitle: 'Por favor, espera unos segundos a que el servidor aplique los cambios y se reinicie.',
    dev_tools_i18n_desc: 'Edita los textos globales del framework y de la aplicación.',
    dev_tools_i18n_gen_desc: 'Administra los textos globales del framework y de la aplicación.',
    dev_tools_i18n_gen_title: 'Gestor de Textos (i18n)',
    dev_tools_i18n_key_column: 'Clave',
    dev_tools_i18n_loading: 'Cargando textos...',
    dev_tools_i18n_meta_description: 'Descripción (meta)',
    dev_tools_i18n_no_matches: 'No hay coincidencias en esta sección.',
    dev_tools_i18n_saving: 'Guardando cambios...',
    dev_tools_i18n_search_placeholder: 'Buscar clave o texto...',
    dev_tools_i18n_site_texts_title: 'Textos del Sitio (index.html)',
    dev_tools_i18n_subtitle: 'Edita los textos principales del framework y del sitio.',
    dev_tools_i18n_tab_title: 'Título de la pestaña',
    dev_tools_i18n_title: 'Gestor de Textos Globales (I18N)',
    dev_tools_i18n_value_column: 'Valor',
    dev_tools_menu_button: 'Menú',
    dev_tools_mode_badge: 'Modo Desarrollo',
    dev_tools_nav_col_icon: 'Ícono',
    dev_tools_nav_col_id: 'ID',
    dev_tools_nav_col_title: 'Título',
    dev_tools_nav_dialog_delete_confirm_message: '¿Estás seguro de que deseas eliminar el grupo "{0}"? Esta acción no se puede deshacer.',
    dev_tools_nav_dialog_delete_confirm_title: 'Confirmar Eliminación',
    dev_tools_nav_dialog_edit_title: 'Editar Grupo',
    dev_tools_nav_dialog_id_error: 'Solo letras, números y guiones bajos/medios.',
    dev_tools_nav_dialog_id_exists_error: 'El ID "{0}" ya existe.',
    dev_tools_nav_dialog_id_label: 'ID (único, sin espacios)',
    dev_tools_nav_dialog_icon_label: 'Ícono (ej: heroicons_outline:users)',
    dev_tools_nav_dialog_new_title: 'Nuevo Grupo de Navegación',
    dev_tools_nav_dialog_title_label: 'Título (visible en el menú)',
    dev_tools_nav_gen_desc: 'Administra los grupos del menú principal de la aplicación.',
    dev_tools_nav_gen_title: 'Gestor de Navegación',
    dev_tools_nav_subtitle: 'Añade, edita o elimina los grupos del menú principal.',
    dev_tools_nav_title: 'Gestor de Grupos de Navegación',
    dev_tools_new_group_button: 'Nuevo',
    dev_tools_next_button: 'Siguiente',
    dev_tools_no: 'No',
    dev_tools_none: 'Ninguno',
    dev_tools_perm_create: 'Permiso de Creación (CREATE)',
    dev_tools_perm_delete: 'Permiso de Borrado (DELETE)',
    dev_tools_perm_read: 'Permiso de Lectura (READ)',
    dev_tools_perm_update: 'Permiso de Edición (UPDATE)',
    dev_tools_review_and_generate_button: 'Revisar y Generar',
    dev_tools_save_button: 'Guardar',
    dev_tools_save_changes_button: 'Guardar Cambios',
    dev_tools_scan_button: 'Escanear y continuar',
    dev_tools_scan_error_title: 'Error al escanear:',
    dev_tools_subtitle: 'Asistentes para la generación de código y scaffolding de la aplicación.',
    dev_tools_title: 'Herramientas de Desarrollo',
    dev_tools_yes: 'Sí',
    dev_tools_crud_gen_action_form_modal_title: 'Definir Formulario para',
    dev_tools_crud_gen_action_form_modal_col_key: 'Campo (Key)',
    dev_tools_crud_gen_action_form_modal_col_label: 'Etiqueta',
    dev_tools_crud_gen_action_form_modal_col_control_type: 'Tipo de Control',
    dev_tools_crud_gen_action_form_modal_col_required: 'Requerido',

    // --- Textos de Plantilla (Ej: Fuse) ---
    our_community: 'nuestra comunidad',
    template_description: 'Fuse ayuda a los desarrolladores a construir paneles organizados y bien codificados, llenos de módulos hermosos y ricos. Únete a nosotros y comienza a construir tu aplicación hoy.',
    template_join_us: 'Más de 17k personas se unieron, es tu turno',
    welcome_to: 'Bienvenido a',
  }
};

--- FILE: @fwk/layout/common/search-button/search-button.component.html ---

<button
    *ngIf="searchEnabled"
    mat-button
    class="hidden md:inline-flex px-3"
    (click)="openSearchModal($event)">
    <mat-icon [svgIcon]="'heroicons_outline:document-magnifying-glass'"></mat-icon>
    <span class="ml-2 text-sm text-secondary">{{ 'search_button_label' | translate }}</span>
</button>

<button
    *ngIf="searchEnabled"
    mat-icon-button
    class="md:hidden px-3"
    (click)="openSearchModal($event)">
    <mat-icon [svgIcon]="'heroicons_outline:magnifying-glass'"></mat-icon>
</button>

--- FILE: @fwk/layout/common/search-button/search-button.component.ts ---

import { Component, ChangeDetectionStrategy, inject, OnInit } from '@angular/core';
import { CommonModule } from '@angular/common';
import { MatButtonModule } from '@angular/material/button';
import { MatIconModule } from '@angular/material/icon';
import { MatDialog } from '@angular/material/dialog';
import { SearchModalComponent } from '../search-modal/search-modal.component';
import { AbstractAuthService } from '@fwk/auth/abstract-auth.service';
import { TranslatePipe } from '@fwk/pipe/translate.pipe';

@Component({
     selector: 'fwk-search-button',
    standalone: true,
    imports: [CommonModule, MatButtonModule, MatIconModule, TranslatePipe],
    templateUrl: './search-button.component.html',
    changeDetection: ChangeDetectionStrategy.OnPush,
})
export class SearchButtonComponent implements OnInit {
    private dialog = inject(MatDialog);
    private authService = inject(AbstractAuthService);

    searchEnabled = false;

    ngOnInit(): void {
        this.authService.authenticated$.subscribe(isAuthenticated => {
            this.searchEnabled = isAuthenticated;
        });
    }

    openSearchModal(event: MouseEvent): void {
        this.dialog.open(SearchModalComponent, {
            width: '600px',
            maxWidth: '90vw',
            panelClass: 'search-modal-panel'
        });

        if (event.currentTarget) {
            (event.currentTarget as HTMLElement).blur();
        }
    }
}

--- FILE: @fwk/layout/common/search-modal/search-modal.component.html ---

<div class="flex flex-col max-h-[90vh] bg-card dark:bg-gray-800 rounded-lg overflow-hidden">

    <!-- Header con Input de Búsqueda -->
    <div class="flex items-center p-4 border-b border-gray-200 dark:border-gray-700">
        <mat-icon class="mr-3 text-gray-400" [svgIcon]="'heroicons_outline:magnifying-glass'"></mat-icon>
        <input #searchInput class="w-full h-10 bg-transparent border-0 focus:ring-0 text-lg"
            [formControl]="searchControl" [placeholder]="'search_placeholder_modal' | translate" autocomplete="off">
        <button mat-icon-button (click)="closeModal()" class="-mr-2">
            <mat-icon [svgIcon]="'heroicons_outline:x-mark'"></mat-icon>
        </button>
    </div>

    <!-- Resultados -->
    <mat-dialog-content class="flex-auto overflow-y-auto p-0">
        <div *ngIf="results$ | async as results" class="divide-y divide-gray-200 dark:divide-gray-700">
            <ng-container *ngIf="results.length > 0; else noResultsTemplate">
                <a mat-list-item *ngFor="let result of results" (click)="navigateTo(result)"
                    class="!h-auto cursor-pointer dark:hover:bg-gray-700/50 flex hover:bg-gray-50 items-center px-6 py-3 w-full">
                    <div class="flex flex-col w-full">
                        <div class="text-xs text-secondary tracking-wider uppercase">
                            <ng-container *ngFor="let item of result.breadcrumb; let isLast = last">
                                <span>{{ item }}</span>
                                <span *ngIf="!isLast" class="mx-1.5 opacity-50">/</span>
                            </ng-container>
                        </div>
                        <div class="text-2xl font-medium">
                            {{ result.title }}
                        </div>
                    </div>
                </a>
            </ng-container>

            <ng-template #noResultsTemplate>
                <div *ngIf="searchControl.value && searchControl.value.length >= 2"
                    class="flex flex-col items-center justify-center p-16 text-center">
                    <mat-icon class="icon-size-16 text-gray-400"
                        [svgIcon]="'heroicons_outline:document-magnifying-glass'"></mat-icon>
                    <p class="mt-4 text-lg font-medium">{{ 'search_no_results' | translate }}</p>
                    <p class="text-secondary mt-1">{{ 'search_no_results_subtitle' | translate }}</p>
                </div>
            </ng-template>
        </div>
    </mat-dialog-content>
</div>

--- FILE: @fwk/layout/common/search-modal/search-modal.component.ts ---

import { Component, ChangeDetectionStrategy, inject, OnInit, ViewChild, ElementRef, AfterViewInit } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormControl, ReactiveFormsModule } from '@angular/forms';
import { MatInputModule } from '@angular/material/input';
import { MatIconModule } from '@angular/material/icon';
import { MatListModule } from '@angular/material/list';
import { MatDialogModule, MatDialogRef } from '@angular/material/dialog';
import { MatButtonModule } from '@angular/material/button';
import { Router } from '@angular/router';
import { Observable, of } from 'rxjs';
import { debounceTime, distinctUntilChanged, startWith, switchMap } from 'rxjs/operators';
import { SearchResult, SearchService } from '@fwk/services/search/search.service';
import { TranslatePipe } from '@fwk/pipe/translate.pipe';

@Component({
     selector: 'fwk-search-modal',
    standalone: true,
    imports: [
        CommonModule, ReactiveFormsModule, MatInputModule,
        MatIconModule, MatListModule, MatDialogModule, MatButtonModule, TranslatePipe
    ],
    templateUrl: './search-modal.component.html',
    styles: [
        `
      .search-modal-panel .mat-mdc-dialog-container .mdc-dialog__surface {
          border-radius: 0.75rem !important; /* 12px */
      }
    `
    ],
    changeDetection: ChangeDetectionStrategy.OnPush,
})
export class SearchModalComponent implements OnInit, AfterViewInit {
    private dialogRef = inject(MatDialogRef<SearchModalComponent>);
    private searchService = inject(SearchService);
    private router = inject(Router);

    @ViewChild('searchInput') searchInput: ElementRef<HTMLInputElement>;

    searchControl = new FormControl('');
    results$: Observable<SearchResult[]>;

    ngOnInit(): void {
        this.results$ = this.searchControl.valueChanges.pipe(
            startWith(''),
            debounceTime(500),
            distinctUntilChanged(),
            switchMap(term => {
                if (!term || term.length < 2) {
                    return of([]);
                }
                return this.searchService.search(term);
            })
        );
    }

    ngAfterViewInit(): void {
        setTimeout(() => this.searchInput.nativeElement.focus(), 100);

        this.dialogRef.afterClosed().subscribe(() => {
            if (document.activeElement instanceof HTMLElement) {
                document.activeElement.blur();
            }
        });
    }

    navigateTo(result: SearchResult): void {
        if (result?.link) {
            this.router.navigateByUrl(result.link);
            this.closeModal();
        }
    }

    closeModal(): void {
        this.dialogRef.close();
    }
}

--- FILE: @fwk/layout/common/settings/settings.component.html ---

<div
    class="settings-cog fixed flex items-center justify-center right-0 w-10 h-10 shadow-lg rounded-l-lg z-90 cursor-pointer bg-red-600 bg-opacity-90 print:hidden"
    [class.lg:right-0]="config.layout === 'centered' || config.layout === 'material'"
    [class.lg:right-16]="config.layout !== 'centered' && config.layout !== 'material'"
    style="top: 275px"
    (click)="settingsDrawer.toggle()">
    <mat-icon
        class="icon-size-5 text-white animate-spin-slow"
        [svgIcon]="'heroicons_solid:cog-8-tooth'"></mat-icon>
</div>

<fuse-drawer
    class="w-screen min-w-screen sm:w-100 sm:min-w-100 z-999"
    fixed
    [mode]="'over'"
    [name]="'settingsDrawer'"
    [position]="'right'"
    #settingsDrawer>

    <div class="flex flex-col w-full overflow-auto bg-card">
        <div class="flex flex-row items-center px-6 h-20 min-h-20 text-white bg-primary">
            <mat-icon
                class="icon-size-7 text-current"
                [svgIcon]="'heroicons_solid:cog-8-tooth'"></mat-icon>
            <div class="ml-3 text-2xl font-semibold tracking-tight">{{ 'settings_title' | translate }}</div>
            <button
                class="ml-auto"
                mat-icon-button
                (click)="settingsDrawer.close()">
                <mat-icon
                    class="text-current"
                    [svgIcon]="'heroicons_outline:x-mark'"></mat-icon>
            </button>
        </div>

        <div class="flex flex-col p-6">

            <div class="text-md font-semibold text-secondary">{{ 'settings_theme_title' | translate }}</div>
            <div class="grid grid-cols-2 sm:grid-cols-3 gap-3 mt-6">
                <ng-container *ngFor="let theme of config.themes">
                    <div
                        class="flex items-center justify-center px-4 py-3 rounded-full cursor-pointer ring-inset ring-primary bg-hover"
                        [class.ring-2]="config.theme === theme.id"
                        [ngClass]="theme.id"
                        (click)="setTheme(theme.id)">
                        <div
                            class="flex-0 w-3 h-3 rounded-full bg-primary"
                        ></div>
                        <div
                            class="ml-2.5 font-medium leading-5 truncate"
                            [class.text-secondary]="config.theme !== theme.id">
                            {{theme.name}}
                        </div>
                    </div>
                </ng-container>
            </div>

            <hr class="my-8">

            <div class="text-md font-semibold text-secondary">{{ 'settings_scheme_title' | translate }}</div>
            <div class="grid grid-cols-3 gap-3 justify-items-start mt-6">

                <div
                    class="flex items-center py-3 pl-5 pr-6 rounded-full cursor-pointer ring-inset ring-primary bg-hover"
                    [class.ring-2]="config.scheme === 'auto'"
                    [matTooltip]="'settings_scheme_auto_tooltip' | translate"
                    (click)="setScheme('auto')">
                    <div class="flex items-center rounded-full overflow-hidden">
                        <mat-icon
                            class="icon-size-5"
                            [svgIcon]="'heroicons_solid:bolt'"></mat-icon>
                    </div>
                    <div
                        class="flex items-center ml-2 font-medium leading-5"
                        [class.text-secondary]="config.scheme !== 'auto'">
                        {{ 'settings_scheme_auto' | translate }}
                    </div>
                </div>

                <div
                    class="flex items-center py-3 pl-5 pr-6 rounded-full cursor-pointer ring-inset ring-primary bg-hover"
                    [class.ring-2]="config.scheme === 'dark'"
                    (click)="setScheme('dark')">
                    <div class="flex items-center rounded-full overflow-hidden">
                        <mat-icon
                            class="icon-size-5"
                            [svgIcon]="'heroicons_solid:moon'"></mat-icon>
                    </div>
                    <div
                        class="flex items-center ml-2 font-medium leading-5"
                        [class.text-secondary]="config.scheme !== 'dark'">
                        {{ 'settings_scheme_dark' | translate }}
                    </div>
                </div>

                <div
                    class="flex items-center py-3 pl-5 pr-6 rounded-full cursor-pointer ring-inset ring-primary bg-hover"
                    [class.ring-2]="config.scheme === 'light'"
                    (click)="setScheme('light')">
                    <div class="flex items-center rounded-full overflow-hidden">
                        <mat-icon
                            class="icon-size-5"
                            [svgIcon]="'heroicons_solid:sun'"></mat-icon>
                    </div>
                    <div
                        class="flex items-center ml-2 font-medium leading-5"
                        [class.text-secondary]="config.scheme !== 'light'">
                        {{ 'settings_scheme_light' | translate }}
                    </div>
                </div>
            </div>

            <hr class="my-8">

            <div class="text-md font-semibold text-secondary">{{ 'settings_layout_title' | translate }}</div>
            <div class="grid grid-cols-3 gap-3 mt-6">

                <div
                    class="flex flex-col cursor-pointer"
                    (click)="setLayout('empty')">
                    <div
                        class="flex flex-col h-20 rounded-md overflow-hidden border-2 hover:opacity-80"
                        [class.border-primary]="config.layout === 'empty'">
                        <div class="flex flex-col flex-auto bg-gray-50 dark:bg-gray-900"></div>
                    </div>
                    <div
                        class="mt-2 text-md font-medium text-center text-secondary"
                        [class.text-primary]="config.layout === 'empty'">
                        {{ 'settings_layout_empty' | translate }}
                    </div>
                </div>

                <div
                    class="flex flex-col cursor-pointer"
                    (click)="setLayout('classic')">
                    <div
                        class="flex h-20 rounded-md overflow-hidden border-2 hover:opacity-80"
                        [class.border-primary]="config.layout === 'classic'">
                        <div class="w-8 bg-gray-100 dark:bg-gray-800">
                            <div class="mt-3 mx-1.5 space-y-1">
                                <div class="h-1 rounded-sm bg-gray-300 dark:bg-gray-700"></div>
                                <div class="h-1 rounded-sm bg-gray-300 dark:bg-gray-700"></div>
                                <div class="h-1 rounded-sm bg-gray-300 dark:bg-gray-700"></div>
                                <div class="h-1 rounded-sm bg-gray-300 dark:bg-gray-700"></div>
                                <div class="h-1 rounded-sm bg-gray-300 dark:bg-gray-700"></div>
                            </div>
                        </div>
                        <div class="flex flex-col flex-auto border-l">
                            <div class="h-3 bg-gray-100 dark:bg-gray-800">
                                <div class="flex items-center justify-end h-full mr-1.5">
                                    <div class="w-1 h-1 ml-1 rounded-full bg-gray-300 dark:bg-gray-700"></div>
                                    <div class="w-1 h-1 ml-1 rounded-full bg-gray-300 dark:bg-gray-700"></div>
                                    <div class="w-1 h-1 ml-1 rounded-full bg-gray-300 dark:bg-gray-700"></div>
                                </div>
                            </div>
                            <div class="flex flex-auto border-t bg-gray-50 dark:bg-gray-900"></div>
                        </div>
                    </div>
                    <div
                        class="mt-2 text-md font-medium text-center text-secondary"
                        [class.text-primary]="config.layout === 'classic'">
                        {{ 'settings_layout_classic' | translate }}
                    </div>
                </div>

                <div
                    class="flex flex-col cursor-pointer"
                    (click)="setLayout('classy')">
                    <div
                        class="flex h-20 rounded-md overflow-hidden border-2 hover:opacity-80"
                        [class.border-primary]="config.layout === 'classy'">
                        <div class="w-8 bg-gray-100 dark:bg-gray-800">
                            <div class="flex items-center mt-1 mx-1">
                                <div class="w-1 h-1 rounded-full bg-gray-300 dark:bg-gray-700"></div>
                                <div class="w-1 h-1 ml-auto rounded-full bg-gray-300 dark:bg-gray-700"></div>
                                <div class="w-1 h-1 ml-0.5 rounded-full bg-gray-300 dark:bg-gray-700"></div>
                            </div>
                            <div class="w-4 h-4 mt-2.5 mx-auto rounded-full bg-gray-300 dark:bg-gray-700"></div>
                            <div class="mt-2 mx-1 space-y-1">
                                <div class="h-1 rounded-sm bg-gray-300 dark:bg-gray-700"></div>
                                <div class="h-1 rounded-sm bg-gray-300 dark:bg-gray-700"></div>
                                <div class="h-1 rounded-sm bg-gray-300 dark:bg-gray-700"></div>
                                <div class="h-1 rounded-sm bg-gray-300 dark:bg-gray-700"></div>
                            </div>
                        </div>
                        <div class="flex flex-col flex-auto border-l">
                            <div class="h-3 bg-gray-100 dark:bg-gray-800">
                                <div class="flex items-center justify-end h-full mr-2">
                                    <div class="w-1 h-1 rounded-full bg-gray-300 dark:bg-gray-700"></div>
                                </div>
                            </div>
                            <div class="flex flex-auto border-t bg-gray-50 dark:bg-gray-900"></div>
                        </div>
                    </div>
                    <div
                        class="mt-2 text-md font-medium text-center text-secondary"
                        [class.text-primary]="config.layout === 'classy'">
                        {{ 'settings_layout_classy' | translate }}
                    </div>
                </div>

                <div
                    class="flex flex-col cursor-pointer"
                    (click)="setLayout('compact')">
                    <div
                        class="flex h-20 rounded-md overflow-hidden border-2 hover:opacity-80"
                        [class.border-primary]="config.layout === 'compact'">
                        <div class="w-5 bg-gray-100 dark:bg-gray-800">
                            <div class="w-3 h-3 mt-2 mx-auto rounded-sm bg-gray-300 dark:bg-gray-700"></div>
                            <div class="flex flex-col items-center w-full mt-2 space-y-1">
                                <div class="w-3 h-2.5 rounded-sm bg-gray-300 dark:bg-gray-700"></div>
                                <div class="w-3 h-2.5 rounded-sm bg-gray-300 dark:bg-gray-700"></div>
                                <div class="w-3 h-2.5 rounded-sm bg-gray-300 dark:bg-gray-700"></div>
                            </div>
                        </div>
                        <div class="flex flex-col flex-auto border-l">
                            <div class="h-3 bg-gray-100 dark:bg-gray-800">
                                <div class="flex items-center justify-end h-full mr-1.5">
                                    <div class="w-1 h-1 ml-1 rounded-full bg-gray-300 dark:bg-gray-700"></div>
                                    <div class="w-1 h-1 ml-1 rounded-full bg-gray-300 dark:bg-gray-700"></div>
                                    <div class="w-1 h-1 ml-1 rounded-full bg-gray-300 dark:bg-gray-700"></div>
                                </div>
                            </div>
                            <div class="flex flex-auto border-t bg-gray-50 dark:bg-gray-900"></div>
                        </div>
                    </div>
                    <div
                        class="mt-2 text-md font-medium text-center text-secondary"
                        [class.text-primary]="config.layout === 'compact'">
                        {{ 'settings_layout_compact' | translate }}
                    </div>
                </div>

                <div
                    class="flex flex-col cursor-pointer"
                    (click)="setLayout('dense')">
                    <div
                        class="flex h-20 rounded-md overflow-hidden border-2 hover:opacity-80"
                        [class.border-primary]="config.layout === 'dense'">
                        <div class="w-4 bg-gray-100 dark:bg-gray-800">
                            <div class="w-2 h-2 mt-2 mx-auto rounded-sm bg-gray-300 dark:bg-gray-700"></div>
                            <div class="flex flex-col items-center w-full mt-2 space-y-1">
                                <div class="w-2 h-2 rounded-sm bg-gray-300 dark:bg-gray-700"></div>
                                <div class="w-2 h-2 rounded-sm bg-gray-300 dark:bg-gray-700"></div>
                                <div class="w-2 h-2 rounded-sm bg-gray-300 dark:bg-gray-700"></div>
                            </div>
                        </div>
                        <div class="flex flex-col flex-auto border-l">
                            <div class="h-3 bg-gray-100 dark:bg-gray-800">
                                <div class="flex items-center justify-end h-full mr-1.5">
                                    <div class="w-1 h-1 ml-1 rounded-full bg-gray-300 dark:bg-gray-700"></div>
                                    <div class="w-1 h-1 ml-1 rounded-full bg-gray-300 dark:bg-gray-700"></div>
                                    <div class="w-1 h-1 ml-1 rounded-full bg-gray-300 dark:bg-gray-700"></div>
                                </div>
                            </div>
                            <div class="flex flex-auto border-t bg-gray-50 dark:bg-gray-900"></div>
                        </div>
                    </div>
                    <div
                        class="mt-2 text-md font-medium text-center text-secondary"
                        [class.text-primary]="config.layout === 'dense'">
                        {{ 'settings_layout_dense' | translate }}
                    </div>
                </div>

                <div
                    class="flex flex-col cursor-pointer"
                    (click)="setLayout('futuristic')">
                    <div
                        class="flex h-20 rounded-md overflow-hidden border-2 hover:opacity-80"
                        [class.border-primary]="config.layout === 'futuristic'">
                        <div class="w-8 bg-gray-100 dark:bg-gray-800">
                            <div class="flex flex-col flex-auto h-full py-3 px-1.5 space-y-1">
                                <div class="h-1 rounded-sm bg-gray-300 dark:bg-gray-700"></div>
                                <div class="h-1 rounded-sm bg-gray-300 dark:bg-gray-700"></div>
                                <div class="h-1 rounded-sm bg-gray-300 dark:bg-gray-700"></div>
                                <div class="flex-auto"></div>
                                <div class="h-1 rounded-sm bg-gray-300 dark:bg-gray-700"></div>
                            </div>
                        </div>
                        <div class="flex flex-col flex-auto border-l">
                            <div class="h-3 bg-gray-100 dark:bg-gray-800">
                                <div class="flex items-center justify-end h-full mr-1.5">
                                    <div class="w-1 h-1 ml-1 rounded-full bg-gray-300 dark:bg-gray-700"></div>
                                    <div class="w-1 h-1 ml-1 rounded-full bg-gray-300 dark:bg-gray-700"></div>
                                    <div class="w-1 h-1 ml-1 rounded-full bg-gray-300 dark:bg-gray-700"></div>
                                </div>
                            </div>
                            <div class="flex flex-auto border-t bg-gray-50 dark:bg-gray-900"></div>
                        </div>
                    </div>
                    <div
                        class="mt-2 text-md font-medium text-center text-secondary"
                        [class.text-primary]="config.layout === 'futuristic'">
                        {{ 'settings_layout_futuristic' | translate }}
                    </div>
                </div>

                <div
                    class="flex flex-col cursor-pointer"
                    (click)="setLayout('thin')">
                    <div
                        class="flex h-20 rounded-md overflow-hidden border-2 hover:opacity-80"
                        [class.border-primary]="config.layout === 'thin'">
                        <div class="w-3 bg-gray-100 dark:bg-gray-800">
                            <div class="w-1.5 h-1.5 mt-2 mx-auto rounded-sm bg-gray-300 dark:bg-gray-700"></div>
                            <div class="flex flex-col items-center w-full mt-2 space-y-1">
                                <div class="w-1.5 h-1.5 rounded-full bg-gray-300 dark:bg-gray-700"></div>
                                <div class="w-1.5 h-1.5 rounded-full bg-gray-300 dark:bg-gray-700"></div>
                                <div class="w-1.5 h-1.5 rounded-full bg-gray-300 dark:bg-gray-700"></div>
                                <div class="w-1.5 h-1.5 rounded-full bg-gray-300 dark:bg-gray-700"></div>
                                <div class="w-1.5 h-1.5 rounded-full bg-gray-300 dark:bg-gray-700"></div>
                            </div>
                        </div>
                        <div class="flex flex-col flex-auto border-l">
                            <div class="h-3 bg-gray-100 dark:bg-gray-800">
                                <div class="flex items-center justify-end h-full mr-1.5">
                                    <div class="w-1 h-1 ml-1 rounded-full bg-gray-300 dark:bg-gray-700"></div>
                                    <div class="w-1 h-1 ml-1 rounded-full bg-gray-300 dark:bg-gray-700"></div>
                                    <div class="w-1 h-1 ml-1 rounded-full bg-gray-300 dark:bg-gray-700"></div>
                                </div>
                            </div>
                            <div class="flex flex-auto border-t bg-gray-50 dark:bg-gray-900"></div>
                        </div>
                    </div>
                    <div
                        class="mt-2 text-md font-medium text-center text-secondary"
                        [class.text-primary]="config.layout === 'thin'">
                        {{ 'settings_layout_thin' | translate }}
                    </div>
                </div>

                <div class="col-span-2"></div>

                <div
                    class="flex flex-col cursor-pointer"
                    (click)="setLayout('centered')">
                    <div
                        class="flex h-20 rounded-md overflow-hidden border-2 hover:opacity-80"
                        [class.border-primary]="config.layout === 'centered'">
                        <div class="flex flex-col flex-auto my-1 mx-2 border rounded-md overflow-hidden">
                            <div class="flex items-center h-3 bg-gray-100 dark:bg-gray-800">
                                <div class="flex ml-1.5">
                                    <div class="w-1 h-1 rounded-full bg-gray-300 dark:bg-gray-700"></div>
                                    <div class="w-3 h-1 ml-1 rounded-full bg-gray-300 dark:bg-gray-700"></div>
                                    <div class="w-3 h-1 ml-1 rounded-full bg-gray-300 dark:bg-gray-700"></div>
                                    <div class="w-3 h-1 ml-1 rounded-full bg-gray-300 dark:bg-gray-700"></div>
                                </div>
                                <div class="flex items-center justify-end ml-auto mr-1.5">
                                    <div class="w-1 h-1 ml-1 rounded-full bg-gray-300 dark:bg-gray-700"></div>
                                    <div class="w-1 h-1 ml-1 rounded-full bg-gray-300 dark:bg-gray-700"></div>
                                </div>
                            </div>
                            <div class="flex flex-auto border-t bg-gray-50 dark:bg-gray-900"></div>
                        </div>
                    </div>
                    <div
                        class="mt-2 text-md font-medium text-center text-secondary"
                        [class.text-primary]="config.layout === 'centered'">
                        {{ 'settings_layout_centered' | translate }}
                    </div>
                </div>

                <div
                    class="flex flex-col cursor-pointer"
                    (click)="setLayout('enterprise')">
                    <div
                        class="flex flex-col h-20 rounded-md overflow-hidden border-2 hover:opacity-80"
                        [class.border-primary]="config.layout === 'enterprise'">
                        <div class="flex items-center h-3 px-2 bg-gray-100 dark:bg-gray-800">
                            <div class="w-2 h-2 rounded-full bg-gray-300 dark:bg-gray-700"></div>
                            <div class="flex items-center justify-end ml-auto space-x-1">
                                <div class="w-1 h-1 rounded-full bg-gray-300 dark:bg-gray-700"></div>
                                <div class="w-1 h-1 rounded-full bg-gray-300 dark:bg-gray-700"></div>
                                <div class="w-1 h-1 rounded-full bg-gray-300 dark:bg-gray-700"></div>
                            </div>
                        </div>
                        <div class="flex items-center h-3 px-2 border-t border-b space-x-1 bg-gray-100 dark:bg-gray-800">
                            <div class="w-3 h-1 rounded-full bg-gray-300 dark:bg-gray-700"></div>
                            <div class="w-3 h-1 rounded-full bg-gray-300 dark:bg-gray-700"></div>
                            <div class="w-3 h-1 rounded-full bg-gray-300 dark:bg-gray-700"></div>
                            <div class="w-3 h-1 rounded-full bg-gray-300 dark:bg-gray-700"></div>
                        </div>
                        <div class="flex flex-col flex-auto my-1 mx-2 border rounded overflow-hidden">
                            <div class="flex flex-auto bg-gray-50 dark:bg-gray-900"></div>
                        </div>
                    </div>
                    <div
                        class="mt-2 text-md font-medium text-center text-secondary"
                        [class.text-primary]="config.layout === 'enterprise'">
                        {{ 'settings_layout_enterprise' | translate }}
                    </div>
                </div>

                <div
                    class="flex flex-col cursor-pointer"
                    (click)="setLayout('material')">
                    <div
                        class="flex flex-col h-20 rounded-md overflow-hidden border-2 hover:opacity-80"
                        [class.border-primary]="config.layout === 'material'">
                        <div class="flex flex-col flex-auto my-1 mx-2 border rounded overflow-hidden">
                            <div class="flex items-center h-4 px-2 bg-gray-100 dark:bg-gray-800">
                                <div class="w-2 h-2 rounded-full bg-gray-300 dark:bg-gray-700"></div>
                                <div class="flex items-center justify-end ml-auto space-x-1">
                                    <div class="w-1 h-1 rounded-full bg-gray-300 dark:bg-gray-700"></div>
                                    <div class="w-1 h-1 rounded-full bg-gray-300 dark:bg-gray-700"></div>
                                    <div class="w-1 h-1 rounded-full bg-gray-300 dark:bg-gray-700"></div>
                                </div>
                            </div>
                            <div class="flex items-center h-2 px-2 space-x-1 bg-gray-100 dark:bg-gray-800">
                                <div class="w-3 h-1 rounded-full bg-gray-300 dark:bg-gray-700"></div>
                                <div class="w-3 h-1 rounded-full bg-gray-300 dark:bg-gray-700"></div>
                                <div class="w-3 h-1 rounded-full bg-gray-300 dark:bg-gray-700"></div>
                                <div class="w-3 h-1 rounded-full bg-gray-300 dark:bg-gray-700"></div>
                            </div>
                            <div class="flex flex-auto border-t bg-gray-50 dark:bg-gray-900"></div>
                        </div>
                    </div>
                    <div
                        class="mt-2 text-md font-medium text-center text-secondary"
                        [class.text-primary]="config.layout === 'material'">
                        {{ 'settings_layout_material' | translate }}
                    </div>
                </div>

                <div
                    class="flex flex-col cursor-pointer"
                    (click)="setLayout('modern')">
                    <div
                        class="flex flex-col h-20 rounded-md overflow-hidden border-2 hover:opacity-80"
                        [class.border-primary]="config.layout === 'modern'">
                        <div class="flex items-center h-4 px-2 border-b bg-gray-100 dark:bg-gray-800">
                            <div class="w-2 h-2 rounded-full bg-gray-300 dark:bg-gray-700"></div>
                            <div class="flex items-center h-3 ml-2 space-x-1">
                                <div class="w-3 h-1 rounded-full bg-gray-300 dark:bg-gray-700"></div>
                                <div class="w-3 h-1 rounded-full bg-gray-300 dark:bg-gray-700"></div>
                                <div class="w-3 h-1 rounded-full bg-gray-300 dark:bg-gray-700"></div>
                            </div>
                            <div class="flex items-center justify-end ml-auto space-x-1">
                                <div class="w-1 h-1 rounded-full bg-gray-300 dark:bg-gray-700"></div>
                                <div class="w-1 h-1 rounded-full bg-gray-300 dark:bg-gray-700"></div>
                            </div>
                        </div>
                        <div class="flex flex-col flex-auto">
                            <div class="flex flex-auto bg-gray-50 dark:bg-gray-900"></div>
                        </div>
                    </div>
                    <div
                        class="mt-2 text-md font-medium text-center text-secondary"
                        [class.text-primary]="config.layout === 'modern'">
                        {{ 'settings_layout_modern' | translate }}
                    </div>
                </div>
            </div>
        </div>
    </div>
</fuse-drawer>

--- FILE: @fwk/layout/common/settings/settings.component.ts ---

import { NgClass, NgFor } from '@angular/common';
import { Component, OnDestroy, OnInit, ViewEncapsulation } from '@angular/core';
import { MatButtonModule } from '@angular/material/button';
import { MatIconModule } from '@angular/material/icon';
import { MatTooltipModule } from '@angular/material/tooltip';
import { Router } from '@angular/router';
import { FuseDrawerComponent } from '@fuse/components/drawer';
import { FuseConfig, FuseConfigService, Scheme, Theme, Themes } from '@fuse/services/config';
import { TranslatePipe } from '@fwk/pipe/translate.pipe';

import { Subject, takeUntil } from 'rxjs';

@Component({
    selector     : 'settings',
    templateUrl  : './settings.component.html',
    styles       : [
        `
            settings {
                position: static;
                display: block;
                flex: none;
                width: auto;
            }

            @media (screen and min-width: 1280px) {

                empty-layout + settings .settings-cog {
                    right: 0 !important;
                }
            }
        `,
    ],
    encapsulation: ViewEncapsulation.None,
    standalone   : true,
    imports      : [MatIconModule, FuseDrawerComponent, MatButtonModule, NgFor, NgClass, MatTooltipModule, TranslatePipe],
})
export class SettingsComponent implements OnInit, OnDestroy
{
    config: FuseConfig;
    layout: string;
    scheme: 'dark' | 'light';
    theme: string;
    themes: Themes;
    private _unsubscribeAll: Subject<any> = new Subject<any>();

    constructor(
        private _router: Router,
        private _fuseConfigService: FuseConfigService,
    )
    {
    }

    ngOnInit(): void
    {
        this._fuseConfigService.config$
            .pipe(takeUntil(this._unsubscribeAll))
            .subscribe((config: FuseConfig) =>
            {
                this.config = config;
            });
    }

    ngOnDestroy(): void
    {
        this._unsubscribeAll.next(null);
        this._unsubscribeAll.complete();
    }

    setLayout(layout: string): void
    {
        this._router.navigate([], {
            queryParams        : {
                layout: null,
            },
            queryParamsHandling: 'merge',
        }).then(() =>
        {
            this._fuseConfigService.config = {layout};
        });
    }

    /**
     * Set the scheme on the config
     *
     * @param scheme
     */
    setScheme(scheme: Scheme): void
    {
        this._fuseConfigService.config = {scheme};
    }

    /**
     * Set the theme on the config
     *
     * @param theme
     */
    setTheme(theme: Theme): void
    {
        this._fuseConfigService.config = {theme};
    }
}

--- FILE: @fwk/layout/common/user/user.component.html ---

<div *ngIf="user?.name">
    <button mat-button [matTooltip]="'user_menu_tooltip' | translate" class="h-10 rounded-full px-2"
        [matMenuTriggerFor]="userActions">
        <div class="flex items-center justify-center gap-1">
            <span class="relative items-center flex ">
                <img class="w-7 h-7 rounded-full" *ngIf="showAvatar && user.avatar" [src]="user.avatar"
                    alt="User avatar">
                <mat-icon *ngIf="!showAvatar || !user.avatar"
                    [svgIcon]="'heroicons_outline:user'"></mat-icon>
            </span>
            <span class="text-md font-medium">{{user.name}}</span>
        </div>
    </button>

    <mat-menu [xPosition]="'before'" #userActions="matMenu" class="rounded-xl">
        <div mat-menu-item (click)="$event.stopPropagation();" class="focus:outline-none">
            <mat-button-toggle-group class="flex" [value]="config.scheme" (change)="setScheme($event.value)">
                <mat-button-toggle [value]="'light'" [matTooltip]="'theme_light_tooltip' | translate" class="flex-1">
                    <mat-icon [svgIcon]="'heroicons_outline:sun'" class="mr-0"></mat-icon>
                </mat-button-toggle>
                <mat-button-toggle [value]="'dark'" [matTooltip]="'theme_dark_tooltip' | translate" class="flex-1">
                    <mat-icon [svgIcon]="'heroicons_outline:moon'" class="mr-0"></mat-icon>
                </mat-button-toggle>
                <mat-button-toggle [value]="'auto'" [matTooltip]="'theme_auto_tooltip' | translate" class="flex-1">
                    <mat-icon [svgIcon]="'heroicons_outline:computer-desktop'" class="mr-0"></mat-icon>
                </mat-button-toggle>
            </mat-button-toggle-group>
        </div>

        <mat-divider class="my-2"></mat-divider>

        <div mat-menu-item (click)="$event.stopPropagation();" class="focus:outline-none">
            <fuse-fullscreen class="block"></fuse-fullscreen>
        </div>

        <mat-divider class="my-2"></mat-divider>
        
        <button mat-menu-item (click)="signOut()" class="text-red-500 dark:text-red-400">
            <mat-icon [svgIcon]="'heroicons_outline:arrow-right-on-rectangle'"
                class="text-red-500 dark:text-red-400"></mat-icon>
            <span>{{ 'sign_out_button' | translate }}</span>
        </button>
    </mat-menu>
</div>

--- FILE: @fwk/layout/common/user/user.component.ts ---

import { ChangeDetectionStrategy, ChangeDetectorRef, Component, Input, OnDestroy, OnInit, ViewEncapsulation } from '@angular/core';
import { Router } from '@angular/router';
import { BooleanInput } from '@angular/cdk/coercion';
import { Subject, takeUntil } from 'rxjs';
import { User } from '@fwk/auth/user.types';
import { UserService } from '@fwk/auth/user.service';
import { AuthService } from '@fwk/auth/auth.service';

import { FuseConfig, FuseConfigService, Scheme } from '@fuse/services/config';

import { NgIf, NgClass } from '@angular/common';
import { MatButtonModule } from '@angular/material/button';
import { MatMenuModule } from '@angular/material/menu';
import { MatIconModule } from '@angular/material/icon';
import { MatDividerModule } from '@angular/material/divider';
import { MatTooltipModule } from '@angular/material/tooltip';
import { MatButtonToggleModule } from '@angular/material/button-toggle';
import { FuseFullscreenComponent } from '@fuse/components/fullscreen';
import { TranslatePipe } from '@fwk/pipe/translate.pipe';

@Component({
    selector: 'user',
    templateUrl: './user.component.html',
    encapsulation: ViewEncapsulation.None,
    changeDetection: ChangeDetectionStrategy.OnPush,
    standalone: true,
    imports: [
        NgIf,
        NgClass,
        MatButtonModule,
        MatMenuModule,
        MatIconModule,
        MatDividerModule,
        MatTooltipModule,
        FuseFullscreenComponent,
        MatButtonToggleModule,
        TranslatePipe,
    ],
})
export class UserComponent implements OnInit, OnDestroy {
    static ngAcceptInputType_showAvatar: BooleanInput;

    @Input() showAvatar: boolean = true;
    user: User;
    config: FuseConfig;
    
    private readonly THEME_STORAGE_KEY = 'fuse-theme-scheme';
    private _unsubscribeAll: Subject<any> = new Subject<any>();

    constructor(
        private _changeDetectorRef: ChangeDetectorRef,
        private _router: Router,
        private _userService: UserService,
        private _authService: AuthService,
        private _fuseConfigService: FuseConfigService,
    ) {
    }

    ngOnInit(): void {
        this._userService.user$
            .pipe(takeUntil(this._unsubscribeAll))
            .subscribe((user: User) => {
                this.user = user;
                this._changeDetectorRef.markForCheck();
            });

        this._fuseConfigService.config$
            .pipe(takeUntil(this._unsubscribeAll))
            .subscribe((config: FuseConfig) => {
                this.config = config;
                this._changeDetectorRef.markForCheck();
            });
    }

    ngOnDestroy(): void {
        this._unsubscribeAll.next(null);
        this._unsubscribeAll.complete();
    }

    signOut(): void {
        this._router.navigate(['/sign-out']);
    }

    /**
     * @param scheme
     */
    setScheme(scheme: Scheme): void {
        this._fuseConfigService.config = { scheme };

        try {
            localStorage.setItem(this.THEME_STORAGE_KEY, scheme);
        } catch (e) {
            console.error('No se pudo guardar la preferencia de tema en localStorage.', e);
        }
    }
}

--- FILE: @fwk/layout/layout.component.html ---

<empty-layout *ngIf="layout === 'empty'"></empty-layout>
<dense-layout *ngIf="layout === 'dense'"></dense-layout>


--- FILE: @fwk/layout/layout.component.ts ---

import { DOCUMENT, NgIf } from '@angular/common';
import { Component, Inject, OnDestroy, OnInit, Renderer2, ViewEncapsulation } from '@angular/core';
import { ActivatedRoute, NavigationEnd, Router } from '@angular/router';
import { FuseConfig, FuseConfigService } from '@fuse/services/config';
import { FuseMediaWatcherService } from '@fuse/services/media-watcher';
import { FusePlatformService } from '@fuse/services/platform';
import { FUSE_VERSION } from '@fuse/version';
import { combineLatest, filter, map, Subject, takeUntil } from 'rxjs';
import { SettingsComponent } from './common/settings/settings.component';
import { EmptyLayoutComponent } from './layouts/empty/empty.component';
import { DenseLayoutComponent } from './layouts/vertical/dense/dense.component';
@Component({
    selector     : 'layout',
    templateUrl  : './layout.component.html',
    styleUrls    : ['./layout.component.scss'],
    encapsulation: ViewEncapsulation.None,
    standalone   : true,
    imports      : [NgIf, EmptyLayoutComponent, DenseLayoutComponent, SettingsComponent],
})
export class LayoutComponent implements OnInit, OnDestroy
{
    config: FuseConfig;
    layout: string;
    scheme: 'dark' | 'light';
    theme: string;
    private _unsubscribeAll: Subject<any> = new Subject<any>();

    /**
     * Constructor
     */
    constructor(
        private _activatedRoute: ActivatedRoute,
        @Inject(DOCUMENT) private _document: any,
        private _renderer2: Renderer2,
        private _router: Router,
        private _fuseConfigService: FuseConfigService,
        private _fuseMediaWatcherService: FuseMediaWatcherService,
        private _fusePlatformService: FusePlatformService,
    )
    {
    }

    /**
     * On init
     */
    ngOnInit(): void
    {
        combineLatest([
            this._fuseConfigService.config$,
            this._fuseMediaWatcherService.onMediaQueryChange$(['(prefers-color-scheme: dark)', '(prefers-color-scheme: light)']),
        ]).pipe(
            takeUntil(this._unsubscribeAll),
            map(([config, mql]) =>
            {
                const options = {
                    scheme: config.scheme,
                    theme : config.theme,
                };

                if ( config.scheme === 'auto' )
                {
                    options.scheme = mql.breakpoints['(prefers-color-scheme: dark)'] ? 'dark' : 'light';
                }

                return options;
            }),
        ).subscribe((options) =>
        {
            this.scheme = options.scheme;
            this.theme = options.theme;

            this._updateScheme();
            this._updateTheme();
        });

        this._fuseConfigService.config$
            .pipe(takeUntil(this._unsubscribeAll))
            .subscribe((config: FuseConfig) =>
            {
                this.config = config;
                this._updateLayout();
            });

        this._router.events.pipe(
            filter(event => event instanceof NavigationEnd),
            takeUntil(this._unsubscribeAll),
        ).subscribe(() =>
        {
            this._updateLayout();
        });

        this._renderer2.setAttribute(this._document.querySelector('[ng-version]'), 'fuse-version', FUSE_VERSION);
        this._renderer2.addClass(this._document.body, this._fusePlatformService.osName);
    }

    ngOnDestroy(): void
    {
        this._unsubscribeAll.next(null);
        this._unsubscribeAll.complete();
    }

    private _updateLayout(): void
    {
        let route = this._activatedRoute;
        while ( route.firstChild )
        {
            route = route.firstChild;
        }

        this.layout = this.config.layout;

        const layoutFromQueryParam = route.snapshot.queryParamMap.get('layout');
        if ( layoutFromQueryParam )
        {
            this.layout = layoutFromQueryParam;
            if ( this.config )
            {
                this.config.layout = layoutFromQueryParam;
            }
        }

        const paths = route.pathFromRoot;
        paths.forEach((path) =>
        {
            if ( path.routeConfig && path.routeConfig.data && path.routeConfig.data.layout )
            {
                this.layout = path.routeConfig.data.layout;
            }
        });
    }

    /**
     * Update the selected scheme
     *
     * @private
     */
    private _updateScheme(): void
    {
        this._document.body.classList.remove('light', 'dark');
        this._document.body.classList.add(this.scheme);
    }

    /**
     * Update the selected theme
     *
     * @private
     */
    private _updateTheme(): void
    {
        this._document.body.classList.forEach((className: string) =>
        {
            if ( className.startsWith('theme-') )
            {
                this._document.body.classList.remove(className, className.split('-')[1]);
            }
        });

        this._document.body.classList.add(this.theme);
    }
}

--- FILE: @fwk/layout/layouts/empty/empty.component.html ---

<fuse-loading-bar></fuse-loading-bar>

<div class="flex flex-col flex-auto w-full h-screen">

    <div class="flex flex-col flex-auto">
        <router-outlet *ngIf="true"></router-outlet>
    </div>

</div>


--- FILE: @fwk/layout/layouts/empty/empty.component.ts ---

import { NgIf } from '@angular/common';
import { Component, OnDestroy, ViewEncapsulation } from '@angular/core';
import { RouterOutlet } from '@angular/router';
import { FuseLoadingBarComponent } from '@fuse/components/loading-bar';
import { Subject } from 'rxjs';

@Component({
    selector     : 'empty-layout',
    templateUrl  : './empty.component.html',
    encapsulation: ViewEncapsulation.None,
    standalone   : true,
    imports      : [FuseLoadingBarComponent, NgIf, RouterOutlet],
})
export class EmptyLayoutComponent implements OnDestroy
{
    private _unsubscribeAll: Subject<any> = new Subject<any>();

    constructor()
    {
    }


    ngOnDestroy(): void
    {
        this._unsubscribeAll.next(null);
        this._unsubscribeAll.complete();
    }
}


--- FILE: @fwk/layout/layouts/vertical/dense/dense.component.html ---

<fuse-loading-bar></fuse-loading-bar>

<fuse-vertical-navigation class="dark bg-gray-900 print:hidden" [appearance]="navigationAppearance"
    [mode]="isScreenSmall ? 'over' : 'side'" [name]="'mainNavigation'" [navigation]="navigation.default"
    [opened]="!isScreenSmall">

    <ng-container fuseVerticalNavigationContentHeader>
        <div [routerLink]="'/'" class="flex items-center cursor-pointer justify-center h-20">
            <img class="w-8" src="https://premecsa.com.ar/wp-content/uploads/2018/05/logo-pestan%CC%83a-01.png" alt="Logo image">
        </div>
    </ng-container>
    
    <ng-container fuseVerticalNavigationContentFooter>
        <div class="flex flex-col items-center justify-center w-full p-4 space-y-2">
            <button *ngIf="isDevMode" 
                    mat-icon-button
                    [routerLink]="'/dev-tools'"
                    color="accent" 
                    matTooltip="Herramientas de Desarrollo">
                <mat-icon [svgIcon]="'heroicons_outline:wrench-screwdriver'"></mat-icon>
            </button>
            
            <button class="hidden md:inline-flex" mat-icon-button (click)="toggleNavigationAppearance()">
                <mat-icon [svgIcon]="'heroicons_outline:arrows-right-left'"></mat-icon>
            </button>
        </div>
    </ng-container>
</fuse-vertical-navigation>

<div class="flex flex-col flex-auto w-full min-w-0 h-screen overflow-auto">
    <div
        class="bg-card dark:bg-transparent dark:shadow-none flex flex-0 items-center p-2 sm:px-4 print:hidden relative w-full z-49">
        <div class="flex items-center space-x-2">
            <button mat-icon-button (click)="toggleNavigation('mainNavigation')">
                <mat-icon [svgIcon]="'heroicons_outline:bars-3'"></mat-icon>
            </button>
        </div>

        <span class="w-1 h-6 mx-1 border-r border-gray-300 dark:border-gray-700"></span>

        <fwk-search-button></fwk-search-button>

        <div class="flex items-center pl-2 mr-2 ml-auto space-x-0.5 sm:space-x-2">
            <user></user>
        </div>
    </div>

    <div class="flex flex-col flex-auto">
        <router-outlet *ngIf="true"></router-outlet>
    </div>

</div>

--- FILE: @fwk/layout/layouts/vertical/dense/dense.component.ts ---

import { CommonModule } from '@angular/common';
import { Component, OnDestroy, OnInit, ViewEncapsulation } from '@angular/core';
import { ActivatedRoute, Router, RouterLink, RouterOutlet } from '@angular/router';
import { Observable, Subject, takeUntil } from 'rxjs';
import { FuseMediaWatcherService } from '@fuse/services/media-watcher';
import { FuseNavigationService, FuseVerticalNavigationComponent } from '@fuse/components/navigation';
import { Navigation } from '@fwk/navigation/navigation.types';
import { NavigationService } from '@fwk/navigation/navigation.service';
import { User } from '@fwk/auth/user.types';
import { UserService } from '@fwk/auth/user.service';
import { MatButtonModule } from '@angular/material/button';
import { MatIconModule } from '@angular/material/icon';
import { MatMenuModule } from '@angular/material/menu';
import { UserComponent } from '../../../common/user/user.component';
import { FuseLoadingBarComponent } from '@fuse/components/loading-bar';
import { environment } from 'environments/environment';
import { MatTooltipModule } from '@angular/material/tooltip';
import { SearchButtonComponent } from '../../../common/search-button/search-button.component';

@Component({
    selector: 'dense-layout',
    templateUrl: './dense.component.html',
    encapsulation: ViewEncapsulation.None,
    standalone: true,
    imports: [
        CommonModule,
        RouterOutlet,
        RouterLink, 
        FuseLoadingBarComponent,
        FuseVerticalNavigationComponent,
        MatButtonModule,
        MatIconModule,
        MatMenuModule,
        UserComponent,
        MatTooltipModule,
        SearchButtonComponent,
    ],
})
export class DenseLayoutComponent implements OnInit, OnDestroy {
    isScreenSmall: boolean;
    navigation: Navigation;
    navigationAppearance: 'default' | 'dense' = 'default';
    user$: Observable<User>; 
    isDevMode: boolean = !environment.production; 
    private _unsubscribeAll: Subject<any> = new Subject<any>();

    constructor(
        private _activatedRoute: ActivatedRoute,
        private _router: Router,
        private _navigationService: NavigationService,
        private _userService: UserService, 
        private _fuseMediaWatcherService: FuseMediaWatcherService,
        private _fuseNavigationService: FuseNavigationService,
    ) {
    }

    ngOnInit(): void {
        this._navigationService.navigation$
            .pipe(takeUntil(this._unsubscribeAll))
            .subscribe((navigation: Navigation) => {
                this.navigation = navigation;
            });

        this.user$ = this._userService.user$; 

        this._fuseMediaWatcherService.onMediaChange$
            .pipe(takeUntil(this._unsubscribeAll))
            .subscribe(({ matchingAliases }) => {
                this.isScreenSmall = !matchingAliases.includes('md');
            });
    }

    ngOnDestroy(): void {
        this._unsubscribeAll.next(null);
        this._unsubscribeAll.complete();
    }

    get currentYear(): number {
        return new Date().getFullYear();
    }

    toggleNavigation(name: string): void {
        const navigation = this._fuseNavigationService.getComponent<FuseVerticalNavigationComponent>(name);
        if (navigation) {
            navigation.toggle();
        }
    }

    toggleNavigationAppearance(): void {
        this.navigationAppearance = this.navigationAppearance === 'default' ? 'dense' : 'default';
    }
}

--- FILE: @fwk/model/common/fwk.constants.ts ---

﻿

--- FILE: @fwk/model/component-def/action-def.ts ---

﻿import { WsDef } from '../ws-def';
import { DynamicField } from '../dynamic-form/dynamic-field';
import { FormDef } from '../form-def';

export const ACTION_TYPES = {
  normal: 'normal',
  notification: 'notification',
  redirect: 'redirect',
  html_modal: 'html_modal',
  form_modal: 'form_modal',
  grid_modal: 'grid_modal',
  file_download: 'file_download',
  file_preview: 'file_preview'
};

export class ActionDef {
  actionNameKey?: string;

  actionName?: string;
  title?: string;
  icon?: string;
  form?: DynamicField<any>[];
  formDef?: FormDef;
  actionType?: string;
  actionSecurity?: string;
  htmlModal?: { attributeMapping: string };
  titleKey?: string;
  gridModal?: any;
  ws?: WsDef;
  input?: any;
  confirm?: any;
  redirect?: any;
  formKey?: string; 
}


--- FILE: @fwk/model/component-def/component-def.ts ---

﻿import { WsDef } from '../ws-def';
import { I18n } from '../i18n';
import { NavigationDef } from './navigation-def';
import { SecurityDef } from './security-def';
import { FormsDef } from './form-def';
import { ActionDef } from './action-def';
import { DashboardLayoutDef } from './dashboard-def';

export class ComponentDef {
  name!: string;
  i18n!: I18n;
  template?: string;

  formsDef?: FormsDef;
  ws?: WsDef;
  navigation?: NavigationDef;
  security?: SecurityDef;
  styleUrl?: string;
  test?: any;
  actions?: ActionDef[];
  dialogs?: any;
  dialogConfig?: any;
  dashboardConfig?: DashboardLayoutDef; 
}

--- FILE: @fwk/model/component-def/crud-def.ts ---

﻿import { ComponentDef } from './component-def';
import { FormsCrudDef } from './form-crud-def';
import { PageComponentDef } from './page-component-def';
import { GridDef } from './grid-def';
import { ActionDef } from './action-def';
import { DisplayActionsCondition } from '../display-actions-condition';

export class CrudDef extends ComponentDef {
  grid?: GridDef;
  /* 
    Estructura deprecada usar formsDef -> forms esta solo disponible para el componente visual crud
  */
  backButton?: boolean;
  forms?: FormsCrudDef;
  forceGetDetail?: boolean;
  crudActions?: ActionDef[];
  displayGlobalActions?: DisplayActionsCondition[];
  filterInMemory?: boolean;
  pagination?: {
    page: number,
    pageSize: number
  };
  cancelInitSearch?: boolean;
  serverPagination?: boolean;
  initFilter?: boolean;
  openLink?: string;
  openLinkTitle?: string;
  downloadBoleta?: boolean;
  exportCsv?: {
    type?: 'none' | 'client' | 'server';
    csvExportFileName: string,
    ws?: string
  };
  // Deprecado
  searchFields?: any;
  initSearch?: boolean;
  wsGetDetail?: string;
}


--- FILE: @fwk/model/component-def/dashboard-def.ts ---

import { WsDef } from '../ws-def';
import {
    ApexAxisChartSeries,
    ApexChart,
    ApexDataLabels,
    ApexFill,
    ApexLegend,
    ApexNonAxisChartSeries,
    ApexPlotOptions,
    ApexResponsive,
    ApexStates,
    ApexStroke,
    ApexTheme,
    ApexTitleSubtitle,
    ApexXAxis,
    ApexYAxis,
} from 'ng-apexcharts';

export type ApexChartOptions = {
    series: ApexAxisChartSeries | ApexNonAxisChartSeries;
    chart: ApexChart;
    xaxis: ApexXAxis;
    yaxis: ApexYAxis | ApexYAxis[];
    title: ApexTitleSubtitle;
    dataLabels: ApexDataLabels;
    stroke: ApexStroke;
    legend: ApexLegend;
    fill: ApexFill;
    states: ApexStates;
    theme: ApexTheme;
    plotOptions: ApexPlotOptions;
    responsive: ApexResponsive[];
    labels: string[]; 
};

export interface DashboardFilterOption {
    value: string;
    viewValue: string;
}

export interface DashboardFilterConfig {
    show: boolean;
    options: DashboardFilterOption[];
    defaultOption: string;
}

export interface ChartJsData {
    labels: string[];
    datasets: any[];
}

export interface StatData {
    mainStat: number;
    mainStatLabel: string;
    title: string;
    secondaryStat?: number;
    secondaryStatLabel?: string;
    color?: 'blue' | 'red' | 'amber' | 'green';
}

export interface DashboardWidgetDef {
    type: 'stat' | 'pie' | 'bar' | 'line' | 'donut' | 'widget-group' | 'content-card' | 'polarArea';
    size: 'full' | 'half' | 'third' | 'quarter';
    title?: string;
    titleKey?: string;
    children?: DashboardWidgetDef[];
    ws?: WsDef;
    filterConfig?: DashboardFilterConfig;
    apexChartData?: Partial<ApexChartOptions>;
    dataSource?: StatData[];
    chartJsData?: ChartJsData;
    isLoading?: boolean;
    hasError?: boolean;
    errorMessage?: string;
}

export interface DashboardLayoutDef {
    pageIdentifier: string;
    sectionTitle?: string;
    sectionTitleKey?: string;
    widgets: DashboardWidgetDef[];
}

--- FILE: @fwk/model/component-def/detail-def.ts ---

﻿import { ComponentDef } from './component-def';
import { FormDef } from '../form-def';

export class DetailDef extends ComponentDef {
    formDef!: FormDef;
}


--- FILE: @fwk/model/component-def/display-condition.ts ---

﻿import { DynamicFieldConditionIf } from '../dynamic-form/dynamic-field-condition-if';

export class DisplayCondition {
    key!: string;
    expression!: DynamicFieldConditionIf;
}


--- FILE: @fwk/model/component-def/form-crud-def.ts ---

﻿import { DynamicField } from '../dynamic-form/dynamic-field';
import { DynamicFieldBehavior } from '../dynamic-form/dynamic-field-behavior';

export class FormsCrudDef{
    filter?: DynamicField<any>[];
    filterBehavior?: DynamicFieldBehavior[];
    update?: DynamicField<any>[];
    updateBehavior?: DynamicFieldBehavior[];
    create?: DynamicField<any>[];
    createBehavior?: DynamicFieldBehavior[];
    read?: DynamicField<any>[];

    // deprecado
    validationAddURL?: string;
    validationEditURL?: string;
}


--- FILE: @fwk/model/component-def/form-def.ts ---

﻿import { FormDef } from '../form-def';

export class FormsDef{
    filter?: FormDef;
    update?: FormDef;
    create?: FormDef;
    read?: FormDef;
}


--- FILE: @fwk/model/component-def/grid-def.ts ---

﻿import { DisplayCondition } from './display-condition';
import { ActionDef } from './action-def';
import { DynamicFieldConditionIf } from '../dynamic-form/dynamic-field-condition-if';

export class GridDef {
    columnsDef: ColumnDef[];
    displayedColumns!: string[];
    displayedColumnsCondition?: DisplayCondition[];
    displayedActionsCondition?: DisplayCondition[];
    selectCondition?: DynamicFieldConditionIf;

    key?: string;
    actionHeaderClass?: string;
    actionCellClass?: string;
    columnName?: string;
    sortAllColumns?: boolean;
    deleteAction?: boolean;
    showDeleteAction?: boolean;
    actions?: ActionDef[];
    fromArrayField?: string;
    deleteTernaria?: boolean;
    columnsTernaria?: string[];
    groupActions?: boolean;
    // Deprecated use delleteAction
    deleteColumn?: any;
    titleKey?: string;
    title?: string;
}

export interface ColumnDef {
    columnDef: string;
    columnName?: string;
    columnNameKey: string;
    key?: boolean;
    columnType?: 'text' | 'date' | 'datehour' | 'number' | 'boolean' | string;

    fitContent?: boolean;
    textAlign?: 'left' | 'center' | 'right';
    wrapText?: boolean;
    headerClass?: string;
    cellClass?: string;

    id?: boolean;
    sort?: {
        disabled?: boolean;
        type?: 'asc' | 'desc';
    };
    translate?: boolean;

    singleId?: boolean;
    multiId?: boolean;
}

--- FILE: @fwk/model/component-def/html-modal-def.ts ---

﻿export class HtmlModalDef {
    attributeMapping!: string;
}

--- FILE: @fwk/model/component-def/mapping-component.ts ---

﻿export class MappingComponent{
    componentDef: any;
    styleUrl?: string;
}


--- FILE: @fwk/model/component-def/navigation-def.ts ---

﻿export class NavigationDef {
    id!: string;
    translateKey!: string;
    url!: string;
    title?: string;
    
    permission?: string;
    translate?: string;
    showMenu?: boolean;
    icon?: string;
    group?: string; 
    showInMenu?: boolean;
}

--- FILE: @fwk/model/component-def/page-component-def.ts ---

import { Type } from '@angular/core';
import { ComponentDef } from './component-def';
import { ActionDef } from './action-def';

export interface PageComponentDef extends ComponentDef {
    component: Type<any>;
    actions?: ActionDef[];
    backButton?: boolean;
    subtitleKey?: string;
}

--- FILE: @fwk/model/component-def/security-def.ts ---

﻿export class SecurityDef {
    readAccess?: string;
    updateAccess?: string;
    createAccess?: string;
    deleteAccess?: string;
}


--- FILE: @fwk/model/component-def/toolbar-comp-def.ts ---

﻿import { ComponentDef } from './component-def';
export class ContextMenu {
  key?: string;
  url?: string;
  labelKey?: string;
  label?: string;
  permission?: string;

}
export class ToolbarComponentDef extends ComponentDef {
    
  contextMenu!: ContextMenu[];

}


--- FILE: @fwk/model/dialog-fields-match.ts ---

﻿export class DialogFieldsMatch {
    fieldMatch!: string;
    fieldName!: string;
}


--- FILE: @fwk/model/display-actions-condition.ts ---

﻿import { DynamicFieldConditionIf } from "./dynamic-form/dynamic-field-condition-if";

export class DisplayActionsCondition{
    key!: string;
    expression!: DynamicFieldConditionIf;
}


--- FILE: @fwk/model/dynamic-form/dynamic-field-behavior.ts ---

﻿import { DynamicFieldCondition } from './dynamic-field-condition';

export class DynamicFieldBehavior{
  fieldKey!: string;
  condition!: DynamicFieldCondition;
}


--- FILE: @fwk/model/dynamic-form/dynamic-field-condition-if.ts ---

﻿export const GEN_CONDITION_IF = {
  changeValue: 'change_value',
};
export enum CONDITION_COMPARE {
  LIKE = 'LIKE',
  EQUALS = 'EQUALS',
  LESS = 'LESS',
  LESS_EQUALS = 'LESS-EQUALS',
  GREATER = 'GREATER',
  GREATER_EQUALS = 'GREATER-EQUALS',
  HAS_VALUE = 'HAS-VALUE',
}
export class DynamicFieldConditionIf{
  key?: string;
  value?: any;
  compare?: string;
  toField?: string;
  group?: DynamicFieldConditionIf[];
  condition?: string;
  avoidThenOnValueNull?: boolean;
}


--- FILE: @fwk/model/dynamic-form/dynamic-field-condition.ts ---

﻿import { DynamicFieldConditionIf } from './dynamic-field-condition-if';
import { ThenDynamicField } from './dynamic-field-then';


export class DynamicFieldCondition{
  if?: DynamicFieldConditionIf [];
  then?: ThenDynamicField[];
  else?: ThenDynamicField[];
}


--- FILE: @fwk/model/dynamic-form/dynamic-field-options.interface.ts ---

import { WsDef } from "../ws-def";

export interface BaseFieldOptions {
    floatLabel?: 'auto' | 'always' | 'never';
    matLabel?: string;
    restrictionKeys?: string;
    handlerSourceData?: boolean;
    fromWs?: WsDef;
    baseFilter?: boolean;
    hidden?: boolean;
}

export interface TextboxOptions extends BaseFieldOptions {
    type?: 'text' | 'tel' | 'url';
    prefix?: string;
}

export interface NumberOptions extends BaseFieldOptions {
    prefix?: string;
}

export interface SelectOptions extends BaseFieldOptions {
    fromData?: any[];
    elementValue?: string;
    elementLabel?: string;
}

export interface RadioButtonOptions extends BaseFieldOptions {
    options: { label: string, value: any }[];
}

export interface IconPickerOptions extends BaseFieldOptions {
    namespace?: string;
}

export interface AutocompleteOptions extends BaseFieldOptions {
    requiredMessage?: string;
    invalidValueMessage?: string;
    selectElementOrCleanField?: string;
    elementLabel: string;
    elementValue: string;
    useNativeFilter?: boolean;
    transferIdToField?: string;
    minTermLength?: number;
    useFormSenderFilter?: boolean;
    fromData?: any[];
    searchOnFocus?: boolean;
}

export interface PickListOptions extends BaseFieldOptions {
    titleFrom?: string;
    titleTo?: string;
    titleFromKey?: string;
    titleToKey?: string;
    elementLabel: string;
    fromData?: any[];
}

export interface SimplePickListOptions extends PickListOptions {
    compositeKey?: string[];
}

export interface DisclaimerOptions extends BaseFieldOptions {
    disclaimer?: {
        label?: string;
        labelKey?: string;
        content: string;
    };
}

export interface DatepickerOptions extends BaseFieldOptions {
    format?: string;
    withHourAndMin?: boolean;
    disabledPicker?: boolean;
}

export interface FloatOptions extends BaseFieldOptions {
    delim?: string;
    decimalMaxLength?: number;
    outputFormatDelim?: string;
}

export interface TagsOptions extends BaseFieldOptions {
    requiredMessage?: string;
    invalidValueMessage?: string;
    width?: string;
    placeholder?: string;
    inputPlaceholder?: string;
}

export interface UrlInputOptions extends BaseFieldOptions {
    requiredMessage?: string;
    invalidValueMessage?: string;
    resourceType?: 'Images' | 'Files';
}

export interface FileOptions extends BaseFieldOptions {
    acceptTypes?: string;
    width?: string;
    height?: string;
    shape?: string;
    previewField?: string;
}

export interface ColorPickerOptions extends BaseFieldOptions {
    requiredMessage?: string;
    invalidValueMessage?: string;
}

export type DynamicFieldOptions =
    | BaseFieldOptions
    | TextboxOptions
    | NumberOptions
    | SelectOptions
    | RadioButtonOptions
    | AutocompleteOptions
    | PickListOptions
    | SimplePickListOptions
    | DisclaimerOptions
    | DatepickerOptions
    | FloatOptions
    | TagsOptions
    | UrlInputOptions
    | FileOptions
    | ColorPickerOptions
    | IconPickerOptions;

--- FILE: @fwk/model/dynamic-form/dynamic-field-then.ts ---

﻿import { DynamicField } from './dynamic-field';

export class ThenDynamicField extends DynamicField<any>{
  showErrorMsgKey?: string;
  showErrorMsg?: string;
}


--- FILE: @fwk/model/dynamic-form/dynamic-field.ts ---

﻿import { ValidationDef } from '@fwk/services/dynamic-form/form.validator.service';
import { DynamicFieldOptions } from './dynamic-field-options.interface';

export const LABEL = 'label';
export const EMAIL = 'email';
export const TEXTBOX = 'textbox';
export const PASSWORD: any = 'password';
export const HIDDEN: any = 'hidden';
export const NUMBER = 'number';
export const AUTOCOMPLETE: any = 'autocomplete';
export const AUTOCOMPLETE_DESPLEGABLE: any = 'autocomplete-desplegable';
export const SELECT: any = 'select';
export const DATEPICKER: any = 'datepicker';
export const DATETIMEPICKER: any = 'datetimepicker';
export const CHECKBOX: any = 'checkbox';
export const HEADER: any = 'header';
export const TEXTAREA: any = 'textarea';
export const PICKLIST: any = 'pick-list';
export const SIMPLEPICKLIST: any = 'simple-pick-list';
export const CHIP_LIST: any = 'chip_list';
export const FILE: any = 'file';
export const RADIO_BUTTON = 'radio-button';
export const ICON_PICKER = 'icon-picker';
export const HTML_EDITOR = 'html_editor';
export const HTML = 'HTML';
export const DISCLAIMER = 'DISCLAIMER';
export const FLOAT = 'FLOAT';
export const COLOR_PICKER = 'COLOR_PICKER';
export const TAGS = 'TAGS';
export const URL_INPUT = 'URL_INPUT';
export const IMAGE_PREVIEW = 'IMAGE_PREVIEW';
export const IMAGE_PREVIEW_SRC = 'IMAGE_PREVIEW_SRC';
export const DATE_READ = 'DATE_READ';
export const DATE_TIME_READ = 'DATE_TIME_READ';

export enum CONTROL_TYPE {
  DateRead = 'date_read',
  DateTimeRead = 'date_time_read',
  Email = 'email',
  Textbox = 'textbox',
  Password = 'password',
  Hidden = 'hidden',
  Number = 'number',
  Float = 'float',
  Autocomplete = 'autocomplete',
  AutocompleteDesplegable = 'autocomplete-desplegable',
  Select = 'select',
  Datepicker = 'datepicker',
  Datetimepicker = 'datetimepicker',
  Checkbox = 'checkbox',
  Header = 'header',
  Textarea = 'textarea',
  Picklist = 'pick-list',
  SimplePicklist = 'simple-pick-list',
  ChipList = 'chip_list',
  File = 'file',
  RadioButton = 'radio-button',
  HtmlEditor = 'html_editor',
  Html = 'HTML',
  Disclaimer = 'DISCLAIMER',
  ColorPicker = 'color_picker',
  Tags = 'tags',
  UrlInput = 'url_input',
  IconPicker = 'icon-picker',
  ImagePreview = 'image_preview',
  ImagePreviewSrc = 'image_preview_src',
  Label = 'label'
}


export enum ControlTypeEnum {
  dateRead = 'DATE_READ',
  dateTimeRead = 'DATE_TIME_READ',
  email = 'EMAIL',
  textbox = 'TEXTBOX',
  password = 'PASSWORD',
  hidden = 'HIDDEN',
  number = 'NUMBER',
  float = 'FLOAT',
  autocomplete = 'AUTOCOMPLETE',
  autocomplete_desplegable = 'AUTOCOMPLETE-DESPLEGABLE',
  select = 'SELECT',
  datepicker = 'DATEPICKER',
  datetimepicker = 'DATETIMEPICKER',
  checkbox = 'CHECKBOX',
  header = 'HEADER',
  textarea = 'TEXTAREA',
  picklist = 'PICKLIST',
  simplepicklist = 'SIMPLEPICKLIST',
  file = 'FILE',
  radio_button = 'RADIO-BUTTON',
  html = 'HTML',
  html_ditor = 'HTML_EDITOR',
  color_picker = 'color_picker',
  tags = 'tags',
  url_input = 'url_input',
  image_preview = 'image_preview',
  image_preview_src = 'image_preview_src',
  label = "label"
}

export class DynamicField<T> {
  key: string;
  labelKey?: string;
  id?: boolean;

  controlType: CONTROL_TYPE | string;
  mappingQuerystring?: boolean;
  value?: T;
  label?: string;
  required?: boolean;
  disabled?: boolean;
  options?: DynamicFieldOptions;
  apiOptions?: any;
  maxLength?: any;
  minLength?: any;
  minValue?: any;
  maxValue?: any;
  length?: any;
  validation?: any;
  validations?: ValidationDef[];
  filterType?: any;
  requiredMessage?: string;
  maxLengthMessage?: string;
  minValueMessage?: string;
  maxValueMessage?: string;
  lengthMessage?: string;
  cssClass?: string;
  colSpan?: number; 

  readonly?: boolean;
  showPreview?: boolean;
  icon?: string;
  iconOpenUrl?: string;

  // Deprecated
  type?: string;
  order?: number;
  conditions?: any;
  formatType?: string;
  lengthErrorMsgKey?: string;

  constructor(options: {
    value?: T,
    key?: string,
    label?: string,
    required?: boolean,
    order?: number,
    controlType?: string,
    cssClass?: string
  } = {}) {
    this.value = options.value;
    this.key = options.key || '';
    this.label = options.label || '';
    this.required = !!options.required;
    this.order = options.order === undefined ? 1 : options.order;
    this.controlType = options.controlType || '';
    this.cssClass = options.cssClass || '';
  }
}

--- FILE: @fwk/model/dynamic-form/text-field.ts ---

﻿import { DynamicField, CONTROL_TYPE } from './dynamic-field';

interface DynamicFieldOptions<T> {
    value?: T;
    key?: string;
    label?: string;
    required?: boolean;
    order?: number;
    controlType?: string;
    cssClass?: string;
}

interface TextFieldOptions extends DynamicFieldOptions<string> {
    type?: string;
}

export class TextField extends DynamicField<string> {
    override controlType = CONTROL_TYPE.Textbox;
    type: string;

    constructor(options: TextFieldOptions = {}) {
        super(options);
        this.type = options.type || '';
    }
}

--- FILE: @fwk/model/entity.ts ---

﻿export class Entity {
    id!: number;
    singleId?: number;
    multiId?: number;
}

--- FILE: @fwk/model/field.ts ---

﻿export class Field {
    type!: string;
    name!: string;
    placeholder!: string;
    controlName!: string;
}


--- FILE: @fwk/model/form-def.ts ---

﻿import { DynamicField } from './dynamic-form/dynamic-field';
import { DynamicFieldBehavior } from './dynamic-form/dynamic-field-behavior';
import { WsDef } from './ws-def';
import { ActionDef } from './component-def/action-def';
import { DisplayActionsCondition } from './display-actions-condition';

export class FormDef{
    key?: string;
    fields?: DynamicField<any>[];
    subForms?: FormDef[];
    titleKey?: string;
    title?: string;
    fieldsBehavior?: DynamicFieldBehavior[];
    submitWs?: WsDef;
    initWs?: WsDef;
    actions?: ActionDef[];
    displayActionsCondition?: DisplayActionsCondition[];
    showSubmitContinue?: boolean = false;
    showSubmitButton?: boolean = true;
}


--- FILE: @fwk/model/i18n.ts ---

﻿import { Entity } from './entity';

export class I18n {
    name!: string;
    lang!: string;
    words: any;
    // Deprecado use words
    dictionary?: any;

    clone?(i18n: I18n){
        this.name = i18n.name;
        this.lang = i18n.lang;
        this.dictionary = i18n.dictionary;
        this.words = i18n.words;
    }
    
    translate?(key: string){
        if (key === undefined){
            return key;
        }
        const keyUp = key.toUpperCase();
        // Deprecated use words
        let list;
        if (this.dictionary){
            list = this.dictionary;
        }
        // New Implementation
        if (this.words){
            list = this.words;
        }

        if (list){
            const keyName = Object.getOwnPropertyNames(list).find(name => name.toUpperCase() === keyUp);
            if (keyName === undefined){
                return key;
            }
            return list[keyName];
        }
        return key;
    }
}


--- FILE: @fwk/model/page-component.interface.ts ---

import { ActionDef } from './component-def/action-def';

export interface CustomPageComponent {
    /**
     * @param action
     */
    onAction(action: ActionDef): void;
}

--- FILE: @fwk/model/page-entity.ts ---

﻿import { Entity } from './entity';

export class PageEntity extends Entity {
    name!: string;
}


--- FILE: @fwk/model/resetpassword.ts ---

﻿
export class UpdatePassword {
    username!: String;
    password!: String;
    newPassword!: String;
}


--- FILE: @fwk/model/response.ts ---

﻿import { Entity } from './entity';

export class Response<E> extends Entity {
    status: any;
    error: any;
    data!: E;
}


--- FILE: @fwk/model/table-def.ts ---

﻿export class TableDef {
    columnsDef: any;
    columnName!: string;
    displayedColumns!: string[];
    sortAllColumns!: boolean;
    // Deprecated use delleteAction
    deleteColumn: any;
    deleteAction!: boolean;
    actions: any;
}


--- FILE: @fwk/model/user.ts ---

﻿import { Entity } from './entity';

export class User extends Entity {
    username?: String;
    password?: String;
    name?: String;
    lastname?: String;
    email?: String;
    profiles: any;
}


--- FILE: @fwk/model/ws-def.ts ---

﻿import { DynamicField } from './dynamic-form/dynamic-field';
import { Params } from '@angular/router';

export const HTTP_METHODS = {
    post: 'POST',
    put: 'PUT',
    delete: 'DELETE',
    delete_ternaria: 'DELETE_TERNARIA',
    get: 'GET'
};

export class WsDef {
    key!: string;
    url!: string;
    confirm?: boolean;
    method?: string;
    filter?: DynamicField<any>;
    querystring?: Params;
}

--- FILE: @fwk/navigation/navigation.provider.ts ---

import { EnvironmentProviders, Provider } from '@angular/core';
import { FWK_CRUD_MODULES_LOADER, FWK_NAVIGATION_GROUPS } from '@fwk/navigation/navigation.tokens';
import { CRUD_MODULES } from 'app/core/registries/crud.registry';
import { NAVIGATION_GROUPS_MAP } from 'app/resources/navigation.groups';

export const provideAppNavigation = (): Array<Provider | EnvironmentProviders> =>
{
    return [
        {
            provide: FWK_CRUD_MODULES_LOADER,
            useValue: () => Promise.resolve(CRUD_MODULES)
        },
        {
            provide: FWK_NAVIGATION_GROUPS,
            useValue: NAVIGATION_GROUPS_MAP
        }
    ];
};

--- FILE: @fwk/navigation/navigation.service.ts ---

import { inject, Injectable } from '@angular/core';
import { from, Observable, ReplaySubject, of } from 'rxjs';
import { switchMap, tap } from 'rxjs/operators';
import { FuseNavigationItem } from '@fuse/components/navigation';
import { CrudDef } from '@fwk/model/component-def/crud-def';
import { Navigation, NavigationGroup } from './navigation.types';
import { FWK_CRUD_MODULES_LOADER, FWK_NAVIGATION_GROUPS } from './navigation.tokens';
import { AbstractAuthService } from '@fwk/auth/abstract-auth.service';

@Injectable({ providedIn: 'root' })
export class NavigationService {
    private _navigation: ReplaySubject<Navigation> = new ReplaySubject<Navigation>(1);

    private crudModulesLoader = inject(FWK_CRUD_MODULES_LOADER);
    private navigationGroups = inject(FWK_NAVIGATION_GROUPS);
    private authService = inject(AbstractAuthService);

    get navigation$(): Observable<Navigation> {
        return this._navigation.asObservable();
    }

    get(): Observable<Navigation> {
        return from(this.buildDynamicNavigation()).pipe(
            switchMap(dynamicDefaultNav => {
                const navigationData: Navigation = {
                    compact: [],
                    default: dynamicDefaultNav,
                    futuristic: [],
                    horizontal: [],
                };
                return of(navigationData);
            }),
            tap((navigation) => {
                this._navigation.next(navigation);
            }),
        );
    }

    private async loadAllCrudDefs(): Promise<CrudDef[]> {
        const crudModules = await this.crudModulesLoader();
        const loaderPromises = crudModules.map(moduleDef => moduleDef.loader());
        const loadedModules = await Promise.all(loaderPromises);

        return loadedModules.map(module => {
            const defKey = Object.keys(module).find(key => key.endsWith('_DEF'));
            return defKey ? module[defKey] : null;
        }).filter(Boolean) as CrudDef[];
    }

    private sortNavigationItems = (a: FuseNavigationItem, b: FuseNavigationItem): number => {
        const typeWeights = {
            'collapsable': 1,
            'group': 1,
            'basic': 2,
            'default': 3
        };

        const aWeight = typeWeights[a.type] || typeWeights['default'];
        const bWeight = typeWeights[b.type] || typeWeights['default'];

        if (aWeight !== bWeight) {
            return aWeight - bWeight;
        }

        return a.title.localeCompare(b.title);
    };

    private async buildDynamicNavigation(): Promise<FuseNavigationItem[]> {
        const crudDefs = await this.loadAllCrudDefs();

        const menuGeneralGroup: FuseNavigationItem = {
            id: 'menu-general',
            title: 'Menú General',
            type: 'group',
            children: [],
        };

        const collapsibleMenus = new Map<string, FuseNavigationItem>();
        this.navigationGroups.forEach((groupDef: NavigationGroup) => {
            collapsibleMenus.set(groupDef.id, {
                id: groupDef.id,
                title: groupDef.title,
                type: 'collapsable',
                icon: groupDef.icon,
                children: [],
            });
        });

        crudDefs.forEach(def => {
            const navDef = def.navigation;
            const readPermission = def.security?.readAccess;

            if (!this.authService.hasPermission(readPermission) || !navDef || navDef.showInMenu === false) {
                return;
            }

            let translatedTitle = navDef.translateKey;
            if (def.i18n && navDef.translateKey) {
                const dictionary = def.i18n.words || def.i18n.dictionary;
                if (dictionary && dictionary[navDef.translateKey]) {
                    translatedTitle = dictionary[navDef.translateKey];
                }
            }

            const navItem: FuseNavigationItem = {
                id: navDef.id,
                title: translatedTitle,
                type: 'basic',
                icon: navDef.icon,
                link: navDef.url,
            };

            if (navDef.group) {
                const groupParts = navDef.group.split('.');
                const rootGroupId = groupParts[0];
                let parentMenu = collapsibleMenus.get(rootGroupId);

                if (!parentMenu) {
                    console.warn(`[NavigationService] El grupo raíz '${rootGroupId}' no fue encontrado en NAVIGATION_GROUPS_MAP para el item '${navDef.id}'.`);
                    return;
                }

                for (let i = 1; i < groupParts.length; i++) {
                    const part = groupParts[i];
                    const subGroupId = groupParts.slice(0, i + 1).join('.');

                    let subGroup = parentMenu.children?.find(child => child.id === subGroupId);

                    if (!subGroup) {
                        subGroup = {
                            id: subGroupId,
                            title: part.charAt(0).toUpperCase() + part.slice(1).replace(/-/g, ' '),
                            type: 'collapsable',
                            children: []
                        };
                        parentMenu.children?.push(subGroup);
                        parentMenu.children?.sort(this.sortNavigationItems);
                    }
                    parentMenu = subGroup;
                }

                parentMenu.children?.push(navItem);

            }
        });

        collapsibleMenus.forEach(menu => {
            if (menu.children && menu.children.length > 1) {
                menu.children.sort(this.sortNavigationItems);
            }

            if (menu.children && menu.children.length > 0) {
                menuGeneralGroup.children?.push(menu);
            }
        });

        if (menuGeneralGroup.children && menuGeneralGroup.children.length > 1) {
            menuGeneralGroup.children.sort(this.sortNavigationItems);
        }

        return [menuGeneralGroup];
    }
}

--- FILE: @fwk/navigation/navigation.tokens.ts ---

import { InjectionToken } from '@angular/core';
import { CrudModuleDefinition } from 'app/core/registries/crud.registry';
import { NavigationGroup } from './navigation.types';

export const FWK_CRUD_MODULES_LOADER = new InjectionToken<() => Promise<CrudModuleDefinition[]>>('FWK_CRUD_MODULES_LOADER');
export const FWK_NAVIGATION_GROUPS = new InjectionToken<NavigationGroup[]>('FWK_NAVIGATION_GROUPS');

--- FILE: @fwk/navigation/navigation.types.ts ---

import { FuseNavigationItem } from '@fuse/components/navigation';

export interface Navigation
{
    compact: FuseNavigationItem[];
    default: FuseNavigationItem[];
    futuristic: FuseNavigationItem[];
    horizontal: FuseNavigationItem[];
}

export interface NavigationGroup extends FuseNavigationItem {
    id: string;
    title: string;
    type: 'group' | 'collapsable' | 'basic';
    icon?: string;
    children?: FuseNavigationItem[];
}

--- FILE: @fwk/pipe/filter.pipe.ts ---

import { Pipe, PipeTransform } from '@angular/core';

@Pipe({
    name: 'filter',
    standalone: true
})
export class FilterPipe implements PipeTransform {
    /**
     * @param items 
     * @param searchText 
     * @param propertyName
     */
    transform(items: any[], searchText: string, propertyName: string): any[] {
        if (!items) {
            return [];
        }
        if (!searchText) {
            return items;
        }
        searchText = searchText.toLowerCase();

        return items.filter(it => {
            return it[propertyName] && it[propertyName].toLowerCase().includes(searchText);
        });
    }
}

--- FILE: @fwk/pipe/sanitize-html.pipe.ts ---

import { Pipe, PipeTransform } from '@angular/core';
import { DomSanitizer, SafeHtml } from '@angular/platform-browser';

@Pipe({
    name: 'sanitizeHtml',
    standalone: true 
})
export class SanitizeHtmlPipe implements PipeTransform {
    constructor(private sanitizer: DomSanitizer) {}
    transform(value: string): SafeHtml {
        return this.sanitizer.bypassSecurityTrustHtml(value);
    }
}

--- FILE: @fwk/pipe/some.pipe.ts ---

import { Pipe, PipeTransform } from '@angular/core';

@Pipe({
    name: 'some',
    standalone: true
})
export class SomePipe implements PipeTransform {
    transform(items: any[], predicate: (item: any, ...args: any[]) => boolean, ...args: any[]): boolean {
        if (!items || !predicate) { return false; }
        return items.some(item => predicate(item, ...args));
    }
}

--- FILE: @fwk/pipe/translate.pipe.ts ---

import { Pipe, PipeTransform } from '@angular/core';
import { I18nService } from '@fwk/services/i18n-service/i18n.service';

@Pipe({
  name: 'translate',
  standalone: true,
  pure: false 
})
export class TranslatePipe implements PipeTransform {
  
  constructor(private i18nService: I18nService) {}

  transform(key: string, dictionaryName: string = 'fwk'): string {
    if (!key) {
      return '';
    }
    
    const specificDict = this.i18nService.getDictionary(dictionaryName);
    let translation = specificDict?.translate?.(key);
    
    if (!translation || translation === key) {
        const fwkDict = this.i18nService.getDictionary('fwk');
        translation = fwkDict?.translate?.(key);
    }

    return translation || key;
  }
}

--- FILE: @fwk/providers/core.provider.ts ---

import { EnvironmentProviders, Provider, APP_INITIALIZER, inject } from '@angular/core';
import { CrudRegistryService } from '@fwk/services/crud-registry.service';
import { IconsService } from '@fwk/services/icons.service';

export function crudRegistryServiceFactory(): CrudRegistryService {
    return CrudRegistryService.instance || new CrudRegistryService();
}

export const provideFwkCore = (): Array<Provider | EnvironmentProviders> =>
{
    return [
        {
            provide: CrudRegistryService,
            useFactory: crudRegistryServiceFactory
        },
        {
            provide : APP_INITIALIZER,
            useFactory: (iconsService: IconsService) => () => iconsService.load(),
            deps: [IconsService],
            multi   : true,
        },
    ];
};

--- FILE: @fwk/services/action-def-service/action-def.service.ts ---

﻿import { Injectable } from '@angular/core';
import { Observable, of, throwError } from 'rxjs';
import { map, tap, catchError, finalize, switchMap } from 'rxjs/operators';
import { MatDialog } from '@angular/material/dialog';
import { Router } from '@angular/router';

import { SpinnerService } from '../../modules/spinner/service/spinner.service';
import { GenericHttpService } from '../generic-http-service/generic-http.service';
import { FileService } from '../file/file.service';
import { DialogService } from '../dialog-service/dialog.service';
import { ComponentDefService } from '../component-def-service/component-def.service';
import { ExpressionService } from '../expression-service/expression.service';
import { LocalStorageService } from '../local-storage/local-storage.service';
import { NotificationService } from '../notification/notification.service';
import { ActionDef, ACTION_TYPES } from '../../model/component-def/action-def';
import { DisplayActionsCondition } from '../../model/display-actions-condition';
import { I18n } from '../../model/i18n';

@Injectable({
  providedIn: 'root'
})
export class ActionDefService {
  private spinnerGeneralControl: any;

  constructor(
    private spinnerService: SpinnerService,
    private genericHttpService: GenericHttpService,
    private router: Router,
    private fileService: FileService,
    private componentDefService: ComponentDefService,
    private expressionService: ExpressionService,
    private localStorageService: LocalStorageService,
    private notificationService: NotificationService,
    private dialogService: DialogService
  ) {
    this.spinnerGeneralControl = spinnerService.getControlGlobalSpinner();
  }

  getActions(conditions: DisplayActionsCondition[], actions: ActionDef[], data: any): ActionDef[] {
    if (!actions) return [];

    return actions.filter(action => {
      if (conditions) {
        const condition = conditions.find(c => c.key === action.actionNameKey);
        if (condition) {
          return this.expressionService.evaluate(condition.expression, data);
        }
      }
      return true;
    });
  }

  submitAction(action: ActionDef, entity: any, i18n: I18n, dialogConfig: any): Observable<any> {
    switch (action.actionType) {
      case ACTION_TYPES.notification:
        return this.handleNotificationAction(action);
      case ACTION_TYPES.redirect:
        return this.handleRedirectAction(action, entity);
      case ACTION_TYPES.html_modal:
        return this.handleHtmlModalAction(action, entity, i18n, dialogConfig);
      case ACTION_TYPES.form_modal:
        return this.handleFormModalAction(action, entity, i18n, dialogConfig);
      case ACTION_TYPES.grid_modal:
        return this.handleGridModalAction(action, entity);
      case ACTION_TYPES.file_download:
        return this.handleFileDownloadAction(action, entity);
      case ACTION_TYPES.file_preview:
        return this.handleFilePreviewAction(action, entity);
      default:
        return this.handleDefaultAction(action, entity);
    }
  }

  private handleNotificationAction(action: ActionDef): Observable<any> {
    const data = {
      html: action.input?.message,
      modalName: action.input?.modalName
    };
    return this.dialogService.openHtmlModal(data).afterClosed();
  }

  private handleRedirectAction(action: ActionDef, entity: any): Observable<any> {
    let url = '';
    if (action.redirect?.externalUrl) {
      url = action.input;
    } else {
      url = this.componentDefService.getUrlNavById(action.input) ?? '/';
    }

    if (action.redirect?.openTab) {
      window.open(url, '_blank')?.focus();
      return of({ success: true });
    } else {
      return of(this.router.navigateByUrl(url));
    }
  }

  private handleHtmlModalAction(action: ActionDef, entity: any, i18n: I18n, dialogConfig: any): Observable<any> {
    if (!action.htmlModal) return of(null);

    const data = {
      html: entity[action.htmlModal.attributeMapping],
      i18n: i18n,
    };
    return this.dialogService.openHtmlModal(data, dialogConfig).afterClosed();
  }

  private handleFormModalAction(action: ActionDef, entity: any, i18n: I18n, dialogConfig: any): Observable<any> {
    return this.dialogService.showFormDialog({
      i18n,
      formDef: { key: action.formKey, fields: action.form, submitWs: action.ws },
      entity: entity,
      dialogConfig: dialogConfig,
      modalName: action.actionName
    }).afterClosed();
  }

  private handleGridModalAction(action: ActionDef, entity: any): Observable<any> {
    if (action.gridModal) {
      this.dialogService.showGridModal({
        title: action.actionName,
        entities: entity[action.gridModal.fromArrayField],
        gridDef: action.gridModal.gridDef
      });
    }
    return of({ success: true });
  }

  private handleFileDownloadAction(action: ActionDef, entity: any): Observable<any> {
    this.spinnerGeneralControl.show();
    return this.fileService.downloadFileByAction(action, entity).pipe(
      catchError(e => this.handleActionError(e)),
      finalize(() => this.spinnerGeneralControl.hide())
    );
  }

  private handleFilePreviewAction(action: ActionDef, entity: any): Observable<any> {
    this.spinnerGeneralControl.show();
    return this.fileService.previewFileByAction(action, entity).pipe(
      catchError(e => this.handleActionError(e)),
      finalize(() => this.spinnerGeneralControl.hide())
    );
  }

  private handleDefaultAction(action: ActionDef, entity: any): Observable<any> {
    if (action.confirm) {
      return this.handleConfirmAction(action, entity);
    }

    if (!action.ws) return of({ error: 'No Web Service defined for this action' });

    this.spinnerGeneralControl.show();
    return this.genericHttpService.callWs(action.ws, entity).pipe(
      catchError(e => this.handleActionError(e)),
      finalize(() => this.spinnerGeneralControl.hide())
    );
  }

  private handleConfirmAction(action: ActionDef, entity: any): Observable<any> {
    const message = typeof action.confirm === 'object' ? action.confirm.message : undefined;

    return this.dialogService.showQuestionModal({
      title: action.actionName,
      message: message,
      onSubmit: () => { },
      onReject: () => { }
    }).afterClosed().pipe(
      switchMap(confirmed => {
        if (confirmed) {
          if (!action.ws) {
            const errorMsg = 'No Web Service defined for this confirm action';
            console.error(errorMsg, action);
            this.notificationService.notifyError(errorMsg);
            return of({ error: errorMsg });
          }

          this.spinnerGeneralControl.show();
          return this.genericHttpService.callWs(action.ws, entity).pipe(
            catchError(e => this.handleActionError(e)),
            finalize(() => this.spinnerGeneralControl.hide())
          );
        }
        return of(null);
      })
    );
  }

  private handleActionError(e: any): Observable<never> {
    const message = e?.error?.message ?? 'Se produjo un error al intentar realizar la acción';
    this.notificationService.notifyError(message);
    return throwError(() => new Error(message));
  }

  filterActionsByCondition(actions: ActionDef[], conditions: DisplayActionsCondition[], objList: any[]): ActionDef[] {
    if (!conditions || !actions) {
      return actions ?? [];
    }

    let filteredActions: ActionDef[] = this.localStorageService.clone(actions);
    objList.forEach(obj => {
      filteredActions = filteredActions.filter(action => {
        const condition = conditions.find(c => c.key === action.actionNameKey);
        return condition ? this.expressionService.evaluate(condition.expression, obj) : true;
      });
    });
    return filteredActions;
  }
}

--- FILE: @fwk/services/base-crud-service/base.crud.service.ts ---

﻿import { Injectable, Injector } from '@angular/core';
import { CrudService } from '../crud-service/crud.service';

@Injectable({
  providedIn: 'root'
})
export class BaseCrudService extends CrudService<any> {

  constructor(protected override injector: Injector) {
    super('', injector);
  }

  setBaseURL(url: string): void {
    this.baseUrl = url;
  }
}

--- FILE: @fwk/services/base-service/base.service.ts ---

﻿import { inject, Injector } from '@angular/core';
import { LocalStorageService } from '../local-storage/local-storage.service';
import { MessageService } from '../message/message.service';

export abstract class BaseService {

  protected messageService: MessageService;
  protected localStorageService: LocalStorageService;

  constructor(protected injector: Injector) {
     try {
        this.messageService = inject(MessageService);
        this.localStorageService = inject(LocalStorageService);
     } catch (e) {
        console.error("FALLÓ LA INYECCIÓN MANUAL. Asegúrate de que MessageService y LocalStorageService estén provistos en 'root'.", e);
        throw e;
     }
  }

  protected log(message: string) {
    if (this.messageService) {
        this.messageService.add('EService: ' + message); 
    } else {
        console.warn('MessageService no está disponible para loguear:', message);
    }
  }
}

--- FILE: @fwk/services/component-def-service/component-def.service.ts ---

﻿import { Injectable } from '@angular/core';
import { Observable, Subject, of } from 'rxjs';
import { map, switchMap, take } from 'rxjs/operators';
import { I18nService } from '../i18n-service/i18n.service';
import { FormService } from '../dynamic-form/form.service';
import { FormsDef } from '../../model/component-def/form-def';
import { LocalStorageService } from '../local-storage/local-storage.service';
import { ComponentDef } from '../../model/component-def/component-def';
import { ToolbarComponentDef } from '../../model/component-def/toolbar-comp-def';
import { CrudDef } from '../../model/component-def/crud-def';

@Injectable({
    providedIn: 'root'
})
export class ComponentDefService {
    private charged: { [key: string]: ComponentDef } = {};
    private originalComps: ComponentDef[] = [];
    private copyComps: ComponentDef[] = [];
    private componentDefObs = new Subject<ComponentDef>();
    public componentDefObs$ = this.componentDefObs.asObservable();

    constructor(
        private i18nService: I18nService,
        private localStorageService: LocalStorageService,
        private formService: FormService
    ) { }

    create(componentDef: ComponentDef): void {
        this.getByName(componentDef.name).pipe(take(1)).subscribe(existing => {
            if (!existing) {
                this.componentDefObs.next(componentDef);
            }
        });
    }

    getComponentDefByUrl(url: string): ComponentDef | undefined {
        const components = this.getComponents();
        return components?.find(c => c.navigation?.url === url);
    }

    getByName(componentName: string): Observable<ComponentDef | null> {
        if (!componentName) {
            return of(null);
        }
        if (this.charged[componentName]) {
            return of(this.localStorageService.clone(this.charged[componentName]));
        }

        const componentDef = this.findComponentInMemory(componentName);
        if (!componentDef) {
            return of(null);
        }

        if (componentDef.i18n) {
            return this.i18nService.getByName(componentDef.i18n.name).pipe(
                map(i18n => {
                    if (i18n) {
                        componentDef.i18n = i18n;
                        this.processComponentDef(componentDef);
                        this.charged[componentName] = componentDef;
                        return this.localStorageService.clone(componentDef);
                    }
                    return componentDef;
                })
            );
        } else {
            this.charged[componentName] = componentDef;
            return of(this.localStorageService.clone(componentDef));
        }
    }

    private processComponentDef(componentDef: ComponentDef): void {
        this.setUpkeysi18n(componentDef as CrudDef);
        this.setUpUrls(componentDef);
        if ('contextMenu' in componentDef) {
            this.setToolbarData(componentDef as ToolbarComponentDef);
        }
    }

    setToolbarData(componentDef: ToolbarComponentDef): void {
        componentDef.contextMenu?.forEach(ctx => {
            if (ctx.labelKey && componentDef.i18n) {
                ctx.label = componentDef.i18n?.translate?.(ctx.labelKey);
            }
        });
    }

    setUpUrls(componentDef: ComponentDef): void {
        if (componentDef.ws) {
        }
    }

    getUrlNavById(id: string): string | undefined {
        return undefined;
    }

    private findUrlInNav(id: string, navItem: any): string | undefined {
        if (navItem.id === id) {
            return navItem.url;
        }
        if (navItem.children) {
            for (const child of navItem.children) {
                const url = this.findUrlInNav(id, child);
                if (url) return url;
            }
        }
        return undefined;
    }

    getComponents(): ComponentDef[] {
        return this.localStorageService.clone(this.copyComps);
    }

    setComponentUser(components: ComponentDef[]): void {
        this.originalComps = components;
        this.resetComponent();
        this.charged = {};
    }

    resetComponent(): void {
        this.copyComps = this.localStorageService.clone(this.originalComps) ?? [];
    }


    private setUpkeysi18n(componentDef: CrudDef): void {
        if (!componentDef.i18n) return;

        if (componentDef.formsDef) {
            this.setUpkeysi18nOfFormsDef(componentDef.i18n, componentDef.formsDef);
        }
        if (componentDef.actions) {
            this.formService.setUpActionsFromI18n(componentDef.i18n, componentDef.actions);
        }
        if (componentDef.dialogs) {
            this.formService.setUpDialogsFromI18n(componentDef.i18n, componentDef.dialogs);
        }
        if (componentDef.forms) {
            if (componentDef.forms.create) this.formService.setUpFieldTextFromI18n(componentDef.i18n, componentDef.forms.create);
            if (componentDef.forms.filter) this.formService.setUpFieldTextFromI18n(componentDef.i18n, componentDef.forms.filter);
            if (componentDef.forms.read) this.formService.setUpFieldTextFromI18n(componentDef.i18n, componentDef.forms.read);
            if (componentDef.forms.update) this.formService.setUpFieldTextFromI18n(componentDef.i18n, componentDef.forms.update);
            if (componentDef.forms.updateBehavior) this.formService.setUpBehaviorTextFromI18n(componentDef.i18n, componentDef.forms.updateBehavior);
            if (componentDef.forms.createBehavior) this.formService.setUpBehaviorTextFromI18n(componentDef.i18n, componentDef.forms.createBehavior);
        }
        if (componentDef.grid) {
            this.formService.setUpkeysi18nOfGrid(componentDef.i18n, componentDef.grid);
        }
        if (componentDef.crudActions) {
            this.formService.setUpActionsFromI18n(componentDef.i18n, componentDef.crudActions);
        }
    }

    private setUpkeysi18nOfFormsDef(i18n: any, formsDef: FormsDef): void {
        if (formsDef.create) this.formService.setUpFormDef(i18n, formsDef.create);
        if (formsDef.update) this.formService.setUpFormDef(i18n, formsDef.update);
        if (formsDef.filter) this.formService.setUpFormDef(i18n, formsDef.filter);
        if (formsDef.read) this.formService.setUpFormDef(i18n, formsDef.read);
    }

    private findComponentInMemory(byName: string): ComponentDef | undefined {
        return this.copyComps?.find(e => e.name === byName);
    }

    getUserPermisos(): string[] {
        const permisos = this.localStorageService.getUserLocalStorage()?.permisos;
        return permisos ? String(permisos).split(";") : [];
    }

    hasAccess(security?: string): boolean {
        if (security == null) {
            return true;
        }
        const userPermisos = this.getUserPermisos();
        return userPermisos.includes(security);
    }

    applySecurity(component: any): void {
        const userPermisos = new Set(this.getUserPermisos());
        if (component.security?.createAccess && !userPermisos.has(component.security.createAccess)) {
            delete component.formsDef?.create;
        }
        if (component.security?.updateAccess && !userPermisos.has(component.security.updateAccess)) {
            delete component.formsDef?.update;
        }
        if (component.security?.deleteAccess && !userPermisos.has(component.security.deleteAccess)) {
            if (component.grid) {
                component.grid.deleteAction = false;
                delete component.grid.deleteColumn;
            }
        }
        if (component.grid?.actions) {
            component.grid.actions = component.grid.actions.filter((action: any) =>
                !action.actionSecurity || userPermisos.has(action.actionSecurity)
            );
        }
    }

    filterNavArrayBySecurity(navArray: any[], allowedSecurityValues: string[]): any[] {
        if (!navArray) return [];
        return navArray
            .map(nav => this.filterNavByPermission(nav, new Set(allowedSecurityValues)))
            .filter(nav => nav !== null);
    }

    private filterNavByPermission(nav: any, allowedSecurityValues: Set<string>): any | null {
        if (nav.permission && !allowedSecurityValues.has(nav.permission)) {
            return null;
        }
        const navClone = { ...nav };
        if (navClone.children) {
            navClone.children = navClone.children
                .map((child: any) => this.filterNavByPermission(child, allowedSecurityValues))
                .filter((child: any) => child !== null);

            if (navClone.children.length === 0) {
                delete navClone.children;
            }
        }
        return navClone;
    }
}

--- FILE: @fwk/services/crud-def-service/crud-def.service.ts ---

﻿import { Injectable, Injector } from '@angular/core';
import { Observable, of } from 'rxjs';
import { HttpService } from '../http-service/http.service';
import { CrudDef } from '../../model/component-def/crud-def';

export const CRUDS: CrudDef[] = [];

@Injectable({
  providedIn: 'root'
})
export class CrudDefService extends HttpService {

    constructor(protected override injector: Injector) {
        super(injector, 'cruds');
    }

    getByName(crudName: string): Observable<CrudDef | undefined> {
        const crudDef = this.findCrudDefInMemory(crudName);
        return of(crudDef);
    }

    private findCrudDefInMemory(byName: string): CrudDef | undefined {
        return CRUDS.find(crud => crud.name === byName);
    }
}

--- FILE: @fwk/services/crud-registry.service.ts ---

import { Injectable } from '@angular/core';

@Injectable({
  providedIn: 'root'
})
export class CrudRegistryService {
  public static instance: CrudRegistryService;
  private _registry: Map<string, () => Promise<any>> = new Map();

  constructor() {
    if (!CrudRegistryService.instance) {
      CrudRegistryService.instance = this;
    }
    
    return CrudRegistryService.instance;
  }

  register(name: string, loaderFn: () => Promise<any>): void {
    this._registry.set(name, loaderFn);
  }

  get(name: string): Promise<any> {
    const loader = this._registry.get(name);
    if (!loader) {
      console.error(`[FWK Registry] No se encontró un loader para el CRUD: '${name}'`);
      return Promise.reject(`No loader found for CRUD: '${name}'`);
    }
    return loader();
  }
}

--- FILE: @fwk/services/crud-service/crud.service.ts ---

﻿import { Injector } from '@angular/core';
import { Observable, of } from 'rxjs';
import { map, tap } from 'rxjs/operators';
import { HttpHeaders, HttpParams } from '@angular/common/http';
import { Entity } from '../../model/entity';
import { HttpService } from '../http-service/http.service';
import { FormService } from '../dynamic-form/form.service';
import { CRUD } from './crud';

export abstract class CrudService<E extends Entity> extends HttpService implements CRUD<E> {
    
    formService: FormService;

    constructor(baseURL: string, protected override injector: Injector) {
        super(injector, baseURL);
        this.formService = injector.get(FormService);
    }

    findAll(
        filterEntity: any = null,
        fieldsDef: any = null,
        filterInMemory: boolean = true,
        page: { page: number, pageSize: number } | null = null
    ): Observable<E[]> {

        if (filterInMemory && filterEntity && fieldsDef) {
            return super.httpGet(this.baseUrl).pipe(
                map(entities => this.applyMemoryFilter(entities, filterEntity, fieldsDef))
            );
        }

        const params = this.buildHttpParams(filterEntity, page);
        const options = params ? { params } : {};

        if (!this.baseUrl) {
            console.error('[CrudService] ¡LA URL BASE ES NULA O VACÍA! La llamada no se realizará.');
            return of([]);
        }

        return super.httpGet(this.baseUrl, options);
    }

    private buildHttpParams(filterEntity: any, page: { page: number, pageSize: number } | null): HttpParams | null {
        let params = new HttpParams();
        let hasParams = false;

        if (page) {
            params = params.append('page', page.page.toString());
            params = params.append('pageSize', page.pageSize.toString());
            hasParams = true;
        }

        if (filterEntity) {
            for (const key in filterEntity) {
                if (Object.prototype.hasOwnProperty.call(filterEntity, key)) {
                    const value = filterEntity[key];
                    if (value !== null && value !== undefined && value !== '') {
                        params = params.append(key, value);
                        hasParams = true;
                    }
                }
            }
        }
        
        return hasParams ? params : null;
    }
    
    getParametersToUrlAndPage(filterEntity: any, page: { page: number, pageSize: number }): HttpParams {
        const params = this.buildHttpParams(filterEntity, page);
        return params ?? new HttpParams();
    }
    
    getParametersToUrl(filterEntity: any): HttpParams {
        const params = this.buildHttpParams(filterEntity, null);
        return params ?? new HttpParams();
    }

    getById(id: number): Observable<E> {
        const url = `${this.baseUrl}/${id}`;
        return super.httpGet(url);
    }

    update(entity: E): Observable<E> {
        return this.httpPut(this.baseUrl, entity);
    }

    add(entity: E): Observable<E> {
        return this.httpPost(this.baseUrl, entity);
    }

    delete(entity: E | number): Observable<E> {
        const id = typeof entity === 'number' ? entity : entity.id;
        return this.httpDelete(this.baseUrl, id);
    }

    deleteAll(entities: E[]): Observable<E> {
        if (entities.length === 1) {
            return this.delete(entities[0]);
        } else {
            return this.multipleDelete(entities);
        }
    }

    deleteAllTernario(entities: E[], columnDefSingleId: string, columnDefMultiId: string): Observable<E> {
        return this.multipleDeleteTernario(entities, columnDefSingleId, columnDefMultiId);
    }

    search(term: string): Observable<E[]> {
        if (!term.trim()) {
            return of([]);
        }
        const params = new HttpParams().set('name', term);
        return this.http.get<E[]>(`${this.baseUrl}`, { params }).pipe(
            tap(data => this.log(`found entities matching "${term}"`))
        );
    }
}

--- FILE: @fwk/services/crud-service/crud.ts ---

﻿import { Observable } from 'rxjs';
import { Entity } from '../../model/entity';

export interface CRUD<E extends Entity> {
    findAll(filterEntity?: any, fieldsDef?: any, filterInMemory?: boolean, page?: { page: number, pageSize: number }): Observable<E[]>;
    getById(id: number): Observable<E>;
    update(entity: E): Observable<any>;
    add(entity: E): Observable<E>;
    delete(entity: E | number): Observable<E>;
    deleteAll(entities: E[]): Observable<E>;
    deleteAllTernario(entities: E[], columnDefSingleId: string, columnDefMultiId: string): Observable<E>;
    search(term: string): Observable<E[]>;
}

--- FILE: @fwk/services/crud-table-service/crud-table.service.ts ---

﻿import { Injectable, Injector } from '@angular/core';

@Injectable({
  providedIn: 'root'
})
export class CrudGridService{

  constructor() {
  }
}


--- FILE: @fwk/services/dialog-service/dialog.service.ts ---

﻿import { Injectable } from '@angular/core';
import { MatDialog, MatDialogConfig, MatDialogRef } from '@angular/material/dialog';
import { FormDef } from '../../model/form-def';
import { I18n } from '../../model/i18n';
import { BasicModalComponent } from '../../components/crud/basic-modal/basic-modal.component';
import { HtmlModalComponent } from '../../components/crud/html-modal/html-modal.component';
import { QuestionModalComponent, QuestionModalData } from '../../components/question-modal/question-modal.component';
import { ModalPreviewComponent } from '../../components/modal-preview/modal-preview.component';
import { GridModalComponent, GridModalData } from '../../components/grid-modal/grid-modal.component';

interface FilePreviewData {
    url: string;
    fileName: string;
    fileUsername: string;
}

@Injectable({
    providedIn: 'root'
})
export class DialogService {

    constructor(
        private dialog: MatDialog
    ) {}

    openHtmlModal<T = any>(data: any, dialogConfig?: MatDialogConfig): MatDialogRef<HtmlModalComponent, T> {
        const config: MatDialogConfig = {
            width: '80vw',
            maxWidth: '900px',
            panelClass: 'control-mat-dialog',
            ...dialogConfig,
            data: data
        };
        return this.dialog.open<HtmlModalComponent, any, T>(HtmlModalComponent, config);
    }

    showFormDialog<T = any>({ i18n, formDef, dialogConfig, entity = null, onSubmit, modalName = null }: {
        i18n: I18n;
        formDef: FormDef;
        dialogConfig?: MatDialogConfig;
        entity?: any;
        onSubmit?: (result: any) => void;
        modalName?: string | null;
    }): MatDialogRef<BasicModalComponent, T> {

        const data = {
            entity: entity,
            config: {
                formKey: formDef.key,
                form: formDef.fields,
                ws: formDef.submitWs
            },
            i18n: i18n,
            modalName: modalName,
            submit: onSubmit
        };

        const config: MatDialogConfig = {
            width: '500px',
            panelClass: 'control-mat-dialog',
            ...dialogConfig,
            data: data
        };

        return this.dialog.open<BasicModalComponent, any, T>(BasicModalComponent, config);
    }

    showQuestionModal(data: QuestionModalData): MatDialogRef<QuestionModalComponent> {
        return this.dialog.open(QuestionModalComponent, {
            width: '450px',
            maxWidth: '90vw',
            data: data
        });
    }

    showGridModal<T = any>(data: GridModalData): MatDialogRef<GridModalComponent, T> {
        const config: MatDialogConfig = {
            width: '80vw',
            maxWidth: '1024px',
            data: data
        };
        return this.dialog.open<GridModalComponent, any, T>(GridModalComponent, config);
    }

    openFilePreviewModal(fileData: FilePreviewData): MatDialogRef<ModalPreviewComponent> {
        return this.dialog.open(ModalPreviewComponent, {
            width: 'auto',
            maxWidth: '95vw',
            maxHeight: '95vh',
            panelClass: 'control-mat-dialog',
            data: fileData
        });
    }
}

--- FILE: @fwk/services/dummy-service/dummy.service.ts ---

﻿import { Injectable, Injector } from '@angular/core';
import { Observable, of } from 'rxjs';
import { LocalStorageService } from '../local-storage/local-storage.service';
import { SetUpDummyDataService } from './setup-dummy-data.service';

interface Cache {
  [url: string]: any[];
}

@Injectable({
  providedIn: 'root'
})
export class DummyService {

  private localStorageService: LocalStorageService;
  private setUpDummyDataService: SetUpDummyDataService;

  constructor(private injector: Injector) {
    this.localStorageService = this.injector.get(LocalStorageService);

    this.setUpDummyDataService = this.injector.get(SetUpDummyDataService);

    this.initializeDataIfNeeded();
  }

  private initializeDataIfNeeded(): void {
    const value = this.localStorageService.get('mock_data_storage');
    if (value == null) {
      // this.setUpDummyDataService.initializeDummyData();
      this.localStorageService.save('mock_data_storage', true);
    }
  }

  private getCache(url: string): Cache {
    let cache: Cache | null = this.localStorageService.get('dummy_service');
    if (!cache) {
      cache = {};
    }
    if (!cache[url]) {
      cache[url] = [];
    }
    return cache;
  }

  private saveCache(cache: Cache): void {
    this.localStorageService.save('dummy_service', cache);
  }

  httpGet(url: string): Observable<any[]> {
    const cache = this.getCache(url);
    const data = this.localStorageService.clone(cache[url]);
    return of(data);
  }

  httpPut(url: string, entity: { id: any }): Observable<any> {
    const cache = this.getCache(url);

    const index = cache[url].findIndex(item => item.id === entity.id);
    if (index !== -1) {
      cache[url][index] = entity;
    } else {
      cache[url].push(entity);
    }

    this.saveCache(cache);
    const data = this.localStorageService.clone(entity);
    return of(data);
  }

  httpPost(url: string, entity: { id?: any }): Observable<any> {
    const cache = this.getCache(url);

    entity.id = cache[url].length + 1;
    cache[url].push(entity);

    this.saveCache(cache);
    const data = this.localStorageService.clone(entity);
    return of(data);
  }

  httpDelete(url: string, ids: number[]): Observable<void> {
    const cache = this.getCache(url);

    if (cache[url]) {
      const idsSet = new Set(ids);
      cache[url] = cache[url].filter(el => !idsSet.has(el.id));
    }

    this.saveCache(cache);
    return of(undefined);
  }
}

--- FILE: @fwk/services/dummy-service/setup-dummy-data.service.ts ---

﻿import { Injectable } from '@angular/core';
// import { COMPONENTS } from '../../../../../main/content/pages/integration.components';
import { DummyService } from './dummy.service';

@Injectable({
  providedIn: 'root'
})
export class SetUpDummyDataService {

  constructor(private dummyService: DummyService) { }

  // public initializeDummyData(): void {
  //   const functionalities = COMPONENTS
  //     .filter(c => c.test)
  //     .map(c => c.test);

  //   functionalities.forEach(functionality => {
  //     this.setUpByIntegration(functionality);
  //   });
  // }

  // private setUpByIntegration(functionality: any): void {
  //   if (!functionality) return;

  //   functionality.forEach((integration: any) => {
  //     integration.dataset.forEach((data: any) => {
  //       this.dummyService.httpPost(integration.url, data).subscribe();
  //     });
  //   });
  // }
}

--- FILE: @fwk/services/dynamic-form/form.service.ts ---

﻿import { Injectable } from '@angular/core';
import { FormControl, FormGroup, AbstractControl, ValidationErrors } from '@angular/forms';
import { Observable } from 'rxjs';
import { debounceTime, distinctUntilChanged } from 'rxjs/operators';
import { ActivatedRoute } from '@angular/router';

import { DynamicField, CONTROL_TYPE, HIDDEN } from '../../model/dynamic-form/dynamic-field';
import { DynamicFieldBehavior } from '../../model/dynamic-form/dynamic-field-behavior';
import { DynamicFieldConditionIf } from '../../model/dynamic-form/dynamic-field-condition-if';
import { WsDef, HTTP_METHODS } from '../../model/ws-def';
import { GridDef } from '../../model/component-def/grid-def';
import { ColumnDef } from '../../model/component-def/grid-def';
import { ActionDef } from '../../model/component-def/action-def';
import { FormDef } from '../../model/form-def';
import { I18n } from '../../model/i18n';
import { PREFIX_DOMAIN_API } from 'environments/environment';

import { I18nService } from '../i18n-service/i18n.service';
import { FormValidatorService, MY_FORMATS, ValidationDef } from './form.validator.service';
import { GenericHttpService } from '../generic-http-service/generic-http.service';
import { FilterService, FILTER_TYPE } from '../filter-service/filter.service';

import { format, parseISO } from 'date-fns';
import { es } from 'date-fns/locale';
import { AutocompleteOptions, DatepickerOptions, DisclaimerOptions, FloatOptions, PickListOptions, SelectOptions } from '../../model/dynamic-form/dynamic-field-options.interface';

export interface FieldControlApi {
  field: DynamicField<any>;
  isHide(): boolean;
  hide(): void;
  setLabel(label: string): void;
  setValue(value: any): void;
  setValues(observable: Observable<any[]>): void;
  changeToRequired(): void;
  changeToAutoComplete(): void;
  changeToAutoCompleteDesplegable(): void;
  changeFieldToSelect(): void;
  changeFieldToNumber(): void;
  changeFieldToTextbox(): void;
  changeFieldToDatepicker(): void;
  changeRegexKey(regexKey: string): void;
  changeRemoveRegex(): void;
  changeMaxLength(length: number): void;
  changeMinLength(length: number): void;
  changeLength(length: number): void;
  updateByDef(def: any): void;
}

@Injectable({
  providedIn: 'root'
})
export class FormService {
  editorTemplates: any[] = [];
  i18n?: I18n;

  constructor(
    private i18nService: I18nService,
    private filterService: FilterService,
    public formValidatorService: FormValidatorService,
    private genericHttpService: GenericHttpService,
    private activatedRoute: ActivatedRoute
  ) {
    this.setupTranslations();
  }

  private setupTranslations(): void {
    this.i18nService.addI18n({
      name: 'form',
      lang: 'es',
      words: {
        required_error_message: 'El campo {0} es requerido',
        min_length_error_message: 'El campo {0} debe tener una longitud mínima de {1} caracter/es',
        max_length_error_message: 'El campo {0} debe tener una longitud máxima de {1} caracter/es',
        length_error_message: 'El campo {0} debe tener una longitud de {1} caracter/es',
        min_error_message: 'El campo {0} debe ser de un valor mínimo de {1}',
        max_error_message: 'El campo {0} debe ser de un valor máximo de {1}',
        email_format_error_message: 'El campo {0} no tiene un formato válido',
        user_error_message: 'El campo {0} solo permite letras, números, guion bajo y medio',
        spaces_and_especial_characters_error_message: 'El campo {0} solo permite letras y espacios',
        spaces_and_especial_letters_numbers_slash_dot_error_message: 'El campo {0} solo se permite letras, números, guion medio y punto',
        letter_numbers_dash_undercode_with_first_letter_message: 'El campo {0} debe comenzar con una letra y solo se permite letras, números, guion medio y bajo',
        letters_numbers_error_message: 'El campo {0} solo permite números y letras',
        datepattern_error_message: 'El campo {0} debe tener un formato: {1}',
        date_error_required_or_invalidmessage: 'El campo {0} es requerido y debe tener un formato: {1}',
        cuil_error_message: 'El campo {0} debe comenzar con 20, 23, 24 o 27.',
        cuit_error_message: 'El campo {0} debe comenzar con 20, 23, 24, 27, 30, 33 o 34',
        alias_cbu_error_message: 'El campo {0} debe ser alfanumerico incluyendo guión medio y punto. No incluye la letra Ñ',
        codigo_postal_error_message: 'El campo {0} debe ser de 4 dígitos (1234) o 1 letra, 4 dígitos y 3 letras al final (A1324CDE)',
        phone_error_message: 'El campo {0} debe contener exactamente {1} dígitos sin incluir el 0 de código de área. (Ej: 1148001234)',
        cellphone_error_message: 'El campo {0} debe contener exactamente {1} dígitos incluyendo el 15 después del código de área sin 0. (Ej: 111560001234)',
        error_message_not_set: 'Error desconocido',
        generic_error_message: 'El campo {0} es invalido'
      }
    });
    this.i18nService.getByName('form').subscribe(i18n => { this.i18n = i18n; });
  }

  private translate(key?: string): string {
    if (!key) return '';
    return this.i18n?.translate?.(key) ?? key;
  }

  setUpGridFromI18n(i18n: I18n, gridDef: GridDef): void {
    if (!gridDef) return;
    if (gridDef.titleKey) {
      gridDef.title = this.translate(gridDef.titleKey);
    }
    gridDef.columnsDef?.forEach((column: ColumnDef) => {
      if (column.columnNameKey) {
        column.columnName = this.translate(column.columnNameKey);
      }
    });
    this.setUpActionsFromI18n(i18n, gridDef.actions);
  }

  setUpActionsFromI18n(i18n: I18n, actions?: ActionDef[]): void {
    actions?.forEach(action => {
      if (action.actionNameKey) action.actionName = this.translate(action.actionNameKey);
      if (action.titleKey) {
        const translatedTitle = this.translate(action.titleKey);
        if (action.formDef) {
          action.formDef.title = translatedTitle;
        }
      }
      if (action.actionType === 'notification') {
        if (action.input.messageKey) action.input.message = this.translate(action.input.messageKey);
        if (action.input.modalNameKey) action.input.modalName = this.translate(action.input.modalNameKey);
      }
      if (action.form) this.setUpFieldTextFromI18n(i18n, action.form);

      if (action.formDef) this.setUpFormDef(i18n, action.formDef);

      if (action.gridModal) this.setUpGridFromI18n(i18n, action.gridModal.gridDef);
      if (action.confirm && typeof action.confirm === 'object' && action.confirm.messageKey) {
        action.confirm.message = this.translate(action.confirm.messageKey);
      }
    });
  }

  setUpFormDef(i18n: I18n, formDef?: FormDef): void {
    if (!formDef) return;
    if (formDef.titleKey) formDef.title = this.translate(formDef.titleKey);
    if (formDef.fields) this.setUpFieldTextFromI18n(i18n, formDef.fields);
    this.setUpActionsFromI18n(i18n, formDef.actions);
  }


  setUpkeysi18nOfGrid(i18n: I18n, gridDef: GridDef): void {
    if (gridDef) this.setUpGridFromI18n(i18n, gridDef);
  }

  setUpDialogsFromI18n(i18n: I18n, dialogs: any): void {
    if (dialogs.read) {
      if (dialogs.read.modalNameKey) dialogs.read.modalName = this.translate(dialogs.read.modalNameKey);
      dialogs.read.grids.forEach((grid: GridDef) => this.setUpGridFromI18n(i18n, grid));
      if (dialogs.read.form.fields) this.setUpFieldTextFromI18n(i18n, dialogs.read.form.fields);
      if (dialogs.read.actions) this.setUpActionsFromI18n(i18n, dialogs.read.actions);
    }
  }

  setUpFieldTextFromI18n(i18n: I18n, fields: DynamicField<any>[]): void {
    if (!fields) return;
    fields.forEach(element => {

      if (element.labelKey) {
        element.label = i18n.translate?.(element.labelKey) ?? element.labelKey;
      }

      if (element.validation) {
        if (element.validation.errorMessageKey) {
          element.validation.errorMessage = i18n.translate?.(element.validation.errorMessageKey);
        }
        if (element.validation.regexKey) {
          const regex = i18n.translate?.(element.validation.regexKey);
          if (regex !== element.validation.regexKey) {
            element.validation.regex = regex;
          }
        }
      }
      if (element.validations) {
        element.validations.forEach((validation: ValidationDef) => {
          if (validation.messageKey) {
            validation.message = i18n.translate?.(validation.messageKey);
          }
        });
      }
      this.setUpPickListTextFromI18n(i18n, element);
      this.setUpDisclaimerTextFromI18n(i18n, element);
    });
  }

  setUpDisclaimerTextFromI18n(i18n: I18n, element: DynamicField<any>): void {
    const options = element.options as DisclaimerOptions;
    if (element.controlType === CONTROL_TYPE.Disclaimer && options?.disclaimer?.labelKey) {
      options.disclaimer.label = this.translate(options.disclaimer.labelKey);
    }
  }

  private setUpPickListTextFromI18n(i18n: I18n, element: DynamicField<any>): void {
    if ([CONTROL_TYPE.Picklist, CONTROL_TYPE.SimplePicklist].includes(element.controlType as CONTROL_TYPE) && element.options) {
      const options = element.options as PickListOptions;
      if (options.titleFromKey) options.titleFrom = this.translate(options.titleFromKey);
      if (options.titleToKey) options.titleTo = this.translate(options.titleToKey);
    }
  }

  getMessageErrorValidation(form: AbstractControl, field: DynamicField<any>): string {
    return this.formValidatorService.getMessageErrorValidation(form, field);
  }

  toFormGroupEntity(entity: any, fields: DynamicField<any>[], options: any, onFieldsChanges: any): FormGroup {
    fields.forEach(field => {
      if (entity) {
        if (entity[field.key] !== undefined) {
          field.value = entity[field.key];
        } else if (field.value !== undefined) {
          entity[field.key] = field.value;
        }
      }
    });
    return this.toFormGroup(fields, options, onFieldsChanges);
  }

  toFormGroup(fields: DynamicField<any>[], options: any, onFieldsChanges: any): FormGroup {
    return this.getGroupControls(fields, options, onFieldsChanges);
  }

  getGroupControls(fields: DynamicField<any>[], options: any, onFieldsChanges: any): FormGroup {
    const params = this.activatedRoute.snapshot.queryParams;
    const form = new FormGroup({});
    const validFields = fields.filter(field => this.filterAndPrepareField(field, params));
    validFields.forEach(field => {
      const control = this.createFormControlForField(field, options);
      form.addControl(field.key, control);
      this.setUpWsDef(field, form);
      if (onFieldsChanges) {
        this.subscribeToFieldChanges(form, field, validFields, onFieldsChanges);
      }
    });
    if (onFieldsChanges) {
      onFieldsChanges.emit({ entity: this.injectToEntity({}, form, validFields), fields: validFields });
    }
    return form;
  }

  private filterAndPrepareField(field: DynamicField<any>, params: any): boolean {
    if (!this.implementedField(field)) {
      console.warn(`El tipo de campo -> '${field.controlType}' no se encuentra implementado.`);
      return false;
    }
    if (field.mappingQuerystring && params[field.key]) {
      field.value = params[field.key];
    }
    if (!field.options) field.options = {};
    if ([CONTROL_TYPE.Autocomplete, CONTROL_TYPE.AutocompleteDesplegable].includes(field.controlType as CONTROL_TYPE) && !(field.options as AutocompleteOptions).fromData) {
      (field.options as AutocompleteOptions).fromData = [];
    }
    if (field.controlType === CONTROL_TYPE.Checkbox && field.value == null) {
      field.value = false;
    }
    if (field.value && typeof field.value === 'string') {
      if (field.controlType === CONTROL_TYPE.DateRead) {
        field.value = format(parseISO(field.value), 'P', { locale: es });
      }
      if (field.controlType === CONTROL_TYPE.DateTimeRead) {
        field.value = format(parseISO(field.value), 'P p', { locale: es });
      }
    }
    return true;
  }

  private createFormControlForField(field: DynamicField<any>, options: any): FormControl {
    const formState = {
      value: field.value ?? '',
      disabled: field.disabled ?? options?.disabled ?? false
    };
    const validators = this.formValidatorService.getValidators(field);
    return new FormControl(formState, validators);
  }

  private subscribeToFieldChanges(form: FormGroup, field: DynamicField<any>, allFields: DynamicField<any>[], onFieldsChanges: any): void {
    const control = form.get(field.key);
    if (!control) return;

    control.valueChanges.subscribe(() => {
      const data = {
        fieldKey: field.key,
        entity: this.injectToEntity({}, form, allFields),
        fields: allFields
      };
      onFieldsChanges.emit(data);
    });
  }

  applyParamsToFilter(params: any, field: DynamicField<any>): void {
    if (field.mappingQuerystring && params[field.key]) {
      field.value = params[field.key];
    }
  }

  private setUpWsDef(field: DynamicField<any>, form: FormGroup): void {
    const fromWs: WsDef | undefined = field.options?.fromWs;
    if (!fromWs || ![CONTROL_TYPE.Select, CONTROL_TYPE.Autocomplete, CONTROL_TYPE.AutocompleteDesplegable, CONTROL_TYPE.Picklist, CONTROL_TYPE.SimplePicklist].includes(field.controlType as CONTROL_TYPE)) return;

    const url = new URL(fromWs.url.startsWith('http') ? fromWs.url : `${PREFIX_DOMAIN_API}${fromWs.url}`);
    const qs = fromWs.querystring;
    if (qs) {
      Object.keys(qs).forEach(key => {
        const formKey = qs[key];
        const control = form.get(formKey);
        if (control?.value) {
          url.searchParams.append(key, control.value);
        }
      });
    }
    const wsToCall: WsDef = { ...fromWs, url: url.toString(), method: HTTP_METHODS.get };
    this.genericHttpService.callWs(wsToCall).subscribe(r => {
      if (field.options) (field.options as SelectOptions).fromData = r;
    });
  }

  public implementedField(field: DynamicField<any>): boolean {
    const controlTypes = Object.values(CONTROL_TYPE) as string[];
    return controlTypes.includes(field.controlType.toLowerCase());
  }

  private disabledInputDatePicker(field: DynamicField<any>): void {
    if (field.disabled) {
      if (field.options) (field.options as DatepickerOptions).disabledPicker = true;
    } else {
      field.disabled = true;
      if (field.options) (field.options as DatepickerOptions).disabledPicker = false;
    }
  }

  resetFormWithFields(form: FormGroup, fields: DynamicField<any>[], options: any, onFieldsChanges: any): void {
    form.reset(this.getGroupControls(fields, options, onFieldsChanges));
  }

  toFormError(fields: DynamicField<any>[]): any {
    const group: any = {};
    fields.forEach(field => { group[field.key] = {}; });
    return group;
  }

  patchField(fieldKey: string, value: any, form: FormGroup): void {
    this.patchFields(form, { [fieldKey]: value });
  }

  patchFields(form: FormGroup, fields: any): void {
    Object.keys(fields).forEach(key => {
      const control = form.get(key);
      if (control) {
        control.patchValue(fields[key]);
      }
    });
  }

  addErrorToFields(form: FormGroup, errorsFields: any): void {
    Object.keys(errorsFields).forEach(key => {
      const control = form.controls[key];
      if (control) {
        control.setErrors({ 'customError': { errorMessage: errorsFields[key] } });
        control.markAsTouched();
      }
    });
  }

  getFieldControl(keyField: string, form: FormGroup, fields: DynamicField<any>[]): FieldControlApi | null {
    const field = fields.find(f => f.key === keyField);
    if (!field) return null;
    return {
      field: field,
      isHide: () => field.controlType === HIDDEN,
      hide: () => this.hideField(form, field),
      setLabel: (label: string) => { field.label = label; },
      setValue: (value: any) => this.setValueField(form, field, value),
      setValues: (observable: Observable<any[]>) => this.setValues(observable, field),
      changeToRequired: () => this.changeToRequired(form, field),
      changeToAutoComplete: () => this.changeFieldToAutocomplete(form, field),
      changeToAutoCompleteDesplegable: () => this.changeFieldToAutocompleteDesplegable(form, field),
      changeFieldToSelect: () => this.changeFieldToSelect(form, field),
      changeFieldToNumber: () => this.changeFieldToNumber(form, field),
      changeFieldToTextbox: () => this.changeFieldToTextbox(form, field),
      changeFieldToDatepicker: () => this.changeFieldToDatepicker(form, field),
      changeRegexKey: (regexKey: string) => this.changeRegexKey(form, field, regexKey),
      changeRemoveRegex: () => this.changeRemoveRegex(form, field),
      changeMaxLength: (length: number) => this.changeMaxLength(form, field, length),
      changeMinLength: (length: number) => this.changeMinLength(form, field, length),
      changeLength: (length: number) => this.changeLength(form, field, length),
      updateByDef: (def: any) => this.updateByDef(form, field, def),
    };
  }

  getEntityFromFields(fields: DynamicField<any>[]): any {
    const entity: any = {};
    fields.forEach(element => {
      if (this.implementedField(element)) {
        entity[element.key] = element.value;
        if (element.controlType === CONTROL_TYPE.Checkbox && (entity[element.key] == null)) {
          entity[element.key] = false;
        }
        if (element.controlType === CONTROL_TYPE.Number && (entity[element.key] != null && entity[element.key] !== '')) {
          entity[element.key] = Number(entity[element.key]);
        }
        if (element.id && entity.id === undefined) {
          entity.id = element.value;
        }
      }
    });
    return entity;
  }

  injectToEntity(entity: any, form: FormGroup, fields: DynamicField<any>[]): any {
    fields.forEach(element => {
      const control = form.controls[element.key];
      if (this.implementedField(element) && control) {
        const value = control.value;
        entity[element.key] = value;
        element.value = value;
        if (element.controlType === CONTROL_TYPE.Checkbox && value == null) {
          entity[element.key] = false;
        }
        if (element.controlType === CONTROL_TYPE.Float && element.options && typeof value === 'string') {
          const options = element.options as FloatOptions;
          const delim = options.delim ?? ',';
          const outputDelim = options.outputFormatDelim ?? '.';
          entity[element.key] = value.replace(delim, outputDelim);
        }
        if (element.controlType === CONTROL_TYPE.Number && (value != null && value !== '')) {
          entity[element.key] = Number(value);
        }
        if (element.id && entity.id === undefined) {
          entity.id = value;
        }
      }
    });
    return entity;
  }

  updateFieldsByField(fields: DynamicField<any>[], field: DynamicField<any>): DynamicField<any>[] {
    return fields.map(element => element.key === field.key ? field : element);
  }

  updateFormByField(form: FormGroup, field: DynamicField<any>): void {
    if (form.controls[field.key]) { }
  }

  fieldsChangesBehavior(fields: DynamicField<any>[], fieldsBehavior: DynamicFieldBehavior[], data: any, form: FormGroup): void {
    if (!fields || !fieldsBehavior || !form || !data) return;
    const entity = data.entity;
    const fieldsToChange = data.fieldKey ? [data.fieldKey] : fields.map(f => f.key);
    fieldsToChange.forEach((fieldKey: string) => this.fieldChangeBehavior(fieldKey, fieldsBehavior, entity, fields, form));
  }

  fieldChangeBehavior(fieldKey: string, fieldsBehavior: DynamicFieldBehavior[], entity: any, fields: DynamicField<any>[], form: FormGroup): void {
    fieldsBehavior
      .filter(fb => fb.fieldKey === fieldKey)
      .forEach(fieldBehavior => {
        let result = fieldBehavior.condition.if?.every(el => this.evalCondition(el, fields, entity)) ?? true;
        const fieldsToUpdate = result ? fieldBehavior.condition.then : fieldBehavior.condition.else;
        fieldsToUpdate?.forEach(fieldDef => {
          const fieldControl = this.getFieldControl(fieldDef.key, form, fields);
          fieldControl?.updateByDef(fieldDef);
          if (fieldDef.showErrorMsg) {
            this.addErrorToFields(form, { [fieldDef.key]: fieldDef.showErrorMsg });
          }
        });
      });
  }

  setEditorTemplates(): void {
    this.genericHttpService.basicGet(PREFIX_DOMAIN_API + 'TemplateContent', null, null, {})
      .subscribe({ next: r => this.editorTemplates = r });
  }

  private evalCondition(condition: DynamicFieldConditionIf, fields: DynamicField<any>[], entity: any): boolean {
    if (condition.key === undefined) return true;
    const compare = (condition.compare ?? FILTER_TYPE.EQUALS) as FILTER_TYPE;
    const field = fields.find(f => f.key === condition.key);
    if (condition.toField) {
      const entityValue = entity[condition.toField];
      const conditionValue = condition.value ?? entity[condition.key];
      if ((conditionValue == null || conditionValue === "") && condition.avoidThenOnValueNull) {
        return false;
      }
      return this.filterService.filter(entityValue, conditionValue, compare, field);
    } else {
      return this.filterService.filter(entity[condition.key], condition.value, compare, field);
    }
  }

  private setValues(observable: Observable<any[]>, field: DynamicField<any>): void {
    observable.subscribe(d => {
      if (!field.options) field.options = {};
      (field.options as SelectOptions).fromData = d;
    });
  }

  private hideField(form: FormGroup, field: DynamicField<any>): void {
    if (field.controlType !== HIDDEN) {
      this.setUndefinedField(form, field);
      field.controlType = HIDDEN;
      this.changeToUnRequired(form, field);
      this.disable(form, field);
    }
  }

  private changeToRequired(form: FormGroup, field: DynamicField<any>): void {
    if (!field.required) {
      field.required = true;
      this.updateValidators(form, field);
    }
  }

  private changeMaxLength(form: FormGroup, field: DynamicField<any>, length: number): void {
    if (field.maxLength !== length) {
      field.maxLength = length;
      this.updateValidators(form, field);
    }
  }

  private changeMinLength(form: FormGroup, field: DynamicField<any>, length: number): void {
    if (field.minLength !== length) {
      field.minLength = length;
      this.updateValidators(form, field);
    }
  }

  private changeRemoveLengths(form: FormGroup, field: DynamicField<any>): void {
    if (field.length || field.minLength || field.maxLength) {
      field.length = undefined;
      field.minLength = undefined;
      field.maxLength = undefined;
      this.updateValidators(form, field);
    }
  }

  private updateByDef(form: FormGroup, field: DynamicField<any>, def: Partial<DynamicField<any>>): void {
    let needsUpdate = false;
    const previousControlType = field.controlType;

    Object.keys(def).forEach(keyString => {
      const key = keyString as keyof DynamicField<any>;
      if (field[key] !== def[key]) {
        (field as any)[key] = def[key];
        needsUpdate = true;
      }
    });

    if (def.controlType) {
      if (def.controlType === HIDDEN && previousControlType !== HIDDEN) {
        this.hideField(form, field);
      } else if (def.controlType !== HIDDEN && previousControlType === HIDDEN) {
        this.enabled(form, field);

        if (field.required) {
          this.changeToRequired(form, field);
        }
      }
    }

    if (def.value !== undefined) this.setValueField(form, field, def.value);
    if (def.disabled !== undefined) {
      def.disabled ? this.disable(form, field) : this.enabled(form, field);
    }

    if (needsUpdate) this.updateValidators(form, field);
  }


  private changeLength(form: FormGroup, field: DynamicField<any>, length: number): void {
    if (field.length !== length) {
      field.length = length;
      this.updateValidators(form, field);
    }
  }

  private updateValidators(form: FormGroup, field: DynamicField<any>): void {
    const control = form.get(field.key);
    if (control) {
      control.setValidators(this.formValidatorService.getValidators(field));
      control.updateValueAndValidity();
    }
  }

  private changeRemoveRegex(form: FormGroup, field: DynamicField<any>): void {
    if (field.validation) {
      field.validation = undefined;
      this.updateValidators(form, field);
    }
  }

  private changeRegexKey(form: FormGroup, field: DynamicField<any>, regexKey: string): void {
    if (!field.validation) field.validation = {};
    if (field.validation.regexKey !== regexKey) {
      field.validation.regexKey = regexKey;
      this.updateValidators(form, field);
    }
  }

  private changeToUnRequired(form: FormGroup, field: DynamicField<any>): void {
    if (field.required) {
      field.required = false;
      this.updateValidators(form, field);
    }
  }

  private changeFieldControlType(form: FormGroup, field: DynamicField<any>, newType: (typeof CONTROL_TYPE)[keyof typeof CONTROL_TYPE]): void {
    if (field.controlType !== newType) {
      this.enabled(form, field);
      this.setUndefinedField(form, field);
      field.controlType = newType;
      form.get(field.key)?.reset();
    }
  }

  private changeFieldToAutocomplete(form: FormGroup, field: DynamicField<any>): void { this.changeFieldControlType(form, field, CONTROL_TYPE.Autocomplete); }
  private changeFieldToAutocompleteDesplegable(form: FormGroup, field: DynamicField<any>): void { this.changeFieldControlType(form, field, CONTROL_TYPE.AutocompleteDesplegable); }
  private changeFieldToSelect(form: FormGroup, field: DynamicField<any>): void { this.changeFieldControlType(form, field, CONTROL_TYPE.Select); }
  private changeFieldToNumber(form: FormGroup, field: DynamicField<any>): void { this.changeFieldControlType(form, field, CONTROL_TYPE.Number); }
  private changeFieldToTextbox(form: FormGroup, field: DynamicField<any>): void { this.changeFieldControlType(form, field, CONTROL_TYPE.Textbox); }
  private changeFieldToDatepicker(form: FormGroup, field: DynamicField<any>): void { this.changeFieldControlType(form, field, CONTROL_TYPE.Datepicker); }

  setUpBehaviorTextFromI18n(i18n: I18n, fieldBehavior: DynamicFieldBehavior[]): void {
    const translateMessages = (list: any[]) => {
      list.forEach(item => {
        if (item.showErrorMsgKey) {
          item.showErrorMsg = this.translate(item.showErrorMsgKey);
        }
      });
    };
    fieldBehavior?.forEach(f => {
      if (f.condition) {
        if (f.condition.then) translateMessages(f.condition.then);
        if (f.condition.else) translateMessages(f.condition.else);
      }
    });
  }

  setUndefinedField(form: FormGroup, field: DynamicField<any>): void {
    this.setValueField(form, field, undefined);
  }

  setValueField(form: FormGroup, field: DynamicField<any>, value: any): void {
    const control = form.get(field.key);
    if (control && control.value !== value) {
      field.value = value;
      (control as FormControl).patchValue(value);
    }
  }

  getField(fieldKey: string, fields: DynamicField<any>[]): DynamicField<any> | undefined {
    return fields.find(f => f.key === fieldKey);
  }

  private disable(form: FormGroup, field: DynamicField<any>): void {
    form.get(field.key)?.disable();
  }

  private enabled(form: FormGroup, field: DynamicField<any>): void {
    form.get(field.key)?.enable();
  }
}

--- FILE: @fwk/services/dynamic-form/form.validator.service.ts ---

﻿import { Injectable } from '@angular/core';
import { AbstractControl, FormControl, ValidatorFn, Validators, ValidationErrors } from '@angular/forms';
import { I18nService } from '../i18n-service/i18n.service';
import { I18n } from '../../model/i18n';
import { DynamicField, EMAIL, HIDDEN, DATEPICKER } from '../../model/dynamic-form/dynamic-field';
import { CONSTANTS } from '@fwk/utils/constants';

import { parse, isValid, differenceInYears } from 'date-fns';
import { DatepickerOptions } from '../../model/dynamic-form/dynamic-field-options.interface';

export const MY_FORMATS = {
  parse: { dateInput: 'dd/MM/yyyy', dateInputHours: 'dd/MM/yyyy HH:mm' },
  display: { dateInput: 'dd/MM/yyyy', monthYearLabel: 'MMM yyyy', dateA11yLabel: 'PP', monthYearA11yLabel: 'MMMM yyyy' },
};

export interface ValidationDef {
  key: string;
  input?: any;
  message?: string;
  messageKey?: string;
}

export const REGEX_KEY_SPACES_AND_ESPECIAL_LETTERS_NUMBERS_SLASH_DOT = 'spacesAndSpecialLettersNumbersSlashDot';
export const REGEX_KEY_SPACES_AND_ESPECIAL_LETTERS = 'spacesAndSpecialLetters';
export const REGEX_KEY_LETTERS_NUMBERS = 'lettersNumbers';
export const REGEX_KEY_CODIGO_POSTAL = 'codigoPostal';
export const REGEX_KEY_ALIAS_CBU = 'aliasCBU';
export const REGEX_KEY_CUIT = 'cuit';
export const REGEX_KEY_CUIL = 'cuil';
export const REGEX_KEY_USER = 'user';
export const REGEX_VALIDATION = 'regex';
export const OPTION_VALIDATION = 'optionRequired';
export const EQUALS_VALIDATION = 'equals';
export const GT_18_YEARS_OLD_VALIDATION = 'gt18YearsOld';
export const REGEX_KEY_EMAIL = 'email';
export const REGEX_KEY_URL = 'url';
export const REGEX_KEY_NO_WHITE_SPACES = 'whitespace';


function formatString(str: string, ...args: any[]): string {
  if (!str) return '';
  return str.replace(/{(\d+)}/g, (match, number) => {
    return typeof args[number] !== 'undefined' ? args[number] : match;
  });
}

@Injectable({
  providedIn: 'root'
})
export class FormValidatorService {
  private i18n?: I18n;

  constructor(private i18nService: I18nService) {
    this.setupTranslations();
  }

  private setupTranslations(): void {
    this.i18nService.addI18n({
      name: 'form-validator',
      lang: 'es',
      words: {
        required_error_message: 'El campo {0} es requerido',
        min_length_error_message: 'El campo {0} debe tener una longitud mínima de {1} caracter/es',
        max_length_error_message: 'El campo {0} debe tener una longitud máxima de {1} caracter/es',
        length_error_message: 'El campo {0} debe tener una longitud de {1} caracter/es',
        min_error_message: 'El campo {0} debe ser de un valor mínimo de {1} ',
        max_error_message: 'El campo {0} debe ser de un valor máximo de {1} ',
        email_format_error_message: 'El campo {0} no tiene un formato válido',
        whitespace_format_error_message: 'El campo {0} no puede iniciar con espacios.',
        user_error_message: 'El campo {0} solo permite letras, números, guion bajo y medio',
        spaces_and_especial_characters_error_message: 'El campo {0} solo permite letras y espacios',
        spaces_and_especial_letters_numbers_slash_dot_error_message: 'El campo {0} solo se permite letras, números, guion medio y punto',
        letter_numbers_dash_undercode_with_first_letter_message: 'El campo {0} debe comenzar con una letra y solo se permite letras, números, guion medio y bajo',
        only_numbers_message: 'El campo {0} solo permite números',
        letters_numbers_error_message: 'El campo {0} solo permite números y letras',
        datepattern_error_message: 'El campo {0} debe tener un formato: {1}',
        date_error_required_or_invalidmessage: 'El campo {0} es requerido y debe tener un formato: {1}',
        cuil_error_message: 'El campo {0} debe comenzar con 20, 23, 24 o 27.',
        cuit_error_message: 'El campo {0} debe comenzar con 20, 23, 24, 27, 30, 33 o 34',
        alias_cbu_error_message: 'El campo {0} debe ser alfanumerico incluyendo guión medio y punto. No incluye la letra Ñ',
        codigo_postal_error_message: 'El campo {0} debe ser de 4 dígitos (1234) o 1 letra, 4 dígitos y 3 letras al final (A1324CDE)',
        phone_error_message: 'El campo {0} debe contener exactamente {1} dígitos sin incluir el 0 de código de área. (Ej: 1148001234)',
        cellphone_error_message: 'El campo {0} debe contener exactamente {1} dígitos incluyendo el 15 después del código de área sin 0. (Ej: 111560001234)',
        error_message_not_set: 'Error desconocido',
        generic_error_message: 'El campo {0} es invalido',
        gt_18_years_old_error_message: 'Debe ser mayor de 18 años para registrarse',
        date_hour_message: 'Debe ingresar una fecha y hora valida ej: 20/08/2018 17:00',
        url_protocol_error_message: 'El campo {0} debe comenzar con http:// o https://',
        url_incomplete_error_message: 'La URL en el campo {0} está incompleta o mal formada',
        url_format_error_message: 'El campo {0} no tiene un formato válido',
      }
    });
    this.i18nService.getByName('form-validator').subscribe(i18n => { this.i18n = i18n; });
  }

  private translate(key: string, ...args: any[]): string {
    const template = this.i18n?.translate?.(key) ?? `Key '${key}' not found`;
    return formatString(template, ...args);
  }

  getMessageErrorValidation(form: AbstractControl, field: DynamicField<any>): string {
    const control = form.get(field.key);
    if (!control || !control.errors) return '';
    const errorKeys = Object.keys(control.errors);
    for (const key of errorKeys) {
      if (ERROR_MESSAGE_GENERATORS[key]) {
        return ERROR_MESSAGE_GENERATORS[key](this, field, control.errors[key]);
      }
    }
    console.warn(`Mensaje de error no definido para el error:`, control.errors);
    return this.translate('error_message_not_set');
  }

  public getValidators(field: DynamicField<any>): ValidatorFn[] {
    const validators: ValidatorFn[] = [];
    if (field.required && field.controlType !== HIDDEN) {
      validators.push(Validators.required);
    }
    if (field.controlType === EMAIL) {
      validators.push(Validators.email);
    }
    if (field.maxLength) {
      validators.push(Validators.maxLength(field.maxLength));
    }
    if (field.minLength) {
      validators.push(Validators.minLength(field.minLength));
    }
    if (field.minValue !== undefined) {
      validators.push(Validators.min(field.minValue));
    }
    if (field.maxValue !== undefined) {
      validators.push(Validators.max(field.maxValue));
    }
    if (field.length !== undefined) {
      validators.push(CUSTOMS_VALIDATORS_HELPER.length(field.length, field.required ?? false));
    }
    if (field.controlType === DATEPICKER) {
      validators.push(CUSTOMS_VALIDATORS_HELPER.date((field.options as DatepickerOptions)?.format));
    }
    if (field.validations) {
      field.validations.forEach((validation: ValidationDef) => {
        const validatorFnBuilder = VALIDATIONS_HELPER[validation.key];
        if (validatorFnBuilder) {
          const validator = validation.input ? validatorFnBuilder(validation.input, validation.message) : validatorFnBuilder();
          validators.push(validator as ValidatorFn);
        } else {
          console.warn(`Clave de validación '${validation.key}' no encontrada.`);
        }
      });
    }
    return validators;
  }
}

export const ERROR_MESSAGES_HELPER: { [key: string]: (service: FormValidatorService, field: DynamicField<any>) => string } = {
  [GT_18_YEARS_OLD_VALIDATION]: (service, field) => {
    return service['translate']('gt_18_years_old_error_message');
  }
};

const ERROR_MESSAGE_GENERATORS: { [key: string]: (service: FormValidatorService, field: DynamicField<any>, error: any) => string } = {
  'required': (service, field) => {
    const nameField = (field.label ?? field.key).toLowerCase();
    if (field['requiredMessage']) return field['requiredMessage'];
    if (field.controlType === DATEPICKER) {
      const format = (field.options as DatepickerOptions)?.format || MY_FORMATS.parse.dateInput;
      return service['translate']('date_error_required_or_invalidmessage', nameField, format);
    }
    return service['translate']('required_error_message', nameField);
  },
  'maxlength': (service, field, error) => service['translate']('max_length_error_message', (field.label ?? field.key).toLowerCase(), error.requiredLength),
  'minlength': (service, field, error) => service['translate']('min_length_error_message', (field.label ?? field.key).toLowerCase(), error.requiredLength),
  'length': (service, field) => {
    const nameField = (field.label ?? field.key).toLowerCase();
    const msgKey = field.lengthErrorMsgKey || 'length_error_message';
    return service['translate'](msgKey, nameField, field.length);
  },
  'min': (service, field, error) => service['translate']('min_error_message', (field.label ?? field.key).toLowerCase(), error.min),
  'max': (service, field, error) => service['translate']('max_error_message', (field.label ?? field.key).toLowerCase(), error.max),
  'email': (service, field) => service['translate']('email_format_error_message', (field.label ?? field.key).toLowerCase()),
  'whitespace': (service, field) => service['translate']('whitespace_format_error_message', (field.label ?? field.key).toLowerCase()),
  'pattern': (service, field) => {
    const nameField = (field.label ?? field.key).toLowerCase();
    const key = field.validation?.regexKey;
    const customMessage = field.validation?.errorMessage;
    if (customMessage) return formatString(customMessage, nameField);

    const messageKey = CONSTANTS.REGEXS.find(r => r.key === key)?.messageKey;
    if (messageKey) {
      return service['translate'](messageKey, nameField);
    }
    return service['translate']('generic_error_message', nameField);
  },
  'date': (service, field) => service['translate']('datepattern_error_message', (field.label ?? field.key).toLowerCase(), (field.options as DatepickerOptions)?.format || MY_FORMATS.display.dateInput),
  'matDatepickerParse': (service, field) => service['translate']('datepattern_error_message', (field.label ?? field.key).toLowerCase(), (field.options as DatepickerOptions)?.format || MY_FORMATS.display.dateInput),
  'customError': (_, __, error) => error.errorMessage,
  'regexError': (_, __, error) => error.errorMessage,
  'invalidProtocol': (service, field) => {
    return service['translate']('url_protocol_error_message', (field.label ?? field.key).toLowerCase());
  },
  'invalidUrlFormat': (service, field) => {
    return service['translate']('url_incomplete_error_message', (field.label ?? field.key).toLowerCase());
  },
  'invalidValue': (service, field) => {
    if (field.options && (field.options as any).invalidValueMessage) {
      return (field.options as any).invalidValueMessage;
    }
    return service['translate']('generic_error_message', (field.label ?? field.key).toLowerCase());
  },
  ...ERROR_MESSAGES_HELPER
};

export const CUSTOMS_VALIDATORS_HELPER = {
  optionRequired(): ValidatorFn { return (control: AbstractControl): { [key: string]: any } | null => !control.value ? { 'required': { requiredMessage: '' } } : null; },
  equals(input: string, errorMessage: string): ValidatorFn { return (control: AbstractControl): { [key: string]: any } | null => control.value === input ? null : { 'customError': { errorMessage: errorMessage } }; },
  date(patternDate: string = MY_FORMATS.parse.dateInput): ValidatorFn { return (control: AbstractControl): { [key: string]: any } | null => { if (!control.value || typeof control.value !== 'string') return null; const parsedDate = parse(control.value, patternDate, new Date()); return isValid(parsedDate) ? null : { 'date': true }; }; },
  gt18YearsOld(patternDate: string = MY_FORMATS.parse.dateInput): ValidatorFn { return (control: AbstractControl): { [key: string]: any } | null => { if (!control.value || typeof control.value !== 'string') return null; const parsedDate = parse(control.value, patternDate, new Date()); if (!isValid(parsedDate)) return null; return differenceInYears(new Date(), parsedDate) >= 18 ? null : { [GT_18_YEARS_OLD_VALIDATION]: true }; }; },
  regex(regex: string, errorMessage: string): ValidatorFn { return (control: AbstractControl): { [key: string]: any } | null => { if (!control.value) return null; const error = new RegExp(regex).test(control.value); return error ? null : { 'regexError': { errorMessage: errorMessage } }; }; },
  noWhitespaceValidator(): ValidatorFn { return (control: AbstractControl): { [key: string]: any } | null => { const isWhitespace = typeof control.value === 'string' && control.value.trim().length === 0; return isWhitespace && control.value.length > 0 ? { 'whitespace': true } : null; }; },
  length(length: number, required: boolean): ValidatorFn { return (control: AbstractControl): { [key: string]: any } | null => { const value = control.value; if (value === null || value === undefined) return null; const valueStr = String(value); if (valueStr.length === 0 && !required) return null; return valueStr.length !== length ? { 'length': true } : null; }; }
};

export const VALIDATIONS_HELPER: { [key: string]: (...args: any[]) => ValidatorFn | ((control: AbstractControl) => ValidationErrors | null) } = {
  [OPTION_VALIDATION]: CUSTOMS_VALIDATORS_HELPER.optionRequired,
  [REGEX_VALIDATION]: Validators.pattern,
  [EQUALS_VALIDATION]: CUSTOMS_VALIDATORS_HELPER.equals,
  [GT_18_YEARS_OLD_VALIDATION]: CUSTOMS_VALIDATORS_HELPER.gt18YearsOld,
  [REGEX_KEY_SPACES_AND_ESPECIAL_LETTERS]: () => Validators.pattern(CONSTANTS.REGEX_SPACES_AND_SPECIAL_LETTERS),
  [REGEX_KEY_ALIAS_CBU]: () => Validators.pattern(CONSTANTS.REGEX_ALIAS_CBU),
  [REGEX_KEY_USER]: () => Validators.pattern(CONSTANTS.REGEX_USER),
  [REGEX_KEY_SPACES_AND_ESPECIAL_LETTERS_NUMBERS_SLASH_DOT]: () => Validators.pattern(CONSTANTS.REGEX_SPACES_AND_SPECIAL_LETTERS_NUMBERS_SLASH_DOT),
  [REGEX_KEY_LETTERS_NUMBERS]: () => Validators.pattern(CONSTANTS.REGEX_LETTERS_NUMBERS),
  [REGEX_KEY_CODIGO_POSTAL]: () => Validators.pattern(CONSTANTS.REGEX_CODIGO_POSTAL),
  [REGEX_KEY_CUIT]: () => Validators.pattern(CONSTANTS.REGEX_CUIT),
  [REGEX_KEY_CUIL]: () => Validators.pattern(CONSTANTS.REGEX_CUIL),
  [REGEX_KEY_EMAIL]: () => Validators.email,
  [REGEX_KEY_URL]: () => Validators.pattern(CONSTANTS.REGEX_URL),
  [REGEX_KEY_NO_WHITE_SPACES]: CUSTOMS_VALIDATORS_HELPER.noWhitespaceValidator,
};

export class CustomValidator {
  static urlValidator(control: AbstractControl): { [key: string]: boolean } | null { if (!control.value) return null; const URL_REGEX = /^(https?|ftp):\/\/[^\s/$.?#].[^\s]*$/i; return URL_REGEX.test(control.value) ? null : { invalidUrl: true }; }
  static matchPassword(group: AbstractControl): { [key: string]: boolean } | null { const password = group.get('password'); const confirm = group.get('confirm'); if (!password || !confirm) return null; return password.value === confirm.value ? null : { invalidPassword: true }; }
  static numberValidator(control: AbstractControl): { [key: string]: boolean } | null { if (!control.value) return null; const NUMBER_REGEXP = /^-?[\d.]+(?:e-?\d+)?$/; return NUMBER_REGEXP.test(control.value) ? null : { invalidNumber: true }; }
  static noWhitespaceValidator(control: FormControl): { [key: string]: boolean } | null { const isWhitespace = (control.value || '').trim().length === 0; return isWhitespace && control.value.length > 0 ? { 'whitespace': true } : null; }
}

--- FILE: @fwk/services/expression-service/expression.service.ts ---

﻿import { Injectable } from '@angular/core';
import { DynamicFieldConditionIf } from '../../model/dynamic-form/dynamic-field-condition-if';
import { FILTER_TYPE } from '../filter-service/filter.service';

@Injectable({
  providedIn: 'root'
})
export class ExpressionService {

    evaluate(condition: DynamicFieldConditionIf, entity: Record<string, any>): boolean {
        if (!condition) {
            return true;
        }
        if (!entity) {
            console.error('La entidad para evaluar la condición es nula o indefinida.', { condition });
            return false;
        }

        try {
            const valueA = condition.key ? entity[condition.key] : undefined;
            const valueB = condition.value !== undefined 
                ? condition.value 
                : (condition.toField ? entity[condition.toField] : undefined);

            const compare = condition.compare?.toUpperCase() ?? FILTER_TYPE.EQUALS;

            switch (compare) {
                case FILTER_TYPE.EQUALS:
                    return valueA == valueB;
                case FILTER_TYPE.NOTEQUALS:
                    return valueA != valueB;
                case FILTER_TYPE.GREATER_EQUALS:
                    return Number(valueA) >= Number(valueB);
                case FILTER_TYPE.GREATER:
                    return Number(valueA) > Number(valueB);
                case FILTER_TYPE.LESS_EQUALS:
                    return Number(valueA) <= Number(valueB);
                case FILTER_TYPE.LESS:
                    return Number(valueA) < Number(valueB);
                case FILTER_TYPE.LIKE:
                    if (valueA === null || valueA === undefined || valueB === null || valueB === undefined) {
                        return valueA === valueB;
                    }
                    return String(valueA).toLowerCase().includes(String(valueB).toLowerCase());
                default:
                    console.warn(`Tipo de comparación no reconocido: ${compare}`);
                    return false;
            }
        } catch (e) {
            console.error('Error al evaluar la condición:', e);
            const conditionStr = JSON.stringify(condition);
            const entityStr = JSON.stringify(entity);
            throw new Error(`Error al evaluar la condición ${conditionStr} para la entidad ${entityStr}`);
        }
    }
}

--- FILE: @fwk/services/file/file.service.ts ---

﻿import { Injectable } from '@angular/core';
import { Observable, of, throwError } from 'rxjs';
import { map, tap, catchError } from 'rxjs/operators';
import { LocalStorageService } from '../local-storage/local-storage.service';
import { ActionDef, ACTION_TYPES } from '../../model/component-def/action-def';
import { HTTP_METHODS } from '../../model/ws-def';
import { GenericHttpService } from '../generic-http-service/generic-http.service';
import { DialogService } from '../dialog-service/dialog.service';

interface FileEntity {
  file: string;
  fileName: string;
  fileUsername?: string;
}

@Injectable({
  providedIn: 'root'
})
export class FileService {

  constructor(
    private localStorageService: LocalStorageService,
    private dialogService: DialogService,
    private genericHttpService: GenericHttpService
  ) { }

  downloadFileByAction(action: ActionDef, entity: Record<string, any>): Observable<void> {
    if (action.actionType !== ACTION_TYPES.file_download) {
      return of(undefined);
    }
    if (!action.ws) {
        console.error("Acción de descarga no tiene una definición de Web Service (ws).", action);
        return of(undefined);
    }
    const ws = this.localStorageService.clone(action.ws);
    ws.method = HTTP_METHODS.get;

    return this.genericHttpService.callWs(ws, entity).pipe(
      map((response: any) => {
        if (Array.isArray(response) && response.length > 0) {
          return response[0];
        }
        return response;
      }),
      tap((fileEntity: FileEntity) => this.downloadFileOctectStream(fileEntity)),
      map(() => undefined),
      catchError(error => throwError(() => error))
    );
  }

  previewFileByAction(action: ActionDef, entity: Record<string, any>): Observable<void> {
    if (action.actionType !== ACTION_TYPES.file_preview) {
      return of(undefined);
    }
    if (!action.ws) {
        console.error("Acción de previsualización no tiene una definición de Web Service (ws).", action);
        return of(undefined);
    }
    const ws = this.localStorageService.clone(action.ws);
    ws.method = HTTP_METHODS.get;

    return this.genericHttpService.callWs(ws, entity).pipe(
      map((response: any) => {
        if (Array.isArray(response) && response.length > 0) {
          return response[0];
        }
        return response;
      }),
      tap((fileEntity: FileEntity) => {
        const mimeType = this.getMimeType(fileEntity.fileName);
        const fileUrl = `data:${mimeType};base64,${fileEntity.file}`;
        this.dialogService.openFilePreviewModal({
          url: fileUrl,
          fileName: fileEntity.fileName,
          fileUsername: fileEntity.fileUsername ?? ''
        });
      }),
      map(() => undefined),
      catchError(error => throwError(() => error))
    );
  }

  private getMimeType(fileName: string): string {
    const extension = fileName.split('.').pop()?.toLowerCase() ?? '';
    const mimeTypes: { [key: string]: string } = {
      jpg: 'image/jpeg',
      jpeg: 'image/jpeg',
      png: 'image/png',
      gif: 'image/gif',
      pdf: 'application/pdf',
    };
    return mimeTypes[extension] || 'application/octet-stream';
  }

  downloadFileOctectStream(fileEntity: FileEntity): void {
    const decodedData = atob(fileEntity.file);
    const byteNumbers = new Array(decodedData.length);
    for (let i = 0; i < decodedData.length; i++) {
      byteNumbers[i] = decodedData.charCodeAt(i);
    }
    const byteArray = new Uint8Array(byteNumbers);
    const blob = new Blob([byteArray], { type: this.getMimeType(fileEntity.fileName) });
    this._downloadBlob(blob, fileEntity.fileName);
  }

  createAndDownloadBlobFile(body: any, options: BlobPropertyBag | undefined, filename: string): void {
    const blob = new Blob([body], options);
    this._downloadBlob(blob, filename);
  }

  public downloadCsv(data: any[], exportFileName: string): void {
    if (!data || data.length === 0) return;
    const csvData = this.convertToCSV(data);
    const blob = new Blob([`\uFEFF${csvData}`], { type: 'text/csv;charset=utf-8;' });
    this._downloadBlob(blob, this.createFileName(exportFileName));
  }

  private _downloadBlob(blob: Blob, filename: string): void {
    const link = document.createElement('a');
    if (link.download !== undefined) {
      const url = URL.createObjectURL(blob);
      link.setAttribute('href', url);
      link.setAttribute('download', filename);
      link.style.visibility = 'hidden';
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
    }
  }

  private convertToCSV(objArray: any[]): string {
    const headers = Object.keys(objArray[0]);
    const headerRow = headers.join(',');
    const rows = objArray.map(row =>
      headers.map(header => JSON.stringify(row[header])).join(',')
    );
    return `${headerRow}\r\n${rows.join('\r\n')}`;
  }

  private createFileName(exportFileName: string): string {
    const date = new Date();
    const dateString = date.toLocaleDateString('es-AR');
    const timeString = date.toLocaleTimeString('es-AR', { hour12: false });
    return `${exportFileName}_${dateString}_${timeString}.csv`;
  }
}

--- FILE: @fwk/services/filter-service/filter.service.ts ---

﻿import { Injectable } from '@angular/core';
import { CONTROL_TYPE } from '../../model/dynamic-form/dynamic-field';
import { MY_FORMATS } from '../dynamic-form/form.validator.service';
import { parse, isEqual, isBefore, isAfter, isSameDay } from 'date-fns';

@Injectable({
  providedIn: 'root' 
})
export class FilterService {

    public totalReg: number = 0;

    private convertValue(value: any, field: any): any {
        if (value === undefined || value === null || value === '') {
            return value;
        }

        if (field.controlType === CONTROL_TYPE.Datepicker) {
            const format = field.options?.format || MY_FORMATS.parse.dateInput;
            return parse(value, format, new Date());
        }

        return value;
    }

    filter(entityValue: any, filterValue: any, filterType: FILTER_TYPE, fieldDef: any): boolean {
        if (filterType === FILTER_TYPE.HAS_VALUE) {
            return this.filterHasValue(entityValue);
        }

        if (filterValue === null || filterValue === undefined || String(filterValue).length === 0) {
            return true;
        }

        if (entityValue === null || entityValue === undefined) {
            return false;
        }

        const convertedEntityValue = this.convertValue(entityValue, fieldDef);
        const convertedFilterValue = this.convertValue(filterValue, fieldDef);

        switch (filterType) {
            case FILTER_TYPE.LIKE:
                return this.filterIncludes(convertedEntityValue, convertedFilterValue);
            case FILTER_TYPE.EQUALS:
                return this.filterEquals(convertedEntityValue, convertedFilterValue);
            case FILTER_TYPE.NOTEQUALS:
                return !this.filterEquals(convertedEntityValue, convertedFilterValue);
            case FILTER_TYPE.LESS_EQUALS:
                return this.filterLessEquals(convertedEntityValue, convertedFilterValue);
            case FILTER_TYPE.GREATER_EQUALS:
                return this.filterGreaterEquals(convertedEntityValue, convertedFilterValue);
            case FILTER_TYPE.LESS:
                return this.filterLess(convertedEntityValue, convertedFilterValue);
            case FILTER_TYPE.GREATER:
                return this.filterGreater(convertedEntityValue, convertedFilterValue);
            default:
                console.warn('filterType -> ' + filterType + ' no existe...');
                return false;
        }
    }

    private isDate(value: any): value is Date {
        return value instanceof Date && !isNaN(value.valueOf());
    }

    private filterEquals(valueA: any, valueB: any): boolean {
        if (this.isDate(valueA) && this.isDate(valueB)) {
            return isSameDay(valueA, valueB);
        }
        if (typeof valueA === 'boolean' || typeof valueB === 'boolean') {
            return Boolean(valueA) === Boolean(valueB);
        }
        return valueA == valueB;
    }

    private filterGreaterEquals(valueA: any, valueB: any): boolean {
        if (this.isDate(valueA) && this.isDate(valueB)) {
            return isEqual(valueA, valueB) || isAfter(valueA, valueB);
        }
        return valueA >= valueB;
    }

    private filterLessEquals(valueA: any, valueB: any): boolean {
        if (this.isDate(valueA) && this.isDate(valueB)) {
            return isEqual(valueA, valueB) || isBefore(valueA, valueB);
        }
        return valueA <= valueB;
    }

    private filterLess(valueA: any, valueB: any): boolean {
        if (this.isDate(valueA) && this.isDate(valueB)) {
            return isBefore(valueA, valueB);
        }
        return valueA < valueB;
    }

    private filterGreater(valueA: any, valueB: any): boolean {
        if (this.isDate(valueA) && this.isDate(valueB)) {
            return isAfter(valueA, valueB);
        }
        return valueA > valueB;
    }

    private filterHasValue(value: any): boolean {
        return value !== null && value !== undefined && value !== '';
    }

    private filterIncludes(entityValue: any, filterValue: any): boolean {
        const valA = String(entityValue).toLowerCase();
        const valB = String(filterValue).toLowerCase();
        return valA.includes(valB);
    }
}

export const enum FILTER_TYPE {
    LIKE = 'LIKE',
    EQUALS = 'EQUALS',
    NOTEQUALS = 'NOTEQUALS',
    LESS_EQUALS = 'LESS-EQUALS',
    LESS = 'LESS',
    GREATER_EQUALS = 'GREATER-EQUALS',
    GREATER = 'GREATER',
    HAS_VALUE = 'HAS-VALUE',
}

--- FILE: @fwk/services/generic-http-service/generic-http.service.ts ---

﻿import { Injectable, Injector } from '@angular/core';
import { Observable, of } from 'rxjs';
import { HttpParams } from '@angular/common/http';
import { HttpService } from '../http-service/http.service';
import { WsDef, HTTP_METHODS } from '../../model/ws-def';

@Injectable({
    providedIn: 'root'
})
export class GenericHttpService extends HttpService {

    constructor(protected override injector: Injector) {
        super(injector, '');
    }

    basicPost(url: string, data: any): Observable<any> {
        return this.httpPost(url, data);
    }

    basicDelete(url: string, data: { id: number | string }): Observable<any> {
        return this.httpDelete(url, data.id);
    }

    basicDeleteTernaria(url: string, data: any, querystringKeys: string[]): Observable<any> {
        let finalUrl = url;
        if (querystringKeys && data) {
            const pathSegments = querystringKeys
                .map(key => data[key])
                .filter(Boolean)
                .join('/');

            if (pathSegments) {
                finalUrl = finalUrl.replace(/\/$/, '') + '/' + pathSegments;
            }
        }
        return this.httpDeleteTernaria(finalUrl);
    }

    basicPut(url: string, data: any): Observable<any> {
        return this.httpPut(url, data);
    }

    override httpGet(url: string, queryParams: { [param: string]: string | number | boolean } | HttpParams | null = null): Observable<any> {
        const options: { params?: HttpParams } = {};

        if (queryParams) {
            if (queryParams instanceof HttpParams) {
                options.params = queryParams;
            } else {
                options.params = new HttpParams({ fromObject: queryParams as { [param: string]: string | number | boolean } });
            }
        }
        return super.httpGet(url, options);
    }

    basicGet(url: string, data: any, filter: any, querystring: { [key: string]: string }): Observable<any> {
        if (data instanceof HttpParams) {
            return this.httpGet(url, data);
        }

        let queryParams: { [param: string]: string } = {};

        if (querystring && data) {
            Object.keys(querystring).forEach(key => {
                const dataKey = querystring[key];
                if (data[dataKey]) {
                    queryParams[key] = data[dataKey];
                }
            });
        }

        return this.httpGet(url, queryParams);
    }

    callWs(ws: WsDef, data: any = null): Observable<any> {
        switch (ws.method?.toUpperCase()) {
            case HTTP_METHODS.post:
                return this.basicPost(ws.url, data);
            case HTTP_METHODS.delete:
                return this.basicDelete(ws.url, data);
            case HTTP_METHODS.delete_ternaria: {
                let keys: string[] = [];
                if (Array.isArray(ws.querystring)) {
                    keys = ws.querystring;
                } else if (typeof ws.querystring === 'object' && ws.querystring !== null) {
                    keys = Object.keys(ws.querystring);
                }
                return this.basicDeleteTernaria(ws.url, data, keys);
            }
            case HTTP_METHODS.put:
                return this.basicPut(ws.url, data);
            case HTTP_METHODS.get:
                return this.basicGet(ws.url, data, ws.filter, ws.querystring ?? {});
            default:
                console.warn(`Método HTTP no reconocido: ${ws.method}`);
                return of();
        }
    }
}

--- FILE: @fwk/services/http-service/http.service.ts ---

﻿import { Injectable, Injector } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpParams, HttpErrorResponse } from '@angular/common/http';
import { Observable, of, throwError } from 'rxjs';
import { catchError, map, tap } from 'rxjs/operators';

import { BaseService } from '../base-service/base.service';
import { environment, PREFIX_DOMAIN_API } from 'environments/environment';
import { DummyService } from '../dummy-service/dummy.service';
import { FilterService, FILTER_TYPE } from '../filter-service/filter.service';
import { NotificationService } from '../notification/notification.service';
import { I18nService } from '../i18n-service/i18n.service';

@Injectable({
  providedIn: 'root'
})
export class HttpService extends BaseService {

  protected baseUrl: string;
  protected http: HttpClient;
  dummyService: any;
  filterService: FilterService;
  notificationService: NotificationService;
  i18nService: I18nService;

  constructor(protected override injector: Injector, baseURL: string) {
    super(injector);
    this.http = injector.get(HttpClient);
    this.filterService = injector.get(FilterService);
    this.notificationService = injector.get(NotificationService);
    this.i18nService = injector.get(I18nService);
    this.baseUrl = baseURL;
    if (environment.dummyServices) {
      this.dummyService = injector.get(DummyService);
    }
  }

  downloadBoleta(idContact: number): void {
    this.http.get(`${PREFIX_DOMAIN_API}matriculado/GenerarBoletaContact?id=${idContact}`, {
      observe: 'response',
      responseType: 'blob'
    }).pipe(
      tap((resp: HttpResponse<Blob>) => {
        const name = 'Boleta';
        this.downloadFile(resp, name);
      }),
      catchError(error => this.handleError(error))
    ).subscribe();
  }

  downloadCsv(url: string, params: any): Observable<any> {
    const options = {
      headers: new HttpHeaders({ 'Content-Type': 'application/json' }),
      params: new HttpParams({ fromObject: params })
    };
    return this.http.get<any>(url, options).pipe(
      map(response => this.handleResponse(response)),
      catchError(error => this.handleError(error))
    );
  }

  downloadFile(resp: HttpResponse<Blob>, name: string): void {
    const contentType = resp.headers.get('Content-type');
    if (!resp.body || !contentType) {
      const errorMessage = this.i18nService.getDictionary('fwk')?.translate?.('http_error_no_download') ?? 'http_error_no_download';
      this.notificationService.notifyError(errorMessage);
      return;
    }
    const file = new Blob([resp.body], { type: contentType });

    const fileURL = URL.createObjectURL(file);
    const a = document.createElement('a');
    a.href = fileURL;
    a.target = '_blank';
    a.download = name;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(fileURL);
  }

  private getHttpOptions() {
    return {
      headers: new HttpHeaders({
        'Content-Type': 'application/json'
      })
    };
  }

  httpGet(url: string, options?: any): Observable<any> {
    if (this.dummyService) {
      return this.dummyService.httpGet(url);
    }
    const cacheBuster = `nocache=${new Date().getTime()}`;
    const finalUrl = url.includes('?') ? `${url}&${cacheBuster}` : `${url}?${cacheBuster}`;

    return this.http.get<any>(finalUrl, options).pipe(
      map(response => this.handleResponse(response)),
      catchError(error => this.handleError(error))
    );
  }

  httpPut(url: string, data: any): Observable<any> {
    if (this.dummyService) {
      return this.dummyService.httpPut(url, data);
    }
    return this.http.put(url, data, this.getHttpOptions()).pipe(
      map(response => this.handleResponse(response)),
      catchError(error => this.handleError(error))
    );
  }

  httpPost(url: string, data: any): Observable<any> {
    if (this.dummyService) {
      return this.dummyService.httpPost(url, data);
    }

    const options = data instanceof FormData ? {} : this.getHttpOptions();

    return this.http.post(url, data, options).pipe(
      map(response => this.handleResponse(response)),
      catchError(error => this.handleError(error))
    );
  }

  httpDelete(url: string, id: number | string): Observable<any> {
    const finalUrl = `${url.replace(/\/$/, '')}/${id}`;
    if (this.dummyService) {
      return this.dummyService.httpDelete(finalUrl, [id]);
    }
    return this.http.delete(finalUrl, this.getHttpOptions()).pipe(
      map(response => this.handleResponse(response)),
      catchError(error => this.handleError(error))
    );
  }

  httpDeleteTernaria(url: string): Observable<any> {
    return this.http.delete(url, this.getHttpOptions()).pipe(
      map(response => this.handleResponse(response)),
      catchError(error => this.handleError(error))
    );
  }

  multipleDelete(entities: { id: number | string }[]): Observable<any> {
    if (this.dummyService) {
      const ids = entities.map(e => e.id);
      return this.dummyService.httpDelete(this.baseUrl, ids);
    }
    const ids = entities.map(e => e.id).join(',');
    const url = `${this.baseUrl.replace(/\/$/, '')}/${ids}`;
    return this.http.delete(url, this.getHttpOptions()).pipe(
      map(response => this.handleResponse(response)),
      catchError(error => this.handleError(error))
    );
  }

  multipleDeleteTernario(entities: any[], columnDefSingleId: string, columnDefMultiId: string): Observable<any> {
    if (this.dummyService) {
      return of({ success: true, message: 'Dummy delete ternario successful' });
    }

    if (entities.length === 0) {
      return of({});
    }

    const singleId = entities[0][columnDefSingleId];
    const multiIds = entities.map(e => e[columnDefMultiId]).join(',');

    const url = `${this.baseUrl}/${columnDefSingleId}/${singleId}/${columnDefMultiId}/${multiIds}`;

    return this.http.delete(url, this.getHttpOptions()).pipe(
      map(response => this.handleResponse(response)),
      catchError(error => this.handleError(error))
    );
  }

  private handleResponse(response: any): any {
    if (response && response.ok === false) {
      const errorMessage = this.i18nService.getDictionary('fwk')?.translate?.('http_error_generic') || 'La operación falló pero el servidor no especificó la causa.';
      return this.handleError({
        error: {
          message: errorMessage
        }
      });
    }

    if (response && response.page) {
      this.filterService.totalReg = response.page.totalReg;
    }

    return response && response.data !== undefined ? response.data : response;
  }

  private handleError(error: any): Observable<never> {
    console.error('Error técnico HTTP:', {
      message: error.message,
      status: error.status,
      url: error.url,
      errorBody: error.error,
    });

    const translate = (key: string) => this.i18nService.getDictionary('fwk')?.translate?.(key) || key;

    if (error?.error?.status === 'VALIDATIONS_ERRORS') {
      return throwError(() => error);
    }

    let userFriendlyMessage = translate('http_error_generic');

    if (error instanceof HttpErrorResponse) {
      if (error.error && typeof error.error.message === 'string' && error.error.message.trim() !== '') {
        userFriendlyMessage = error.error.message;
      }
      else {
        switch (error.status) {
          case 400:
            userFriendlyMessage = translate('http_error_400');
            break;
          case 401:
            return throwError(() => error);
          case 403:
            userFriendlyMessage = translate('http_error_403');
            break;
          case 404:
            userFriendlyMessage = translate('http_error_404');
            break;
          case 500:
          case 502:
          case 503:
          case 504:
            userFriendlyMessage = translate('http_error_5xx');
            break;
          case 0:
            userFriendlyMessage = translate('http_error_0');
            break;
          default:
            userFriendlyMessage = translate('http_error_generic');
            break;
        }
      }
    } else if (error?.error?.message) {
      userFriendlyMessage = error.error.message;
    }

    this.notificationService.notifyError(userFriendlyMessage);

    return throwError(() => error);
  }

  applyMemoryFilter(entities: any, filterEntity: any, fieldsDef: any): any {
    if (filterEntity && filterEntity !== null) {
      Object.getOwnPropertyNames(filterEntity).forEach((val) => {
        entities = entities.filter((ent: { [x: string]: any; }) => {
          const field = fieldsDef.find((f: { key: string; }) => f.key === val);
          if (!field) return true;

          let entityValue = ent[val];
          if (entityValue === undefined && (field.options && field.options.matchTo)) {
            entityValue = ent[field.options.matchTo];
          }
          const filterValue = filterEntity[val];
          const filterType = field.filterType ? field.filterType.toUpperCase() : FILTER_TYPE.LIKE;
          return this.filterService.filter(entityValue, filterValue, filterType, field);
        });
      });
    }
    return entities;
  }
}

--- FILE: @fwk/services/i18n-service/i18n.service.ts ---

﻿import { Injectable, Injector } from '@angular/core';
import { Observable, of } from 'rxjs';

import { BaseService } from '../base-service/base.service';
import { I18n } from '../../model/i18n';

@Injectable({
    providedIn: 'root'
})
export class I18nService extends BaseService {

    private dictionaries: Map<string, I18n> = new Map();

    constructor(protected override injector: Injector) {
        super(injector);
    }

    getDictionary(name: string): I18n | undefined {
        if (!name || typeof name !== 'string') {
            return undefined;
        }
        return this.dictionaries.get(name.toLowerCase());
    }

    getByName(byName: string): Observable<I18n> {
        const dictionary = this.getDictionary(byName) || new I18n();
        return of(dictionary);
    }

    addI18n(i18n: I18n): void {
        if (!i18n || !i18n.name) return;
        
        const key = i18n.name.toLowerCase();
        if (!this.dictionaries.has(key)) {
            const i18nInstance = new I18n();
            if (i18nInstance.clone) {
                i18nInstance.clone(i18n);
            } else {
                 Object.assign(i18nInstance, JSON.parse(JSON.stringify(i18n)));
            }
            this.dictionaries.set(key, i18nInstance);
        }
    }
}

--- FILE: @fwk/services/icon-list/icon-list.service.ts ---

import { inject, Injectable } from '@angular/core';
import { Observable, of } from 'rxjs';
import { IconsService } from '@fwk/services/icons.service';

@Injectable({ providedIn: 'root' })
export class IconListService {
    private _iconsService = inject(IconsService);


    public getIconNames(namespace: string): Observable<string[]> {
        const names = this._iconsService.getIconNames(namespace);

        if (names.length === 0) {
            console.error(`[IconListService] No se encontraron iconos para el namespace '${namespace}'. ¿Está registrado en IconsService.load()?`);
        }
        
        return of(names);
    }
}

--- FILE: @fwk/services/icons.service.ts ---

import { inject, Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { MatIconRegistry } from '@angular/material/icon';
import { DomSanitizer, SafeHtml } from '@angular/platform-browser';
import { forkJoin, lastValueFrom, map, Observable, of, catchError } from 'rxjs';

interface IconSet {
    url: string;
    isNamespace: boolean;
    namespace?: string;
}

interface LoadedIconSet extends IconSet {
    svgContent: string;
}

@Injectable({ providedIn: 'root' })
export class IconsService {
    private domSanitizer = inject(DomSanitizer);
    private matIconRegistry = inject(MatIconRegistry);
    private httpClient = inject(HttpClient);

    private _iconNameCache = new Map<string, string[]>();

    load(): Promise<any> {
        const iconSets: IconSet[] = [
            { url: 'assets/icons/heroicons-outline.svg', isNamespace: true, namespace: 'heroicons_outline' },
            { url: 'assets/icons/heroicons-solid.svg', isNamespace: true, namespace: 'heroicons_solid' },
            { url: 'assets/icons/heroicons-mini.svg', isNamespace: true, namespace: 'heroicons_mini' },
            { url: 'assets/icons/material-outline.svg', isNamespace: true, namespace: 'mat_outline' },
            { url: 'assets/icons/material-solid.svg', isNamespace: true, namespace: 'mat_solid' },
            // { url: 'assets/icons/material-twotone.svg', isNamespace: true, namespace: 'mat_twotone' },
        ];

        const requests: Observable<LoadedIconSet>[] = iconSets.map(set =>
            this.httpClient.get(set.url, { responseType: 'text' }).pipe(
                catchError((error) => {
                    console.error(
                        `[IconsService] ¡ERROR CRÍTICO! No se pudo cargar el set de iconos desde '${set.url}'. ` +
                        `Verifica que el archivo exista y sea accesible. Error: ${error.status} ${error.statusText}`
                    );
                    return of(''); 
                }),
                map(svg => ({ ...set, svgContent: svg }))
            )
        );

        return lastValueFrom(forkJoin(requests).pipe(
            map(loadedIconSets => {
                loadedIconSets.forEach(loadedSet => {
                    if (!loadedSet.svgContent) {
                        return;
                    }

                    let correctedSvgContent = loadedSet.svgContent
                        .replace(/<svg id="/g, '<symbol id="')
                        .replace(/<\/svg>/g, '</symbol>');

                    const safeSvg: SafeHtml = this.domSanitizer.bypassSecurityTrustHtml(correctedSvgContent);
                    
                    if (loadedSet.isNamespace && loadedSet.namespace) {
                        this.matIconRegistry.addSvgIconSetLiteralInNamespace(loadedSet.namespace, safeSvg);
                        
                        const iconNames = this.parseSvgSprite(correctedSvgContent);
                        this._iconNameCache.set(loadedSet.namespace, iconNames);
                        // console.log(`[IconsService] Set de iconos '${loadedSet.namespace}' cargado con ${iconNames.length} iconos.`);

                    } else {
                        this.matIconRegistry.addSvgIconSetLiteral(safeSvg);
                    }
                });
            })
        ));
    }

    public getIconNames(namespace: string): string[] {
        return this._iconNameCache.get(namespace) || [];
    }

    private parseSvgSprite(svgText: string): string[] {
        try {
            const parser = new DOMParser();
            const doc = parser.parseFromString(svgText, 'image/svg+xml');
            const symbols = doc.querySelectorAll('symbol');
            if (symbols.length === 0) {
                 const svgTagsWithId = doc.querySelectorAll('svg[id]');
                 if (svgTagsWithId.length > 0) {
                    console.warn(`[IconsService] El archivo SVG parece tener un formato no estándar (svg anidados). Se intentó corregir. Nombres encontrados: ${svgTagsWithId.length}`);
                    return Array.from(svgTagsWithId).map(svg => svg.id).sort((a, b) => a.localeCompare(b));
                 }
            }
            return Array.from(symbols).map(symbol => symbol.id).sort((a, b) => a.localeCompare(b));
        } catch (e) {
            console.error('[IconsService] Error al parsear el archivo SVG de iconos:', e);
            return [];
        }
    }
}

--- FILE: @fwk/services/local-storage/local-storage.service.ts ---

﻿import { Injectable } from '@angular/core';
import { I18n } from '../../model/i18n';

export interface UserCredentials {
    username: string;
    password?: string; 
}

export const LOGIN_FORM_USERDATA = 'LOGIN_FORM_USERDATA';
export const I18N_DATA = 'I18N_DATA';
export const TO_CLONE_DATA = 'TO_CLONE_DATA';
export const USER_DATA_FOR_FORCE_CHANGE_PASSWORD = 'USER_DATA_FOR_FORCE_CHANGE_PASSWORD';

@Injectable({
    providedIn: 'root' 
})
export class LocalStorageService {
    private tokenKey = 'jwt_token';
    private USER_DATA = 'currentUser';

    constructor() { }

    setTokenKey(tokenKey: string): void {
        this.tokenKey = tokenKey;
    }

    cleanTokenData(): void {
        localStorage.removeItem(this.tokenKey);
    }

    saveTokenData(token: string): void {
        localStorage.setItem(this.tokenKey, token);
    }

    getTokenData(): string | null {
        return localStorage.getItem(this.tokenKey);
    }

    cleanLoginFormUserData(): void {
        localStorage.removeItem(LOGIN_FORM_USERDATA);
    }

    saveLoginFormUserData(user: UserCredentials): void {
        localStorage.setItem(LOGIN_FORM_USERDATA, JSON.stringify(user));
    }

    getLoginFormUserData(): UserCredentials | null {
        const storedData = localStorage.getItem(LOGIN_FORM_USERDATA);
        return storedData ? JSON.parse(storedData) : null;
    }

    cleanUserDataForForceChangePassword(): void {
        localStorage.removeItem(USER_DATA_FOR_FORCE_CHANGE_PASSWORD);
    }

    saveUserDataForForceChangePassword(user: UserCredentials): void {
        localStorage.setItem(USER_DATA_FOR_FORCE_CHANGE_PASSWORD, JSON.stringify(user));
    }

    getUserDataForForceChangePassword(): UserCredentials | null {
        const storedData = localStorage.getItem(USER_DATA_FOR_FORCE_CHANGE_PASSWORD);
        return storedData ? JSON.parse(storedData) : null;
    }

    cleanI18nData(): void {
        localStorage.removeItem(I18N_DATA);
    }

    saveI18nData(i18n: I18n[]): void {
        localStorage.setItem(I18N_DATA, JSON.stringify(i18n));
    }

    getI18nData(): I18n[] | null {
        const storedData = localStorage.getItem(I18N_DATA);
        return storedData ? JSON.parse(storedData) : null;
    }

    cleanUserSession(): void {
        this.cleanUserDataForForceChangePassword();
        this.cleanTokenData();
        this.cleanI18nData();
    }

    clone<T>(obj: T): T {
        return JSON.parse(JSON.stringify(obj));
    }

    save(key: string, obj: any): void {
        localStorage.setItem(key, JSON.stringify(obj));
    }

    get<T>(key: string): T | null {
        const storedData = localStorage.getItem(key);
        return storedData ? JSON.parse(storedData) : null;
    }

    remove(key: string): void {
        localStorage.removeItem(key);
    }

    getUserLocalStorage(): any {
        return this.get(this.USER_DATA);
    }
}

--- FILE: @fwk/services/mapping-component-service/mapping.component.service.ts ---

﻿import { ComponentDef } from '../../model/component-def/component-def';

export class MappingComponentService {

  constructor() { }

  static resolveStyles(mappings: ComponentDef[]){
      const styleUrls: any [] = [];
      mappings.forEach(mapping => {
          styleUrls.push(mapping.styleUrl);
      });
      return (styleUrls);
  }
}


--- FILE: @fwk/services/message/error-message.service.ts ---

﻿import { Injectable } from '@angular/core';

import { Injector } from '@angular/core';
import { I18nService } from '../i18n-service/i18n.service';
import { I18n } from '../../model/i18n';

@Injectable({
  providedIn: 'root'
})
export class ErrorMessageService {

  error: any;
  i18nService: I18nService;
  i18n!: I18n;
  constructor(injector: Injector) {
    this.i18nService = injector.get(I18nService);
    this.i18nService.getByName(this.getI18nName()).subscribe(
                i18n => {
                        this.i18n = i18n;
                        }
                      );
  }

  translate(key: string) {
    let value;
    if (this.i18n) {
      value = this.i18n.dictionary[key];
    }
    return value ? value : key;
  }
  setError(error: any) {
    this.error = error;
  }

  clear() {
    this.error = null;
  }

  getError() {
    return this.error;
  }

  getI18nName(): string {
   return 'error';
  }

}


--- FILE: @fwk/services/message/message.service.ts ---

﻿import { Injectable } from '@angular/core';

@Injectable({
  providedIn: 'root'
})
export class MessageService {
  messages: string[] = [];

  add(message: string): void {
    this.messages.push(message);
  }

  clear(): void {
    this.messages = [];
  }
}

--- FILE: @fwk/services/navigation/navigation.service.ts ---

﻿import { Injectable } from '@angular/core';
import { BehaviorSubject, forkJoin, of } from 'rxjs';
import { map, take } from 'rxjs/operators';

import { I18n } from '../../model/i18n';
import { I18nService } from '../i18n-service/i18n.service';
import { ComponentDef } from '../../model/component-def/component-def';
import { LocalStorageService } from '../local-storage/local-storage.service';
import { ComponentDefService } from '../component-def-service/component-def.service';

export interface NavigationItem {
    id?: string;
    title: string;
    type: 'item' | 'group' | 'collapse';
    translate?: string;
    translateKey?: string;
    icon?: string;
    url?: string;
    permission?: string;
    children?: NavigationItem[];
}

@Injectable({
    providedIn: 'root'
})
export class NavigationService {
    private i18n!: I18n;

    private navigationState = new BehaviorSubject<NavigationItem[]>([]);
    public navigation$ = this.navigationState.asObservable();

    constructor(
        private i18nService: I18nService,
        private localStorageService: LocalStorageService,
        private componentDefService: ComponentDefService
    ) {
        this.i18nService.getByName('navigation').pipe(take(1)).subscribe(i18n => {
            this.i18n = i18n || new I18n();
        });
    }

    setNavigation(nav: NavigationItem[]): void {
        const navClone = this.localStorageService.clone(nav);
        const userPermisos = this.componentDefService.getUserPermisos();
        const filteredNav = this.componentDefService.filterNavArrayBySecurity(navClone, userPermisos);
        const sortedNav = this.sortItemsByType(filteredNav);
        this.navigationState.next(this.filterOrphans(sortedNav));
    }

    setUpByMappingComponent(components: ComponentDef[]): void {
        if (!components || components.length === 0) {
            return;
        }

        const i18nObservables$ = components.map(component =>
            this.i18nService.getByName(component.i18n.name).pipe(
                map(i18n => ({ component, i18n }))
            )
        );

        forkJoin(i18nObservables$).pipe(take(1)).subscribe(results => {
            let currentNav = this.localStorageService.clone(this.navigationState.getValue());

            results.forEach(({ component, i18n }) => {
                if (component.navigation?.translateKey && i18n) {
                    component.navigation.translate = i18n.translate?.(component.navigation.translateKey) ?? component.navigation.translateKey;
                }
            });

            const sortedNav = this.sortItemsByType(currentNav);
            this.navigationState.next(this.filterOrphans(sortedNav));
        });
    }

    removeNavigation(navDef: NavigationItem): void {
        const currentNav = this.navigationState.getValue();
        const newNav = this.recursiveRemove(currentNav, navDef);
        const sortedNav = this.sortItemsByType(newNav);
        this.navigationState.next(this.filterOrphans(sortedNav));
    }

    private sortItemsByType(items: NavigationItem[]): NavigationItem[] {
        if (!items) {
            return [];
        }

        const processedItems = items.map(item => {
            if (item.children && item.children.length > 0) {
                return {
                    ...item,
                    children: this.sortItemsByType(item.children)
                };
            }
            return item;
        });

        processedItems.sort((a, b) => {
            const weightA = a.type === 'item' ? 1 : 0;
            const weightB = b.type === 'item' ? 1 : 0;

            return weightA - weightB;
        });

        return processedItems;
    }

    private filterOrphans(items: NavigationItem[]): NavigationItem[] {
        if (!items) return [];

        return items
            .map(item => {
                if (item.children && item.children.length > 0) {
                    const filteredChildren = this.filterOrphans(item.children);
                    return { ...item, children: filteredChildren };
                }
                return item;
            })
            .filter(item => {
                if (item.type === 'item') {
                    return true;
                }
                return item.children && item.children.length > 0;
            });
    }

    private recursiveRemove(items: NavigationItem[], navDefToRemove: NavigationItem): NavigationItem[] {
        if (!items || !navDefToRemove.id) return items;

        return items
            .filter(item => item.id !== navDefToRemove.id)
            .map(item => {
                if (item.children) {
                    return { ...item, children: this.recursiveRemove(item.children, navDefToRemove) };
                }
                return item;
            });
    }
}

--- FILE: @fwk/services/notification/notification.service.ts ---

﻿import { Injectable, Injector } from '@angular/core';
import { MatSnackBar, MatSnackBarConfig } from '@angular/material/snack-bar';

import { BaseService } from '../base-service/base.service';
import { I18nService } from '../i18n-service/i18n.service';
import { I18n } from '../../model/i18n';
import { CustomNotificationComponent } from '../../components/custom-notification/custom-notification.component';

export const NOTIFICATION_OPTS: MatSnackBarConfig = {
  duration: 5000,
  horizontalPosition: 'start',
  verticalPosition: 'bottom',
  panelClass: 'custom-notification-panel'
};

@Injectable({
  providedIn: 'root'
})
export class NotificationService extends BaseService {
  i18nService: I18nService;
  i18n?: I18n;

  constructor(
    private snackBar: MatSnackBar,
    injector: Injector
  ) {
    super(injector);
    this.i18nService = injector.get(I18nService);
  }

  notify(message: string): void {
    const config = { 
        ...NOTIFICATION_OPTS,
        data: { message, type: 'info' }
    };
    this.snackBar.openFromComponent(CustomNotificationComponent, config);
  }

  notifyError(message: string): void {
    const config = { 
        ...NOTIFICATION_OPTS,
        data: { message, type: 'error' }
    };
    this.snackBar.openFromComponent(CustomNotificationComponent, config);
  }

  notifySuccess(message: string): void {
    const config = { 
        ...NOTIFICATION_OPTS,
        data: { message, type: 'success' }
    };
    this.snackBar.openFromComponent(CustomNotificationComponent, config);
  }
}

--- FILE: @fwk/services/search/search.service.ts ---

import { inject, Injectable } from '@angular/core';
import { Observable, of, ReplaySubject } from 'rxjs';
import { switchMap, take, filter, map } from 'rxjs/operators';
import { CrudDef } from '@fwk/model/component-def/crud-def';
import { FWK_CRUD_MODULES_LOADER } from '@fwk/navigation/navigation.tokens';
import { AbstractAuthService } from '@fwk/auth/abstract-auth.service';

export interface SearchResult {
    title: string;
    breadcrumb: string[];
    link: string;
    keywords: string;
}

@Injectable({ providedIn: 'root' })
export class SearchService {
    private crudModulesLoader = inject(FWK_CRUD_MODULES_LOADER);
    private authService = inject(AbstractAuthService);

    private searchablePages = new ReplaySubject<SearchResult[]>(1);
    private searchablePages$: Observable<SearchResult[]> = this.searchablePages.asObservable();

    constructor() {
        this.authService.authenticated$.pipe(
            filter(isAuthenticated => isAuthenticated)
        ).subscribe(() => {
            this.buildSearchIndex();
        });
        
        this.authService.authenticated$.pipe(
            filter(isAuthenticated => !isAuthenticated)
        ).subscribe(() => {
            this.searchablePages.next([]);
        });
    }
    
    private async loadAllCrudDefs(): Promise<CrudDef[]> {
        const crudModules = await this.crudModulesLoader();
        const loaderPromises = crudModules.map(moduleDef => moduleDef.loader());
        const loadedModules = await Promise.all(loaderPromises);

        return loadedModules.map(module => {
            const defKey = Object.keys(module).find(key => key.endsWith('_DEF'));
            return defKey ? module[defKey] : null;
        }).filter(Boolean) as CrudDef[];
    }

    private async buildSearchIndex(): Promise<void> {
        const crudDefs = await this.loadAllCrudDefs();
        const results: SearchResult[] = [];

        crudDefs.forEach(def => {
            const navDef = def.navigation;
            const readPermission = def.security?.readAccess;

            if (!navDef || navDef.showInMenu !== true || !this.authService.hasPermission(readPermission)) {
                return;
            }
            
            let translatedTitle = navDef.translateKey;
            const dictionary = def.i18n?.words || def.i18n?.dictionary;
            if (dictionary && navDef.translateKey && dictionary[navDef.translateKey]) {
                translatedTitle = dictionary[navDef.translateKey];
            }
            
            const breadcrumb = navDef.group ? navDef.group.split('.').map(part => part.charAt(0).toUpperCase() + part.slice(1).replace(/-/g, ' ')) : [];
            const allKeywords = dictionary ? Object.values(dictionary).join(' ').toLowerCase() : '';

            results.push({
                title: translatedTitle,
                breadcrumb,
                link: navDef.url,
                keywords: `${translatedTitle} ${breadcrumb.join(' ')} ${allKeywords}`.toLowerCase()
            });
        });
        
        this.searchablePages.next(results);
    }

    search(term: string): Observable<SearchResult[]> {
        const lowerCaseTerm = term.toLowerCase().trim();
        if (!lowerCaseTerm) {
            return of([]);
        }

        return this.searchablePages$.pipe(
            take(1),
            map(pages => pages.filter(page => page.keywords.includes(lowerCaseTerm)))
        );
    }
}

--- FILE: @fwk/utils/constants.ts ---

﻿export const REGEX_KEY_LETTER_NUMBERS_DASH_UNDERCODE_WITH_FIRST_LETTER = 'regex_letter_numbers_dash_undercode_with_first_letter';
export const REGEX_KEY_ONLY_NUMBERS = 'regex_only_numbers';

export const CONSTANTS = {
    /** 
     * REGEX CONSTANTS
     * For more information go to Google Sheet Validations of Avaco Sistemas
     */

    REGEX_SPACES_AND_SPECIAL_LETTERS_NUMBERS_SLASH_DOT: '[a-zA-Z0-9ñÑáéíóúÁÉÍÓÚ \\-\\.]*',
    REGEX_SPACES_AND_SPECIAL_LETTERS: '[a-zA-ZñÑáéíóúÁÉÍÓÚ ]*',
    REGEX_CODIGO_POSTAL: '([0-9]{4})|([a-zA-Z][0-9]{4}[a-zA-Z]{3})',
    REGEX_LETTERS_NUMBERS: '[a-zA-Z0-9]*',
    REGEX_ALIAS_CBU: '[a-zA-Z0-9\\-\\.]*',
    REGEX_CUIL: '(20|23|24|27|30|33|34)[0-9]{9}',
    REGEX_CUIT: '(20|23|24|27)[0-9]{9}',
    REGEX_EMAIL: '(\\s*?(.+)@(.+?)\\s)*',
    REGEX_USER: '[a-z][a-z0-9\\_\\-]{4,15}',
    REGEX_DATE: '([0-2][0-9]|3[0-1])(\/)(0[1-9]|1[0-2])(\/)(\d{4})',
    REGEX_URL: '^((https?:\\/\\/)|(http?:\\/\\/))' +
        '((([a-z\\d]([a-z\\d-]*[a-z\\d])*)\\.)+[a-z]{2,}|' +
        '((\\d{1,3}\\.){3}\\d{1,3}))' +
        '(\\:\\d+)?(\\/[-a-z\\d%_.~+]*)*' +
        '(\\?[;&a-z\\d%_.~+=-]*)?' +
        '(\\#[-a-z\\d_]*)?$',

    REGEXS: [{
        key: REGEX_KEY_LETTER_NUMBERS_DASH_UNDERCODE_WITH_FIRST_LETTER,
        messageKey: 'letter_numbers_dash_undercode_with_first_letter_message',
        regex: '[a-z][a-z0-9\\_\\-]*'
    },
    {
        key: REGEX_KEY_ONLY_NUMBERS,
        messageKey: 'only_numbers_message',
        regex: '[0-9]*'
    }]
};



--- FILE: @fwk/utils/crud-route-generator.ts ---

import { inject } from '@angular/core';
import { ResolveFn, Routes } from '@angular/router';
import { CrudRegistryService } from '../services/crud-registry.service';
import { I18nService } from '../services/i18n-service/i18n.service';
import { PageComponentDef } from '../model/component-def/page-component-def';
import { CrudDef } from '../model/component-def/crud-def';

export function normalizeCrudName(name: string): string {
    return name.replace(/-|_/g, '').toUpperCase();
}

function createDefResolver(loader: () => Promise<any>): ResolveFn<CrudDef | PageComponentDef | null> {
    return () => {
        const registry = inject(CrudRegistryService);
        const i18nService = inject(I18nService);

        return loader().then(module => {
            const defKey = Object.keys(module).find(key => key.endsWith('_DEF'));
            if (!defKey) {
                console.error('No se encontró una exportación "_DEF" en el módulo cargado.', module);
                return null;
            }

            const definition = module[defKey];
            const componentName = normalizeCrudName(definition.name);

            if (definition.i18n) {
                i18nService.addI18n(definition.i18n);
            }

            registry.register(componentName, () => Promise.resolve(definition));

            return definition;
        });
    };
}

export function generateFwkPageRoutes(loader: () => Promise<any>): Routes {
    return [
        {
            path: '',
            resolve: {
                definition: createDefResolver(loader)
            },
            loadComponent: () => {
                return loader().then(module => {
                    const defKey = Object.keys(module).find(key => key.endsWith('_DEF'));
                    const definition = defKey ? module[defKey] : null;

                    if (definition && (definition as PageComponentDef).component) {
                        return import('../components/page-component-wrapper/page-component-wrapper.component')
                            .then(m => m.PageComponentWrapperComponent);
                    }

                    if (definition && definition.dashboardConfig) {
                        return import('../components/dashboard-wrapper/dashboard-wrapper.component')
                            .then(m => m.DashboardWrapperComponent);
                    } else {
                        return import('../components/legacy-crud-wrapper/legacy-crud-wrapper.component')
                            .then(m => m.LegacyCrudWrapperComponent);
                    }
                });
            }
        }
    ];
}

--- FILE: @fwk/_scripts/dev-server.js ---

// @fwk/_scripts/dev-server.js

const express = require('express');
const cors = require('cors');
const fs = require('fs-extra');
const path = require('path');
const axios = require('axios');
const { exec } = require('child_process');
const { v4: uuidv4 } = require('uuid');
const cheerio = require('cheerio');

const parser = require('@babel/parser');
const traverse = require('@babel/traverse').default;
const generate = require('@babel/generator').default;
const t = require('@babel/types');

let chalk;
let ora;

async function importUxDependencies() {
    chalk = (await import('chalk')).default;
    ora = (await import('ora')).default;
}

const toCamelCase = (str) => str.replace(/[-_]([a-z])/g, g => g[1].toUpperCase());
const toClassName = (str) => { const camel = toCamelCase(str); return camel.charAt(0).toUpperCase() + camel.slice(1); };
const toSnakeCase = (str) => str.replace(/[A-Z]/g, letter => `_${letter.toLowerCase()}`).replace(/^_/, '');

const keyToLabel = (str) => {
    if (!str) return '';
    const spaced = str.replace(/([A-Z])/g, ' $1').trim();
    return spaced.charAt(0).toUpperCase() + spaced.slice(1);
};

const toConstCase = (str) => {
    if (!str) return '';
    return str
        .replace(/([A-Z])/g, letter => `_${letter}`)
        .replace(/[\s-]/g, '_')
        .replace(/[^\w]/g, '')
        .replace(/__+/g, '_')
        .toUpperCase()
        .replace(/^_/, '');
};

importUxDependencies();

const app = express();
const port = 4201;

app.use(cors());
app.use(express.json({ limit: '10mb' }));

console.log('🚀 [DEV-API] Servidor de desarrollo iniciado.');

function objectToString(obj, indentLevel = 1) {
    if (obj === undefined) return 'undefined';
    if (obj === null) return 'null';

    if (typeof obj === 'string') {
        if (obj.startsWith('%%') && obj.endsWith('%%')) {
            return obj.slice(2, -2);
        }
        return `'${obj.replace(/'/g, "\\'")}'`;
    }

    if (typeof obj !== 'object') {
        return String(obj);
    }

    const indent = '    '.repeat(indentLevel);
    const indentClose = '    '.repeat(indentLevel - 1);

    if (Array.isArray(obj)) {
        if (obj.length === 0) return '[]';
        const items = obj.map(item => `${indent}${objectToString(item, indentLevel + 1)}`).join(',\n');
        return `[\n${items}\n${indentClose}]`;
    }

    const props = Object.entries(obj)
        .filter(([, value]) => value !== undefined)
        .map(([key, value]) => {
            const keyStr = /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(key) ? key : `'${key}'`;
            return `${indent}${keyStr}: ${objectToString(value, indentLevel + 1)}`;
        })
        .join(',\n');

    return `{\n${props}\n${indentClose}}`;
}

function buildDisplayedActionsConditionFromArray(actions) {
    if (!Array.isArray(actions)) return undefined;

    return actions
        .filter(action => action.displayCondition?.expression?.key)
        .map(action => {
            const expression = action.displayCondition.expression;
            return {
                key: action.actionNameKey,
                expression: {
                    ...expression,
                    compare: `%%FILTER_TYPE.${expression.compare}%%`
                }
            };
        });
}

const inferControlType = (key, value) => {
    const keyLower = key ? key.toLowerCase() : '';
    if (keyLower === 'id') return 'hidden';
    if (typeof value === 'boolean') return 'checkbox';
    if (typeof value === 'number') return 'number';
    if (typeof value === 'string') {
        if (keyLower.includes('date') || keyLower.includes('fecha')) {
            return /\d{4}-\d{2}-\d{2}T\d{2}:\d{2}/.test(value) ? 'datetimepicker' : 'datepicker';
        }
        if (keyLower.includes('email')) return 'email';
        if (keyLower.includes('color')) return 'color_picker';
        if (value.length > 100) return 'textarea';
    }
    return 'textbox';
};

function getEnvConfig() {
    try {
        const envPath = path.join(__dirname, '..', '..', '..', 'src', 'environments', 'environment.ts');
        const content = fs.readFileSync(envPath, 'utf8');
        const simpleValueRegex = (key) => new RegExp(`export const ${key}\\s*=\\s*['"](.*?)['"]`);
        const apiPrefixMatch = content.match(simpleValueRegex('PREFIX_DOMAIN_API'));
        if (!apiPrefixMatch) throw new Error('PREFIX_DOMAIN_API no encontrado.');
        const apiPrefix = apiPrefixMatch[1];
        const swaggerUrlMatch = content.match(simpleValueRegex('PREFIX_SWAGGER_API'));
        if (!swaggerUrlMatch) throw new Error('PREFIX_SWAGGER_API no encontrado.');
        const swaggerUrl = swaggerUrlMatch[1];
        return { apiPrefix, swaggerUrl };
    } catch (error) {
        console.error(`[DEV-API] Error al leer el archivo de entorno: ${error.message}`);
        return { apiPrefix: null, swaggerUrl: null };
    }
}

const parseFile = (filePath) => {
    if (!fs.existsSync(filePath)) return null;
    const content = fs.readFileSync(filePath, 'utf8');
    try {
        return parser.parse(content, { sourceType: "module", plugins: ["typescript"] });
    } catch (e) {
        console.error(`[DEV-API] Fallo al parsear AST de: ${filePath}`, e.message);
        return null;
    }
};

function astNodeToJsValue(node) {
    if (!node) return undefined;
    switch (node.type) {
        case 'StringLiteral':
        case 'NumericLiteral':
        case 'BooleanLiteral':
            return node.value;
        case 'NullLiteral':
            return null;
        case 'Identifier':
            if (node.name === 'undefined') return undefined;
            return `%%${node.name}%%`;
        case 'ObjectExpression':
            return node.properties.reduce((obj, prop) => {
                if (prop.type === 'ObjectProperty') {
                    const key = prop.key.name || prop.key.value;
                    obj[key] = astNodeToJsValue(prop.value);
                }
                return obj;
            }, {});
        case 'ArrayExpression':
            return node.elements.map(element => astNodeToJsValue(element));
        case 'BinaryExpression':
            if (node.operator === '+') {
                const left = astNodeToJsValue(node.left);
                const right = astNodeToJsValue(node.right);
                const leftStr = left.startsWith('%%') ? left.slice(2, -2) : `'${left}'`;
                const rightStr = right.startsWith('%%') ? right.slice(2, -2) : `'${right}'`;
                return `%%${leftStr} + ${rightStr}%%`;
            }
            return `%%${generate(node).code}%%`;
        case 'MemberExpression':
            return `%%${generate(node).code}%%`;
        case 'UnaryExpression':
            if (node.operator === '-' && node.argument.type === 'NumericLiteral') {
                return -node.argument.value;
            }
            return `%%${generate(node).code}%%`;
        default:
            const code = generate(node).code;
            if (code) {
                return `%%${code}%%`;
            }
            return undefined;
    }
}

function resolveReferences(obj, context) {
    if (typeof obj === 'string' && obj.startsWith('%%') && obj.endsWith('%%')) {
        const varName = obj.slice(2, -2);
        return context[varName] !== undefined ? context[varName] : obj;
    }
    if (Array.isArray(obj)) {
        return obj.map(item => resolveReferences(item, context));
    }
    if (typeof obj === 'object' && obj !== null) {
        const newObj = {};
        for (const key in obj) {
            newObj[key] = resolveReferences(obj[key], context);
        }
        return newObj;
    }
    return obj;
}

function jsValueToASTNode(value) {
    if (value === null) return t.nullLiteral();
    if (value === undefined) return t.identifier('undefined');
    switch (typeof value) {
        case 'string':
            if (value.startsWith('%%') && value.endsWith('%%')) {
                const code = value.slice(2, -2).trim();
                try {
                    const parsed = parser.parseExpression(code);
                    return parsed;
                } catch (e) {
                    console.warn(`[DEV-API] No se pudo parsear la expresión '${code}' como AST. Se tratará como string literal.`);
                    return t.stringLiteral(code);
                }
            }
            return t.stringLiteral(value);
        case 'number': return t.numericLiteral(value);
        case 'boolean': return t.booleanLiteral(value);
        case 'object':
            if (Array.isArray(value)) return t.arrayExpression(value.map(jsValueToASTNode));
            const properties = Object.keys(value).map(key => {
                if (value[key] === undefined) return null;
                const astValue = jsValueToASTNode(value[key]);
                if (astValue === null) return null;
                return t.objectProperty(
                    /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(key) ? t.identifier(key) : t.stringLiteral(key),
                    astValue
                );
            }).filter(Boolean);
            return t.objectExpression(properties);
        default: throw new Error(`Tipo de dato no soportado para conversión a AST: ${typeof value}`);
    }
}

async function updateVariableInFile(filePath, varName, newData) {
    if (!await fs.pathExists(filePath)) {
        console.warn(chalk.yellow(`[DEV-API] ADVERTENCIA: No se encontró el archivo ${filePath}. Saltando actualización.`));
        return;
    }

    const ast = parseFile(filePath);
    if (!ast) return;

    let variableFound = false;
    traverse(ast, {
        VariableDeclarator(path) {
            if (path.node.id.name === varName) {
                variableFound = true;
                const objectExpression = path.node.init;

                if (t.isObjectExpression(objectExpression)) {
                    const existingProps = new Map(
                        objectExpression.properties.map(p => [(p.key.name || p.key.value), p])
                    );

                    for (const key in newData) {
                        if (Object.prototype.hasOwnProperty.call(newData, key)) {
                            const newValue = newData[key];
                            const newNode = jsValueToASTNode(newValue);

                            if (existingProps.has(key)) {
                                existingProps.get(key).value = newNode;
                            } else {
                                const newProperty = t.objectProperty(
                                    /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(key) ? t.identifier(key) : t.stringLiteral(key),
                                    newNode
                                );
                                objectExpression.properties.push(newProperty);
                            }
                        }
                    }
                }
                path.stop();
            }
        }
    });

    if (!variableFound) {
        console.warn(chalk.yellow(`[DEV-API] ADVERTENCIA: No se encontró la variable '${varName}' en '${filePath}'.`));
        return;
    }

    const { code: tempCode } = generate(ast);

    const potentialImports = [
        { keyword: 'PREFIX_DOMAIN_API', path: 'environments/environment' },
        { keyword: 'PREFIX_STATS_API', path: 'environments/environment' },
        { keyword: 'FILTER_TYPE', path: '@fwk/services/filter-service/filter.service' }
    ];

    potentialImports.forEach(imp => {
        if (tempCode.includes(imp.keyword)) {
            let isAlreadyImported = false;
            traverse(ast, {
                ImportDeclaration(path) {
                    if (path.node.source.value === imp.path) {
                        if (path.node.specifiers.some(spec => spec.imported && spec.imported.name === imp.keyword)) {
                            isAlreadyImported = true;
                            path.stop();
                        }
                    }
                }
            });

            if (!isAlreadyImported) {
                console.log(chalk.gray(`   -> Inyectando import para '${imp.keyword}' en '${path.basename(filePath)}'.`));
                const importSpecifier = t.importSpecifier(t.identifier(imp.keyword), t.identifier(imp.keyword));
                const importDeclaration = t.importDeclaration([importSpecifier], t.stringLiteral(imp.path));
                ast.program.body.unshift(importDeclaration);
            }
        }
    });

    const { code } = generate(ast, { retainLines: false, comments: true, jsescOption: { quotes: 'single' } });

    await fs.writeFile(filePath, code, 'utf8');
    console.log(chalk.blue(` -> Archivo '${path.basename(filePath)}' actualizado para la variable '${varName}'.`));
};

app.get('/api/dev/swagger-endpoints', async (req, res) => {
    console.log('\n[DEV-API] Petición recibida en /api/dev/swagger-endpoints');
    try {
        const { swaggerUrl } = getEnvConfig();
        if (!swaggerUrl) { return res.status(500).json({ message: 'PREFIX_SWAGGER_API no está configurado en environment.ts' }); }
        const response = await axios.get(swaggerUrl);
        const swaggerData = response.data;
        if (!swaggerData.paths) { return res.status(500).json({ message: 'El JSON de Swagger no contiene la propiedad "paths".' }); }
        const endpoints = Object.keys(swaggerData.paths).filter(p => swaggerData.paths[p].get).map(p => ({ path: p, summary: swaggerData.paths[p].get.summary || (swaggerData.paths[p].get.tags ? swaggerData.paths[p].get.tags[0] : 'Sin descripción') })).sort((a, b) => a.path.localeCompare(b.path));
        res.json(endpoints);
    } catch (error) {
        console.error('[DEV-API] Error obteniendo Swagger:', error.message);
        res.status(500).json({ message: 'No se pudo obtener la definición de Swagger.', error: error.message });
    }
});

app.post('/api/dev/scan-endpoint', async (req, res) => {
    console.log('\n[DEV-API] Petición recibida en /api/dev/scan-endpoint');
    const { endpoint, token } = req.body;
    const { apiPrefix } = getEnvConfig();
    if (!endpoint || !token || !apiPrefix) { return res.status(400).json({ message: 'Faltan parámetros: endpoint, token, apiPrefix' }); }
    try {
        const cleanEndpoint = endpoint.replace(/{\w+}/g, '');
        const urlWithParams = `${apiPrefix}${cleanEndpoint.replace('/api/', '')}?page=0&pageSize=1`;
        const config = { headers: { 'Authorization': `Bearer ${token}` } };
        const response = await axios.get(urlWithParams, config);
        const data = response.data.data || response.data;
        if (!Array.isArray(data) || data.length === 0) { return res.status(404).json({ message: 'La respuesta no contiene datos en la propiedad "data" o el array está vacío.' }); }
        const sample = data[0];
        const fields = Object.keys(sample).map(key => ({ key, value: sample[key], label: keyToLabel(key), type: typeof sample[key], controlType: inferControlType(key, sample[key]) }));
        const pageSize = response.data.page?.pageSize;
        const serverPagination = pageSize !== undefined && pageSize < 9999;
        const result = { fields, paginationSettings: { serverPagination, filterInMemory: !serverPagination } };
        res.json(result);
    } catch (error) {
        console.error(`[DEV-API] Error escaneando el endpoint ${endpoint}:`, error.message);
        res.status(500).json({ message: `Error al escanear el endpoint: ${error.response?.statusText || error.message}` });
    }
});


app.post('/api/dev/generate-crud', async (req, res) => {
    try {
        const config = req.body;
        console.log('\n[DEV-API] Petición recibida en /api/dev/generate-crud');

        const {
            name, pluralName, navGroup, navIcon, showInMenu, apiEndpoint,
            useCreate, useUpdate, useRead, fields,
            security, actionsConfig, advancedConfig, fieldsBehavior
        } = config;

        if (!fields || !Array.isArray(fields)) {
            throw new Error("La propiedad 'fields' no fue recibida o no es un array en el servidor.");
        }

        const pascalToCamel = (str) => str.charAt(0).toLowerCase() + str.slice(1);
        const pascalToSnake = (str) => str.replace(/[A-Z]/g, (letter, index) => index === 0 ? letter.toLowerCase() : `_${letter.toLowerCase()}`);

        const camelName = pascalToCamel(name);
        const fileName = pascalToSnake(name).replace(/_/g, '-');
        const constName = toConstCase(name);
        const navUrl = camelName;

        const templatesPath = path.join(__dirname, '..', '..', '@fwk', '_templates', 'crud_template');
        const resourcesPath = path.join(__dirname, '..', '..', '..', 'src', 'app', 'resources');

        const targetPath = path.join(resourcesPath, fileName);
        if (await fs.pathExists(targetPath)) {
            return res.status(409).json({ message: `El directorio para "${fileName}" ya existe.` });
        }

        await fs.copy(templatesPath, targetPath);

        const finalActions = (actionsConfig.actions || []).map((action, index) => {
            const safeName = action.name.toLowerCase().replace(/[\s-]/g, '_').replace(/[^\w]/g, '');
            const actionKey = `${constName}_grid_action_${safeName}`;

            const finalAction = {
                actionNameKey: actionKey,
                icon: action.icon ? (action.icon.includes(':') ? action.icon : `heroicons_outline:${action.icon}`) : undefined,
                actionType: action.type,
                actionSecurity: action.security || null,
            };

            if (action.requiresConfirm) {
                finalAction.confirm = { message: action.confirmMessage || `¿Está seguro de que desea ejecutar la acción: ${action.name}?` };
            }

            if (action.type === 'form_modal') {
                if (actionFormDefs.has(index)) {
                    finalAction.formDef = {
                        fields: actionFormDefs.get(index),
                        showSubmitContinue: action.showSubmitContinue
                    };
                }
                if (action.ws?.endpoint) {
                    finalAction.ws = {
                        key: `${actionKey}_ws`,
                        method: action.ws.method || 'POST',
                        url: action.ws.isRelative ? `%%PREFIX_DOMAIN_API + '${action.ws.endpoint}'%%` : action.ws.endpoint
                    };
                }
            } else if (action.type === 'redirect') {
                finalAction.redirect = {
                    url: action.redirect.endpoint,
                    openTab: action.redirect.openTab
                };
            } else if (action.ws?.endpoint) {
                finalAction.ws = {
                    key: `${actionKey}_ws`,
                    method: action.ws.method || 'POST',
                    url: action.ws.isRelative ? `%%PREFIX_DOMAIN_API + '${action.ws.endpoint}'%%` : action.ws.endpoint
                };
            }

            const querystringObject = (action.querystring || []).reduce((acc, curr) => {
                if (curr.paramKey && curr.paramValue) {
                    acc[curr.paramKey] = curr.paramValue;
                }
                return acc;
            }, {});

            if (Object.keys(querystringObject).length > 0) {
                if (finalAction.redirect) finalAction.redirect.querystring = querystringObject;
                if (finalAction.ws) finalAction.ws.querystring = querystringObject;
            }

            if (action.displayCondition?.expression?.key) {
                finalAction.displayCondition = action.displayCondition;
            }

            finalAction.actionNameValue = action.name;

            return finalAction;
        });

        const files = await fs.readdir(targetPath, { recursive: true });
        for (const file of files) {
            const filePath = path.join(targetPath, file);
            if ((await fs.stat(filePath)).isDirectory()) continue;

            let content = await fs.readFile(filePath, 'utf8');
            const newFilePath = path.join(path.dirname(filePath), path.basename(filePath).replace(/__fileName__/g, fileName));

            content = content
                .replace(/__constName__/g, constName)
                .replace(/__fileName__/g, fileName);

            if (file.endsWith('.def.ts')) {
                let exportCsvString = '';
                if (advancedConfig.exportCsv === 'client') {
                    exportCsvString = `exportCsv: {\n        csvExportFileName: \`\${'${pluralName}'.replace(/\\s/g, '_')}.csv\`\n    },`;
                } else if (advancedConfig.exportCsv === 'server') {
                    exportCsvString = `exportCsv: {\n        csvExportFileName: \`\${'${pluralName}'.replace(/\\s/g, '_')}.csv\`,\n        ws: \`\${PREFIX_DOMAIN_API}${(apiEndpoint || camelName).replace(/^\/api\//, '')}/export\`\n    },`;
                }

                content = content
                    .replace(/__apiEndpoint__/g, (apiEndpoint || camelName).replace(/^\/api\//, ''))
                    .replace(/__formCreate__/g, useCreate ? `create: ${constName}_CREATE_FORM_FIELDS_DEF,` : '')
                    .replace(/__createBehavior__/g, useCreate ? `createBehavior: ${constName}_CREATE_FORM_BEHAVIOR_DEF,` : '')
                    .replace(/__formUpdate__/g, useUpdate ? `update: ${constName}_UPDATE_FORM_FIELDS_DEF,` : '')
                    .replace(/__updateBehavior__/g, useUpdate ? `updateBehavior: ${constName}_UPDATE_FORM_BEHAVIOR_DEF,` : '')
                    .replace(/__formRead__/g, useRead ? `read: ${constName}_READ_FORM_FIELDS_DEF` : '')
                    .replace(/__filterBehavior__/g, fields.some(f => f.inFilter) ? `filterBehavior: ${constName}_FILTER_FORM_BEHAVIOR_DEF,` : '')
                    .replace(/__filterInMemory__/g, advancedConfig.filterInMemory)
                    .replace(/__serverPagination__/g, advancedConfig.serverPagination)
                    .replace(/__cancelInitSearch__/g, advancedConfig.cancelInitSearch)
                    .replace(/__pageSize__/g, advancedConfig.pageSize)
                    .replace('width: \'600px\'', `width: '${advancedConfig.dialogWidth}'`)
                    .replace(/__exportCsv__/g, exportCsvString);

            } else if (file.includes(path.join('form', '')) && file.endsWith('.behavior.ts')) {
                const formType = path.basename(file).split('.')[1];
                const behaviorString = generateBehaviorString(fieldsBehavior, fields, formType, constName);
                content = `import { DynamicFieldBehavior } from "@fwk/model/dynamic-form/dynamic-field-behavior";\n${content}`;
                content = content.replace('= []', behaviorString);
            } else if (file.endsWith('.grid.ts')) {
                const gridFields = fields.filter(f => f.inGrid);
                const displayedColumnsString = gridFields.map(c => `'${c.key}'`).join(',\n    ');
                let needsApiPrefixImport = false;
                let needsFilterTypeImport = false;

                const actionsForGrid = finalActions.map(action => {
                    const { actionNameValue, displayCondition, ...actionForFile } = action;
                    if (action.ws?.url?.includes('PREFIX_DOMAIN_API')) needsApiPrefixImport = true;
                    if (displayCondition) needsFilterTypeImport = true;
                    return actionForFile;
                });
                const actionsString = objectToString(actionsForGrid, 2);

                const displayedActionsCondition = buildDisplayedActionsConditionFromArray(finalActions);
                const displayedActionsConditionString = displayedActionsCondition && displayedActionsCondition.length > 0
                    ? `displayedActionsCondition: ${objectToString(displayedActionsCondition, 2)},`
                    : '';

                if (needsApiPrefixImport) {
                    content = `import { PREFIX_DOMAIN_API } from "environments/environment";\n${content}`;
                }
                if (needsFilterTypeImport) {
                    content = `import { FILTER_TYPE } from "@fwk/services/filter-service/filter.service";\n${content}`;
                }

                content = content
                    .replace(/__deleteAction__/g, actionsConfig.deleteAction)
                    .replace(/actionCellClass: ''/g, `actionCellClass: '${advancedConfig.actionCellClass || ''}'`)
                    .replace(/groupActions: true/g, `groupActions: ${actionsConfig.groupActions}`)
                    .replace(/columnsDef: \[[^\]]*\]/s, `columnsDef: ${generateGridColumnsString(fields, constName)}`)
                    .replace(/displayedColumns: \[[^\]]*\]/s, `displayedColumns: [\n    ${displayedColumnsString}\n  ]`)
                    .replace(/actions: \[[^\]]*\]/s, `actions: ${actionsString}`)
                    .replace(/\/\*[\s\S]*?displayedActionsCondition:[\s\S]*?\*\//, displayedActionsConditionString);

            } else if (file.includes(path.join('form', '')) && file.endsWith('.fields.ts')) {
                const formType = path.basename(file).split('.')[1];
                let relevantFields = [];
                switch (formType) {
                    case 'filter': relevantFields = fields.filter(f => f.inFilter); break;
                    case 'create': relevantFields = fields.filter(f => f.key.toLowerCase() !== 'id'); break;
                    case 'update': case 'read': relevantFields = fields; break;
                    default: relevantFields = [];
                }
                content = content.replace('[]', generateFieldsString(relevantFields, constName, formType));

                if (content.includes('PREFIX_DOMAIN_API')) {
                    content = `import { PREFIX_DOMAIN_API } from "environments/environment";\n${content}`;
                }

                const fieldsString = generateFieldsString(relevantFields, constName, formType);

                content = `import { DynamicField } from "@fwk/model/dynamic-form/dynamic-field";\n${content}`;
                content = content.replace('= []', fieldsString);
            } else if (file.endsWith('.i18n.ts')) {
                content = content.replace(/__i18nWords__/g, generateI18nWords(fields, pluralName, fileName, constName, finalActions));
            } else if (file.endsWith('.nav.ts')) {
                const iconString = navIcon ? `'${'heroicons_outline:' + navIcon}'` : 'null';
                content = content
                    .replace(/__camelName__/g, camelName)
                    .replace(/__navGroup__/g, navGroup)
                    .replace(/__navIcon__/g, iconString)
                    .replace(/__navUrl__/g, navUrl)
                    .replace(/__showInMenu__/g, showInMenu);
            } else if (file.endsWith('.security.ts')) {
                const secDef = security.customize
                    ? `{\n  readAccess: ${security.readAccess ? `'${security.readAccess}'` : 'null'},\n  updateAccess: ${useUpdate && security.updateAccess ? `'${security.updateAccess}'` : 'null'},\n  createAccess: ${useCreate && security.createAccess ? `'${security.createAccess}'` : 'null'},\n  deleteAccess: ${actionsConfig.deleteAction && security.deleteAccess ? `'${security.deleteAccess}'` : 'null'}\n}`
                    : `{\n  readAccess: '${constName}_READ',\n  updateAccess: ${useUpdate ? `'${constName}_UPDATE'` : 'null'},\n  createAccess: ${useCreate ? `'${constName}_CREATE'` : 'null'},\n  deleteAccess: ${actionsConfig.deleteAction ? `'${constName}_DELETE'` : 'null'}\n}`;
                content = content.replace(/__securityDef__/g, secDef);
            }

            await fs.writeFile(newFilePath, content, 'utf8');
            if (filePath !== newFilePath) await fs.remove(filePath);
        }

        console.log(`[DEV-API] Archivos de CRUD generados en ${targetPath}`);

        const spinner = ora('Actualizando registros y notificando al servidor de desarrollo...').start();
        await new Promise(resolve => setTimeout(resolve, 500));

        exec('npm run generate:registries', async (error, stdout, stderr) => {
            if (error) {
                spinner.fail(chalk.red('CRUD generado, pero falló la regeneración del registro.'));
                console.error(`[DEV-API] Error al regenerar registros: ${stderr}`);
                return res.status(500).json({ message: 'CRUD generado, pero falló la regeneración del registro.', error: stderr });
            }

            spinner.succeed(chalk.green('Registros actualizados.'));
            console.log(stdout);

            try {
                await new Promise(resolve => setTimeout(resolve, 500));

                const appRoutesPath = path.join(__dirname, '..', '..', '..', 'src', 'app', 'app.routes.ts');
                fs.utimesSync(appRoutesPath, new Date(), new Date());

                spinner.succeed(chalk.green('Servidor de Angular notificado para recargar.'));

                res.json({ success: true, message: `CRUD "${pluralName}" generado. Recargando la aplicación...` });

            } catch (touchError) {
                spinner.fail(chalk.red('No se pudo notificar al servidor de Angular para recargar.'));
                console.error(`[DEV-API] Error al "tocar" app.routes.ts:`, touchError);
                res.status(500).json({ message: 'CRUD generado, pero falló la recarga automática.', error: touchError.message });
            }
        });

    } catch (error) {
        console.error('[DEV-API] Error crítico generando CRUD:', error);
        res.status(500).json({ message: 'Error interno al generar el CRUD.', error: error.message, stack: error.stack });
    }
});

function generateBehaviorString(behaviorData, allFields, formType, constName) {
    if (!behaviorData || !behaviorData[formType] || behaviorData[formType].length === 0) return '[]';

    const relevantBehaviors = behaviorData[formType];
    const behaviorString = objectToString(relevantBehaviors);

    const needsImport = behaviorString.includes('FILTER_TYPE');
    if (needsImport) {
        return `import { FILTER_TYPE } from '@fwk/services/filter-service/filter.service';\n\nexport const ${constName}_${formType.toUpperCase()}_FORM_BEHAVIOR_DEF = ${behaviorString};`;
    }

    return `: DynamicFieldBehavior[] = ${behaviorString}`;
}

function generateFieldsString(fields, constName, formType) {
    if (!fields || fields.length === 0) return '[]';

    const fieldObjects = fields.map(f => {
        let finalControlType = f.controlType;
        let finalDisabled = formType === 'read';
        if (f.key.toLowerCase() === 'id') {
            if (formType === 'create') return null;
            if (formType === 'update' || formType === 'read') finalControlType = 'hidden';
            if (formType === 'read' || formType === 'update') finalDisabled = true;
        }

        const fieldDef = {
            key: f.key,
            labelKey: `${constName.toUpperCase()}_${formType.toUpperCase()}_FORM_FIELDS_DEF_FIELD_${f.key.toLowerCase()}`,
            controlType: finalControlType,
        };

        if (f.required && !finalDisabled) fieldDef.required = true;
        if (finalDisabled) fieldDef.disabled = true;
        if (f.mappingQuerystring) fieldDef.mappingQuerystring = true;
        if (f.cssClass) fieldDef.cssClass = f.cssClass;

        ['minLength', 'maxLength', 'minValue', 'maxValue', 'length'].forEach(key => {
            if (f[key] !== null && f[key] !== undefined && f[key] !== '') {
                fieldDef[key] = f[key];
            }
        });

        ['requiredMessage', 'minLengthMessage', 'maxLengthMessage', 'minValueMessage', 'maxValueMessage', 'lengthMessage'].forEach(key => {
            if (f[key]) {
                fieldDef[key] = f[key];
            }
        });

        if (f.validations && f.validations.pattern) {
            fieldDef.validations = [{
                key: 'pattern',
                input: `%%${f.validations.pattern}%%`
            }];
        }

        const options = {};
        if (formType === 'filter' && f.isBaseFilter) {
            options.baseFilter = true;
        }

        if (f.options) {
            if (f.options.dataSourceType === 'static' && f.options.fromData) {
                try {
                    options.fromData = typeof f.options.fromData === 'string' ? JSON.parse(f.options.fromData) : f.options.fromData;
                } catch (e) {
                    console.warn(`[DEV-API] JSON inválido para 'fromData' en el campo ${f.key}, se guardará como string.`);
                    options.fromData = f.options.fromData;
                }
            }
            if (f.options.dataSourceType === 'api' && f.options.fromWsUrl) {
                options.fromWs = { key: `${f.key}_ws`, url: `%%PREFIX_DOMAIN_API + '${f.options.fromWsUrl}'%%` };
            }
            if (f.options.elementLabel) options.elementLabel = f.options.elementLabel;
            if (f.options.elementValue) options.elementValue = f.options.elementValue;
        }

        if (Object.keys(options).length > 0) {
            fieldDef.options = options;
        }

        return fieldDef;
    }).filter(Boolean);

    const fieldsString = objectToString(fieldObjects);

    return `: DynamicField<any>[] = ${fieldsString}`;
}

function generateGridColumnsString(fields, constName) {
    const gridFields = fields.filter(f => f.inGrid);
    if (!gridFields || gridFields.length === 0) return '[]';

    const columnObjects = gridFields.map(f => {
        let colDef = {
            columnDef: f.key,
            columnNameKey: `${constName.toLowerCase()}_grid_def_column_${f.key.toLowerCase()}`
        };
        if (f.headerClass) colDef.headerClass = f.headerClass;
        if (f.cellClass) colDef.cellClass = f.cellClass;
        if (f.columnType && f.columnType !== 'text') colDef.columnType = f.columnType;
        if (f.key.toLowerCase() === 'id') colDef.id = true;
        return colDef;
    });

    return objectToString(columnObjects);
}

function generateI18nWords(fields, pluralName, fileName, constName, actions) {
    const pageTitle = `'page_title': '${pluralName}'`;
    const navDef = `'${fileName.replace(/-/g, '_')}_nav_def': '${pluralName}'`;
    const gridWords = fields.filter(f => f.inGrid).map(field => `    '${constName.toLowerCase()}_grid_def_column_${field.key.toLowerCase()}': '${field.label}'`).join(',\n');
    const formTypes = ['create', 'update', 'read', 'filter'];
    const formWords = fields.flatMap(field => formTypes.map(type => `'${constName.toUpperCase()}_${type.toUpperCase()}_FORM_FIELDS_DEF_FIELD_${field.key.toLowerCase()}': '${field.label}'`)).join(',\n    ');

    const actionWords = (actions || []).map((action) => {
        if (!action.name) {
            return null;
        }
        const actionKey = `${constName}_grid_action_${action.name.toLowerCase().replace(/[\s-]/g, '_')}`;
        return `    '${actionKey}': '${action.name}'`;
    }).filter(Boolean).join(',\n');

    return [pageTitle, navDef, gridWords, formWords, actionWords].filter(Boolean).join(',\n    ');
}

app.get('/api/dev/navigation-groups', async (req, res) => {
    console.log('\n[DEV-API] Petición recibida en /api/dev/navigation-groups (GET)');
    try {
        const navGroupsPath = path.join(__dirname, '..', '..', '..', 'src', 'app', 'resources', 'navigation.groups.ts');
        const content = await fs.readFile(navGroupsPath, 'utf8');
        const arrayContentMatch = content.match(/export const NAVIGATION_GROUPS_MAP: NavigationGroup\[]\s*=\s*(\[[\s\S]*?\]);/);
        if (!arrayContentMatch || !arrayContentMatch[1]) { throw new Error('No se pudo encontrar o parsear el array NAVIGATION_GROUPS_MAP.'); }
        const arrayString = arrayContentMatch[1];
        const groups = eval(arrayString);
        res.json(groups);
    } catch (error) {
        console.error('[DEV-API] Error obteniendo grupos de navegación:', error.stack);
        res.status(500).json({ message: 'No se pudo leer el archivo de grupos de navegación.', error: error.message });
    }
});

app.post('/api/dev/generate-dashboard', async (req, res) => {
    try {
        const config = req.body;
        console.log('\n[DEV-API] Petición recibida en /api/dev/generate-dashboard');
        const {
            fileName, pageTitle, navGroup, navIcon, showInMenu, security, widgets
        } = config;

        if (!fileName || !pageTitle || !navGroup || !widgets || !Array.isArray(widgets) || !security) {
            return res.status(400).json({ message: 'La configuración del dashboard es incompleta o inválida.' });
        }

        const toCamelCase = (str) => str.replace(/[-_]([a-z])/g, g => g[1].toUpperCase());
        const constName = toConstCase(fileName);
        const camelName = toCamelCase(fileName);
        const navUrl = camelName;

        const resourcesPath = path.join(__dirname, '..', '..', '..', 'src', 'app', 'resources');
        const targetPath = path.join(resourcesPath, fileName);

        if (await fs.pathExists(targetPath)) {
            return res.status(409).json({ message: `El directorio para "${fileName}" ya existe.` });
        }

        await fs.copy(path.join(__dirname, '..', '..', '@fwk', '_templates', 'dashboard_template'), targetPath);

        const filterConstants = new Map();
        const i18nWidgetTitles = [];

        const widgetsWithDetails = widgets.map(w => {
            const widgetConstName = toConstCase(w.widgetTitle);
            const widgetTitleKey = `${fileName.replace(/-/g, '_')}_widget_${w.widgetTitle.toLowerCase().replace(/[ -]/g, '_')}`;
            i18nWidgetTitles.push({ key: widgetTitleKey, value: w.widgetTitle });

            const widgetDef = {
                type: w.widgetType,
                size: w.widgetSize,
                titleKey: widgetTitleKey,
                ws: {
                    key: `${widgetConstName}_URL`,
                    url: `%%PREFIX_STATS_API + '${w.widgetEndpoint}'%%`
                }
            };

            if (w.hasFilters && w.filters && w.filters.length > 0) {
                const filterConstName = `${constName}_${widgetConstName}_FILTERS`;
                const filterOptions = w.filters.map(f => ({
                    value: f.value || 'all',
                    viewValue: f.viewValue
                }));
                filterConstants.set(filterConstName, filterOptions);

                widgetDef.filterConfig = {
                    show: true,
                    options: `%%${filterConstName}%%`,
                    defaultOption: filterOptions[0].value,
                };
            }
            return widgetDef;
        });

        let filterConstantsString = '';
        if (filterConstants.size > 0) {
            filterConstants.forEach((options, name) => {
                filterConstantsString += `export const ${name} = ${objectToString(options)};\n\n`;
            });
        }

        const widgetsDefString = objectToString(widgetsWithDetails);

        const navDefKey = `${fileName.replace(/-/g, '_')}_nav_def`;
        const i18nWords = {
            'page_title': pageTitle,
            [navDefKey]: pageTitle,
            ...i18nWidgetTitles.reduce((acc, curr) => ({ ...acc, [curr.key]: curr.value }), {})
        };

        const i18nWordsString = objectToString(i18nWords, 2);

        const replacements = {
            '__constName__': constName,
            '__fileName__': fileName,
            '__navGroup__': navGroup,
            '__navIcon__': navIcon ? `'heroicons_outline:${navIcon}'` : 'null',
            '__navUrl__': navUrl,
            '__showInMenu__': showInMenu,
            '__camelName__': camelName,
        };

        const files = await fs.readdir(targetPath, { recursive: true });

        for (const file of files) {
            const filePath = path.join(targetPath, file);
            if ((await fs.stat(filePath)).isDirectory()) continue;

            const newFilePath = path.join(path.dirname(filePath), path.basename(filePath).replace('__fileName__', fileName));
            let content = await fs.readFile(filePath, 'utf8');

            if (file.endsWith('layout.ts')) {
                content = content.replace('__filterConstants__', filterConstantsString.trim());
                content = content.replace(/widgets:\s*\[\s*__widgetsDef__\s*\]/s, `widgets: ${widgetsDefString}`);
            } else if (file.endsWith('i18n.ts')) {
                content = content.replace(/words:\s*{\s*__i18nWords__\s*}/s, `words: ${i18nWordsString}`);
            }
            else if (file.endsWith('security.ts')) {
                const readAccess = security.customize ? (security.readAccess ? `'${security.readAccess}'` : 'null') : `'${constName}_READ'`;
                content = content.replace(/readAccess: '.*'/, `readAccess: ${readAccess}`);
            } else if (file.endsWith('nav.ts')) {
                content = content.replace(/translateKey: '__translateKey__',/, `translateKey: '${navDefKey}',`);
            }

            for (const key in replacements) {
                const value = replacements[key];
                content = content.replace(new RegExp(key, 'g'), value === null ? 'null' : String(value));
            }

            await fs.writeFile(newFilePath, content, 'utf8');
            if (filePath !== newFilePath) await fs.remove(filePath);
        }

        console.log(`[DEV-API] Archivos de Dashboard generados en ${targetPath}`);

        const spinner = ora('Actualizando registros y notificando al servidor de desarrollo...').start();

        exec('npm run generate:registries', async (error, stdout, stderr) => {
            if (error) {
                spinner.fail(chalk.red('Dashboard generado, pero falló la regeneración del registro.'));
                return res.status(500).json({ message: 'Dashboard generado, pero falló la regeneración del registro.', error: stderr });
            }

            spinner.succeed(chalk.green('Registros actualizados.'));
            console.log(stdout);

            try {
                await new Promise(resolve => setTimeout(resolve, 500));
                const appRoutesPath = path.join(__dirname, '..', '..', '..', 'src', 'app', 'app.routes.ts');
                fs.utimesSync(appRoutesPath, new Date(), new Date());
                spinner.succeed(chalk.green('Servidor de Angular notificado para recargar.'));
                res.json({ success: true, message: `Dashboard "${pageTitle}" generado. Recargando la aplicación...` });
            } catch (touchError) {
                spinner.fail(chalk.red('No se pudo notificar al servidor de Angular para recargar.'));
                res.status(500).json({ message: 'Dashboard generado, pero falló la recarga automática.', error: touchError.message });
            }
        });

    } catch (error) {
        console.error('[DEV-API] Error crítico generando Dashboard:', error);
        res.status(500).json({ message: 'Error interno al generar el Dashboard.', error: error.message, stack: error.stack });
    }
});

app.post('/api/dev/navigation-groups', async (req, res) => {
    console.log('\n[DEV-API] Petición recibida en /api/dev/navigation-groups (POST)');
    try {
        const { groups } = req.body;
        if (!Array.isArray(groups)) { return res.status(400).json({ message: 'El cuerpo de la petición debe contener un array "groups".' }); }
        const navGroupsPath = path.join(__dirname, '..', '..', '..', 'src', 'app', 'resources', 'navigation.groups.ts');
        const newGroupsString = groups.map(g => {
            const iconPart = g.icon ? `\n        icon: '${g.icon}',` : '';
            return `    {\n        id: '${g.id}',\n        title: '${g.title}',\n        type: 'group',${iconPart}\n    }`;
        }).join(',\n');
        const newFileContent = `import { FuseNavigationItem } from '@fuse/components/navigation';

export interface NavigationGroup extends FuseNavigationItem {
    id: string;
    title: string;
    type: 'group';
    icon?: string;
    children?: FuseNavigationItem[]; 
}

export const NAVIGATION_GROUPS_MAP: NavigationGroup[] = [
${newGroupsString}
];
`;
        await fs.writeFile(navGroupsPath, newFileContent, 'utf8');
        console.log(`[DEV-API] Archivo navigation.groups.ts actualizado con ${groups.length} grupos.`);
        const angularJsonPath = path.join(__dirname, '..', '..', '..', 'angular.json');
        fs.utimesSync(angularJsonPath, new Date(), new Date());
        res.json({ success: true, message: 'Grupos de navegación actualizados. El servidor se está recargando.' });
    } catch (error) {
        console.error('[DEV-API] Error actualizando grupos de navegación:', error.message);
        res.status(500).json({ message: 'No se pudo escribir en el archivo de grupos de navegación.', error: error.message });
    }
});

app.get('/api/dev/definitions', async (req, res) => {
    console.log('\n[DEV-API] Petición recibida en /api/dev/definitions');
    try {
        const resourcesPath = path.join(__dirname, '..', '..', '..', 'src', 'app', 'resources');
        const entries = await fs.readdir(resourcesPath, { withFileTypes: true });
        const directories = entries.filter(dirent => dirent.isDirectory() && dirent.name !== 'navigation.groups.ts').map(dirent => dirent.name);
        const definitions = (await Promise.all(directories.map(async (dir) => {
            const defPath = path.join(resourcesPath, dir, `${dir}.def.ts`);
            if (await fs.pathExists(defPath)) {
                return { id: dir, name: dir.replace(/_/g, ' ').replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase()) };
            }
            return null;
        }))).filter(Boolean);
        definitions.sort((a, b) => a.name.localeCompare(b.name));
        res.json(definitions);
    } catch (error) {
        res.status(500).json({ message: 'No se pudieron listar las definiciones.', error: error.message });
    }
});

app.get('/api/dev/definition/:name', async (req, res) => {
    const { name } = req.params;
    console.log(`\n[DEV-API] Petición para obtener definición: ${name}`);
    try {
        const resourcePath = path.join(__dirname, '..', '..', '..', 'src', 'app', 'resources', name);
        const constName = toConstCase(name);
        const finalDefinition = { forms: {} };

        const mainDefAST = parseFile(path.join(resourcePath, `${name}.def.ts`));

        if (mainDefAST) {
            traverse(mainDefAST, {
                VariableDeclarator(path) {
                    if (path.node.id.name === `${constName}_DEF` && t.isObjectExpression(path.node.init)) {
                        const props = path.node.init.properties;
                        [
                            'serverPagination',
                            'filterInMemory',
                            'cancelInitSearch',
                            'exportCsv',
                            'dialogConfig',
                            'pagination'
                        ].forEach(key => {
                            const prop = props.find(p => p.key.name === key);
                            if (prop) {
                                finalDefinition[key] = astNodeToJsValue(prop.value);
                            }
                        });

                        path.stop();
                    }
                }
            });
        }

        const extractVariableFromFile = async (filePath, varName) => {
            if (!await fs.pathExists(filePath)) return null;
            const ast = parseFile(filePath);
            if (!ast) return null;
            let foundNode = null;
            traverse(ast, {
                VariableDeclarator(path) {
                    if (path.node.id.name === varName) {
                        foundNode = path.node.init; path.stop();
                    }
                }
            });
            return astNodeToJsValue(foundNode);
        };

        finalDefinition.navigation = await extractVariableFromFile(path.join(resourcePath, 'navigation', `${name}.nav.ts`), `${constName}_NAV_DEF`);
        finalDefinition.security = await extractVariableFromFile(path.join(resourcePath, 'security', `${name}.security.ts`), `${constName}_SECURITY_DEF`);

        finalDefinition.i18n = await extractVariableFromFile(path.join(resourcePath, 'i18n', `${name}.i18n.ts`), `${constName}_I18N_DEF`);

        const enrichWithI18nValues = (items, keyProp, valueProp) => {
            if (!Array.isArray(items) || !finalDefinition.i18n?.words) return;
            items.forEach(item => {
                if (item && item[keyProp]) {
                    item[valueProp] = finalDefinition.i18n.words[item[keyProp]] || `[Clave no encontrada: ${item[keyProp]}]`;
                }
            });
        };

        if (finalDefinition.navigation && finalDefinition.i18n?.words && finalDefinition.navigation.translateKey) {
            finalDefinition.navigation.title = finalDefinition.i18n.words[finalDefinition.navigation.translateKey] || finalDefinition.navigation.translateKey;
        }

        const layoutFile = path.join(resourcePath, 'layout', `${name}.layout.ts`);
        if (await fs.pathExists(layoutFile)) {
            const layoutExports = await extractAllExportedVariables(layoutFile);
            const layoutDef = layoutExports[`${constName}_LAYOUT_DEF`];
            if (layoutDef) {
                const resolvedLayoutDef = resolveReferences(layoutDef, layoutExports);
                finalDefinition.dashboardConfig = resolvedLayoutDef;
            } else {
                finalDefinition.dashboardConfig = null;
            }
            enrichWithI18nValues(finalDefinition.dashboardConfig?.widgets, 'titleKey', 'titleValue');
        } else {
            finalDefinition.grid = await extractVariableFromFile(path.join(resourcePath, 'grid', `${name}.grid.ts`), `${constName}_GRID_DEF`);

            if (finalDefinition.grid?.displayedActionsCondition) {
                finalDefinition.grid.displayedActionsCondition.forEach(cond => {
                    if (cond.expression?.compare && cond.expression.compare.startsWith('FILTER_TYPE.')) {
                        cond.expression.compare = cond.expression.compare.split('.')[1];
                    }
                });
            }

            enrichWithI18nValues(finalDefinition.grid?.columnsDef, 'columnNameKey', 'columnNameValue');
            enrichWithI18nValues(finalDefinition.grid?.actions, 'actionNameKey', 'actionNameValue');

            for (const type of ['filter', 'create', 'update', 'read']) {
                const formData = await extractVariableFromFile(path.join(resourcePath, 'form', `${name}.${type}.fields.ts`), `${constName}_${type.toUpperCase()}_FORM_FIELDS_DEF`);
                finalDefinition.forms[type] = Array.isArray(formData) ? formData : [];
                enrichWithI18nValues(finalDefinition.forms[type], 'labelKey', 'labelValue');

                const behaviorFile = path.join(resourcePath, 'form', `${name}.${type}.behavior.ts`);
                if (await fs.pathExists(behaviorFile)) {
                    finalDefinition.forms[`${type}Behavior`] = await extractVariableFromFile(behaviorFile, `${constName}_${type.toUpperCase()}_FORM_BEHAVIOR_DEF`);
                }
            }
        }
        console.log(`[DEV-API] Definición completa de '${name}' parseada. Enviando al cliente.`);
        res.json(finalDefinition);
    } catch (error) {
        console.error(`[DEV-API] Error obteniendo la definición '${name}':`, error.stack);
        res.status(500).json({ message: `No se pudo parsear la definición '${name}'.`, error: error.message });
    }
});

app.post('/api/dev/definition/:name', async (req, res) => {
    const { name } = req.params;
    const { i18nUpdates, ...updates } = req.body;
    console.log(`\n[DEV-API] Petición para GUARDAR definición: ${name}`);
    console.log('[DEV-API] Payload de cambios recibido:', JSON.stringify(updates, null, 2));

    try {
        const resourcePath = path.join(__dirname, '..', '..', '..', 'src', 'app', 'resources', name);
        const constName = toConstCase(name);
        const mainDefAST = parseFile(path.join(resourcePath, `${name}.def.ts`));

        if (mainDefAST) {
            traverse(mainDefAST, {
                VariableDeclarator(path) {
                    if (path.node.id.name === `${constName}_DEF` && t.isObjectExpression(path.node.init)) {
                        const props = path.node.init.properties;

                        ['serverPagination', 'filterInMemory', 'cancelInitSearch', 'exportCsv', 'dialogConfig', 'pagination'].forEach(key => {
                            const prop = props.find(p => p.key.name === key);
                            if (prop) finalDefinition[key] = prop.value.value;
                        });

                        ['exportCsv', 'dialogConfig', 'pagination'].forEach(key => {
                            const prop = props.find(p => p.key.name === key);
                            if (prop) finalDefinition[key] = astNodeToJsValue(prop.value);
                        });

                        path.stop();
                    }
                }
            });
        }

        const mainDefFile = path.join(resourcePath, `${name}.def.ts`);
        const mainDefContent = await fs.readFile(mainDefFile, 'utf8');

        const allI18nUpdates = req.body.i18nUpdates || {};

        if (updates.navigation) {
            console.log(chalk.yellow(`[DEV-API] ADVERTENCIA: Se recibió 'navigation' en el endpoint general, pero será ignorado. Usa el endpoint específico.`));
            delete updates.navigation;
        }
        if (updates.security) {
            console.log(chalk.yellow(`[DEV-API] ADVERTENCIA: Se recibió 'security' en el endpoint general, pero será ignorado. Usa el endpoint específico.`));
            delete updates.security;
        }

        ['serverPagination', 'filterInMemory', 'cancelInitSearch', 'exportCsv', 'pageSize', 'dialogConfig'].forEach(key => {
            if (updates.hasOwnProperty(key)) {
                console.log(chalk.yellow(`[DEV-API] ADVERTENCIA: Se recibió '${key}' en el endpoint general, pero será ignorado.`));
                delete updates[key];
            }
        });


        if (updates.dashboardConfig) {
            console.log(chalk.yellow(`[DEV-API] ADVERTENCIA: Se recibió 'dashboardConfig' en el endpoint general, pero será ignorado.`));
            delete updates.dashboardConfig;
        }

        if (updates.grid) {
            console.log(chalk.yellow(`[DEV-API] ADVERTENCIA: Se recibió 'grid' en el endpoint general, pero será ignorado.`));
            delete updates.grid;
        }

        if (updates.forms) {
            console.log(chalk.yellow(`[DEV-API] ADVERTENCIA: Se recibió 'forms' en el endpoint general, pero será ignorado.`));
            delete updates.forms;
        }

        const mainDefUpdates = {};

        if (Object.keys(mainDefUpdates).length > 0) {
            await updateVariableInFile(path.join(resourcePath, `${name}.def.ts`), `${constName}_DEF`, mainDefUpdates);
        }

        if (allI18nUpdates && Object.keys(allI18nUpdates).length > 0) {
            const i18nPath = path.join(resourcePath, 'i18n', `${name}.i18n.ts`);
            const i18nAST = parseFile(i18nPath);
            if (i18nAST) {
                traverse(i18nAST, {
                    ObjectProperty(path) {
                        if ((path.node.key.name || path.node.key.value) === 'words' && t.isObjectExpression(path.node.value)) {

                            const wordsNode = path.node.value;
                            const existingKeys = new Set(
                                wordsNode.properties.map(prop => prop.key.name || prop.key.value)
                            );

                            wordsNode.properties.forEach(prop => {
                                if (t.isObjectProperty(prop)) {
                                    const keyName = prop.key.name || prop.key.value;
                                    if (allI18nUpdates.hasOwnProperty(keyName) && prop.value.value !== allI18nUpdates[keyName]) {
                                        prop.value = t.stringLiteral(String(allI18nUpdates[keyName]));
                                    }
                                }
                            });

                            for (const key in allI18nUpdates) {
                                if (!existingKeys.has(key)) {
                                    console.log(chalk.green(`   + Añadiendo nueva clave i18n: ${key}`));
                                    const newProperty = t.objectProperty(
                                        t.stringLiteral(key),
                                        t.stringLiteral(String(allI18nUpdates[key]))
                                    );
                                    wordsNode.properties.push(newProperty);
                                }
                            }

                            path.stop();
                        }
                    }
                });

                const { code: newI18nCode } = generate(i18nAST, { jsescOption: { quotes: 'single' } });
                await fs.writeFile(i18nPath, newI18nCode, 'utf8');
                console.log(chalk.blue(` -> Archivo i18n '${path.basename(i18nPath)}' actualizado.`));
            }
        }

        const angularJsonPath = path.join(__dirname, '..', '..', '..', 'angular.json');
        fs.utimesSync(angularJsonPath, new Date(), new Date());
        console.log(`[DEV-API] Forzando reinicio del servidor de desarrollo de Angular.`);

        res.json({ success: true, message: `Definición "${name}" guardada exitosamente` });
    } catch (error) {
        console.error(`[DEV-API] Error guardando la definición '${name}':`, error.stack);
        res.status(500).json({ message: `No se pudo guardar la definición '${name}'.`, error: error.message });
    }
});

app.post('/api/dev/definition/:name', async (req, res) => {
    const { name } = req.params;
    const { i18nUpdates, ...updates } = req.body;
    console.log(`\n[DEV-API] Petición para GUARDAR definición: ${name}`);
    console.log('[DEV-API] Payload de cambios recibido:', JSON.stringify(updates, null, 2));

    try {
        const resourcePath = path.join(__dirname, '..', '..', '..', 'src', 'app', 'resources', name);
        const constName = toConstCase(name);
        const mainDefAST = parseFile(path.join(resourcePath, `${name}.def.ts`));

        if (mainDefAST) {
            traverse(mainDefAST, {
                VariableDeclarator(path) {
                    if (path.node.id.name === `${constName}_DEF` && t.isObjectExpression(path.node.init)) {
                        const props = path.node.init.properties;

                        ['serverPagination', 'filterInMemory', 'cancelInitSearch', 'exportCsv', 'dialogConfig', 'pagination'].forEach(key => {
                            const prop = props.find(p => p.key.name === key);
                            if (prop) finalDefinition[key] = prop.value.value;
                        });

                        ['exportCsv', 'dialogConfig', 'pagination'].forEach(key => {
                            const prop = props.find(p => p.key.name === key);
                            if (prop) finalDefinition[key] = astNodeToJsValue(prop.value);
                        });

                        path.stop();
                    }
                }
            });
        }

        const mainDefFile = path.join(resourcePath, `${name}.def.ts`);
        const mainDefContent = await fs.readFile(mainDefFile, 'utf8');

        const allI18nUpdates = req.body.i18nUpdates || {};

        if (updates.navigation) {
            console.log(chalk.yellow(`[DEV-API] ADVERTENCIA: Se recibió 'navigation' en el endpoint general, pero será ignorado. Usa el endpoint específico.`));
            delete updates.navigation;
        }
        if (updates.security) {
            console.log(chalk.yellow(`[DEV-API] ADVERTENCIA: Se recibió 'security' en el endpoint general, pero será ignorado. Usa el endpoint específico.`));
            delete updates.security;
        }

        ['serverPagination', 'filterInMemory', 'cancelInitSearch', 'exportCsv', 'pageSize', 'dialogConfig'].forEach(key => {
            if (updates.hasOwnProperty(key)) {
                console.log(chalk.yellow(`[DEV-API] ADVERTENCIA: Se recibió '${key}' en el endpoint general, pero será ignorado.`));
                delete updates[key];
            }
        });


        if (updates.dashboardConfig) {
            console.log(chalk.yellow(`[DEV-API] ADVERTENCIA: Se recibió 'dashboardConfig' en el endpoint general, pero será ignorado.`));
            delete updates.dashboardConfig;
        }

        if (updates.grid) {
            console.log(chalk.yellow(`[DEV-API] ADVERTENCIA: Se recibió 'grid' en el endpoint general, pero será ignorado.`));
            delete updates.grid;
        }

        if (updates.forms) {
            console.log(chalk.yellow(`[DEV-API] ADVERTENCIA: Se recibió 'forms' en el endpoint general, pero será ignorado.`));
            delete updates.forms;
        }

        const mainDefUpdates = {};

        if (Object.keys(mainDefUpdates).length > 0) {
            await updateVariableInFile(path.join(resourcePath, `${name}.def.ts`), `${constName}_DEF`, mainDefUpdates);
        }

        if (allI18nUpdates && Object.keys(allI18nUpdates).length > 0) {
            const i18nPath = path.join(resourcePath, 'i18n', `${name}.i18n.ts`);
            const i18nAST = parseFile(i18nPath);
            if (i18nAST) {
                traverse(i18nAST, {
                    ObjectProperty(path) {
                        if ((path.node.key.name || path.node.key.value) === 'words' && t.isObjectExpression(path.node.value)) {

                            const wordsNode = path.node.value;
                            const existingKeys = new Set(
                                wordsNode.properties.map(prop => prop.key.name || prop.key.value)
                            );

                            wordsNode.properties.forEach(prop => {
                                if (t.isObjectProperty(prop)) {
                                    const keyName = prop.key.name || prop.key.value;
                                    if (allI18nUpdates.hasOwnProperty(keyName) && prop.value.value !== allI18nUpdates[keyName]) {
                                        prop.value = t.stringLiteral(String(allI18nUpdates[keyName]));
                                    }
                                }
                            });

                            for (const key in allI18nUpdates) {
                                if (!existingKeys.has(key)) {
                                    console.log(chalk.green(`   + Añadiendo nueva clave i18n: ${key}`));
                                    const newProperty = t.objectProperty(
                                        t.stringLiteral(key),
                                        t.stringLiteral(String(allI18nUpdates[key]))
                                    );
                                    wordsNode.properties.push(newProperty);
                                }
                            }

                            path.stop();
                        }
                    }
                });

                const { code: newI18nCode } = generate(i18nAST, { jsescOption: { quotes: 'single' } });
                await fs.writeFile(i18nPath, newI18nCode, 'utf8');
                console.log(chalk.blue(` -> Archivo i18n '${path.basename(i18nPath)}' actualizado.`));
            }
        }

        const angularJsonPath = path.join(__dirname, '..', '..', '..', 'angular.json');
        fs.utimesSync(angularJsonPath, new Date(), new Date());
        console.log(`[DEV-API] Forzando reinicio del servidor de desarrollo de Angular.`);

        res.json({ success: true, message: `Definición "${name}" guardada exitosamente` });
    } catch (error) {
        console.error(`[DEV-API] Error guardando la definición '${name}':`, error.stack);
        res.status(500).json({ message: `No se pudo guardar la definición '${name}'.`, error: error.message });
    }
});

app.get('/api/dev/i18n-main', async (req, res) => {
    console.log('\n[DEV-API] Petición recibida en /api/dev/i18n-main (GET)');
    try {
        const i18nPath = path.join(__dirname, '..', '..', '@fwk', 'i18n', 'fwk.i18n.ts');
        const indexPath = path.join(__dirname, '..', '..', '..', 'src', 'index.html');

        const indexContent = await fs.readFile(indexPath, 'utf8');
        const $ = cheerio.load(indexContent);
        const meta = {
            title: $('title').text(),
            description: $('meta[name="description"]').attr('content')
        };

        const i18nContent = await fs.readFile(i18nPath, 'utf8');
        const ast = parseFile(i18nPath);
        if (!ast) throw new Error('No se pudo parsear el AST de fwk.i18n.ts');

        let words = {};
        traverse(ast, {
            ObjectProperty(path) {
                if (path.node.key.name === 'words') {
                    words = astNodeToJsValue(path.node.value);
                    path.stop();
                }
            }
        });

        const categories = [];
        const categoryRegex = /\/\/\s*---\s*(.+?)\s*---/g;
        let match;

        while ((match = categoryRegex.exec(i18nContent)) !== null) {
            if (categories.length > 0) {
                categories[categories.length - 1].endIndex = match.index;
            }
            categories.push({ name: match[1], startIndex: match.index, endIndex: i18nContent.length, keys: [] });
        }

        if (categories.length === 0) {
            categories.push({ name: 'General', startIndex: 0, endIndex: i18nContent.length, keys: [] });
        }

        const lines = i18nContent.split('\n');

        Object.entries(words).forEach(([key, value]) => {
            const keyRegex = new RegExp(`'${key}'|"${key}"|${key}:`);
            const lineIndex = lines.findIndex(line => keyRegex.test(line));
            const charIndex = lineIndex !== -1 ? lines.slice(0, lineIndex).join('\n').length : -1;

            let assigned = false;
            for (const category of categories) {
                if (charIndex >= category.startIndex && charIndex < category.endIndex) {
                    category.keys.push({ key, value });
                    assigned = true;
                    break;
                }
            }
            if (!assigned && categories.length > 0) {
                categories[0].keys.push({ key, value });
            }
        });

        const finalCategories = categories.map(({ name, keys }) => ({ name, keys }));

        res.json({ meta, categories: finalCategories });

    } catch (error) {
        console.error('[DEV-API] Error obteniendo datos de I18N:', error.stack);
        res.status(500).json({ message: 'No se pudo leer la configuración principal de I18N.', error: error.message });
    }
});

app.post('/api/dev/i18n-main', async (req, res) => {
    console.log('\n[DEV-API] Petición recibida en /api/dev/i18n-main (POST)');
    try {
        const { meta, categories } = req.body;
        if (!meta || !Array.isArray(categories)) {
            return res.status(400).json({ message: 'El cuerpo de la petición es inválido.' });
        }

        const indexPath = path.join(__dirname, '..', '..', '..', 'src', 'index.html');
        const indexContent = await fs.readFile(indexPath, 'utf8');
        const $ = cheerio.load(indexContent);
        $('title').text(meta.title);
        $('meta[name="description"]').attr('content', meta.description);
        await fs.writeFile(indexPath, $.html(), 'utf8');
        console.log(' -> index.html actualizado.');

        const i18nPath = path.join(__dirname, '..', '..', '@fwk', 'i18n', 'fwk.i18n.ts');
        const ast = parseFile(i18nPath);
        if (!ast) throw new Error('No se pudo parsear el AST de fwk.i18n.ts');

        const newWordsObject = categories.flatMap(cat => cat.keys).reduce((obj, item) => {
            obj[item.key] = item.value;
            return obj;
        }, {});

        traverse(ast, {
            ObjectProperty(path) {
                if (path.node.key.name === 'words' && t.isObjectExpression(path.node.value)) {

                    const wordsNode = path.node.value;
                    const existingKeys = new Set();

                    wordsNode.properties.forEach(prop => {
                        if (t.isObjectProperty(prop)) {
                            const keyName = prop.key.name || prop.key.value;
                            existingKeys.add(keyName);

                            if (newWordsObject.hasOwnProperty(keyName) && prop.value.value !== newWordsObject[keyName]) {
                                prop.value = t.stringLiteral(String(newWordsObject[keyName]));
                            }
                        }
                    });

                    for (const key in newWordsObject) {
                        if (!existingKeys.has(key)) {
                            console.log(`[DEV-API] Añadiendo nueva clave i18n que no existía: ${key}`);
                            const newProperty = t.objectProperty(
                                t.stringLiteral(key),
                                t.stringLiteral(String(newWordsObject[key]))
                            );
                            wordsNode.properties.push(newProperty);
                        }
                    }
                    path.stop();
                }
            }
        });

        const { code } = generate(ast, {
            retainLines: false,
            comments: true,
            jsescOption: {
                quotes: 'single',
                minimal: true
            }
        });

        await fs.writeFile(i18nPath, code, 'utf8');
        console.log(' -> fwk.i18n.ts actualizado correctamente.');

        const angularJsonPath = path.join(__dirname, '..', '..', '..', 'angular.json');
        fs.utimesSync(angularJsonPath, new Date(), new Date());
        console.log('[DEV-API] Forzando reinicio del servidor de desarrollo de Angular.');

        res.json({ success: true, message: 'Textos actualizados. El servidor se está recargando.' });

    } catch (error) {
        console.error('[DEV-API] Error guardando datos de I18N:', error.stack);
        res.status(500).json({ message: 'No se pudo guardar la configuración de I18N.', error: error.message });
    }
});

// navigation definition editor
async function updateNavFile(name, navigationData) {
    const resourcePath = path.join(__dirname, '..', '..', '..', 'src', 'app', 'resources', name);
    const constName = toConstCase(name);
    const navPath = path.join(resourcePath, 'navigation', `${name}.nav.ts`);

    await updateVariableInFile(navPath, `${constName}_NAV_DEF`, navigationData);
}
async function updateNavI18nFile(name, i18nUpdates) {
    if (!i18nUpdates || Object.keys(i18nUpdates).length === 0) {
        return;
    }
    const resourcePath = path.join(__dirname, '..', '..', '..', 'src', 'app', 'resources', name);
    const i18nPath = path.join(resourcePath, 'i18n', `${name}.i18n.ts`);
    const i18nAST = parseFile(i18nPath);

    if (i18nAST) {
        traverse(i18nAST, {
            ObjectProperty(path) {
                if ((path.node.key.name || path.node.key.value) === 'words' && t.isObjectExpression(path.node.value)) {
                    path.node.value.properties.forEach(prop => {
                        if (t.isObjectProperty(prop)) {
                            const keyName = prop.key.name || prop.key.value;
                            if (i18nUpdates.hasOwnProperty(keyName) && prop.value.value !== i18nUpdates[keyName]) {
                                prop.value = t.stringLiteral(String(i18nUpdates[keyName]));
                            }
                        }
                    });
                    path.stop();
                }
            }
        });
        const { code: newI18nCode } = generate(i18nAST, { jsescOption: { quotes: 'single' } });
        await fs.writeFile(i18nPath, newI18nCode, 'utf8');
        console.log(chalk.blue(` -> Archivo i18n '${path.basename(i18nPath)}' actualizado para navegación.`));
    }
}
app.post('/api/dev/definition/:name/navigation', async (req, res) => {
    const { name } = req.params;
    const { navigationData, i18nUpdates } = req.body;
    console.log(`\n[DEV-API] Petición para GUARDAR NAVEGACIÓN de: ${name}`);

    try {
        let hasNavChanges = navigationData && Object.keys(navigationData).length > 0;
        let hasI18nChanges = i18nUpdates && Object.keys(i18nUpdates).length > 0;

        if (!hasNavChanges && !hasI18nChanges) {
            return res.status(400).json({ message: 'No se enviaron datos para actualizar.' });
        }

        if (hasNavChanges) {
            await updateNavFile(name, navigationData);
        }

        if (hasI18nChanges) {
            await updateNavI18nFile(name, i18nUpdates);
        }

        const angularJsonPath = path.join(__dirname, '..', '..', '..', 'angular.json');
        fs.utimesSync(angularJsonPath, new Date(), new Date());
        console.log(`[DEV-API] Forzando reinicio del servidor de desarrollo de Angular.`);

        res.json({ success: true, message: `Navegación para "${name}" guardada.` });
    } catch (error) {
        console.error(`[DEV-API] Error guardando la navegación de '${name}':`, error.stack);
        res.status(500).json({ message: `No se pudo guardar la navegación de '${name}'.`, error: error.message });
    }
});

// security definition editor
async function updateSecurityFile(name, securityData) {
    const resourcePath = path.join(__dirname, '..', '..', '..', 'src', 'app', 'resources', name);
    const constName = toConstCase(name);
    const securityPath = path.join(resourcePath, 'security', `${name}.security.ts`);
    await updateVariableInFile(securityPath, `${constName}_SECURITY_DEF`, securityData);
}
app.post('/api/dev/definition/:name/security', async (req, res) => {
    const { name } = req.params;
    const securityData = req.body;
    console.log(`\n[DEV-API] Petición para GUARDAR SEGURIDAD de: ${name}`);

    try {
        await updateSecurityFile(name, securityData);

        const angularJsonPath = path.join(__dirname, '..', '..', '..', 'angular.json');
        fs.utimesSync(angularJsonPath, new Date(), new Date());
        console.log(`[DEV-API] Forzando reinicio del servidor de desarrollo de Angular.`);

        res.json({ success: true, message: `Seguridad para "${name}" guardada.` });
    } catch (error) {
        console.error(`[DEV-API] Error guardando la seguridad de '${name}':`, error.stack);
        res.status(500).json({ message: `No se pudo guardar la seguridad de '${name}'.`, error: error.message });
    }
});

// crud-config definition editor
async function updateCrudConfigFile(name, crudConfigData) {
    const resourcePath = path.join(__dirname, '..', '..', '..', 'src', 'app', 'resources', name);
    const constName = toConstCase(name);

    const mainDefUpdates = {
        serverPagination: crudConfigData.serverPagination,
        filterInMemory: crudConfigData.filterInMemory,
        cancelInitSearch: crudConfigData.cancelInitSearch,
        pagination: {
            page: 0,
            pageSize: crudConfigData.pageSize
        },
        dialogConfig: { width: crudConfigData.dialogWidth }
    };

    if (crudConfigData.exportCsv) {
        let exportCsvValue = null;
        const { type, csvExportFileName, ws } = crudConfigData.exportCsv;
        if (type === 'client' && csvExportFileName) {
            exportCsvValue = {
                type: 'client',
                csvExportFileName: `%%'${csvExportFileName}.csv'%%`
            };
        } else if (type === 'server' && csvExportFileName) {
            exportCsvValue = {
                type: 'server',
                csvExportFileName: `%%'${csvExportFileName}.csv'%%`,
                ws: ws ? `%%PREFIX_DOMAIN_API + '${ws}'%%` : undefined
            };
        }
        mainDefUpdates.exportCsv = exportCsvValue;
    }
    await updateVariableInFile(path.join(resourcePath, `${name}.def.ts`), `${constName}_DEF`, mainDefUpdates);
}
app.post('/api/dev/definition/:name/crud-config', async (req, res) => {
    const { name } = req.params;
    const crudConfigData = req.body;
    console.log(`\n[DEV-API] Petición para GUARDAR CONFIG CRUD de: ${name}`);

    try {
        await updateCrudConfigFile(name, crudConfigData);

        const angularJsonPath = path.join(__dirname, '..', '..', '..', 'angular.json');
        fs.utimesSync(angularJsonPath, new Date(), new Date());
        console.log(`[DEV-API] Forzando reinicio del servidor de desarrollo de Angular.`);

        res.json({ success: true, message: `Configuración de CRUD para "${name}" guardada.` });
    } catch (error) {
        console.error(`[DEV-API] Error guardando la config de CRUD de '${name}':`, error.stack);
        res.status(500).json({ message: `No se pudo guardar la config de CRUD de '${name}'.`, error: error.message });
    }
});

// grid-editor definition editor
async function updateGridFile(name, gridData, i18nUpdates) {
    const resourcePath = path.join(__dirname, '..', '..', '..', 'src', 'app', 'resources', name);
    const constName = toConstCase(name);

    if (gridData?.columnsDef && Array.isArray(gridData.columnsDef)) {
        gridData.columnsDef.forEach(col => {
            delete col.columnNameValue;

            if (col.headerClass === '' || col.headerClass === null || col.headerClass === undefined) {
                delete col.headerClass;
            }
            if (col.cellClass === '' || col.cellClass === null || col.cellClass === undefined) {
                delete col.cellClass;
            }
            if (col.id === false || col.id === null || col.id === undefined) {
                delete col.id;
            }
            if (col.columnType === '' || col.columnType === null || col.columnType === undefined) {
                delete col.columnType;
            }
        });
    }

    if (gridData?.actions) {
        gridData.actions.forEach(action => {
            delete action.displayCondition;
        });

        const displayedActionsCondition = buildDisplayedActionsConditionFromArray(gridData.actions);
        if (displayedActionsCondition && displayedActionsCondition.length > 0) {
            gridData.displayedActionsCondition = displayedActionsCondition;
        } else {
            delete gridData.displayedActionsCondition;
        }
    }

    await updateVariableInFile(path.join(resourcePath, 'grid', `${name}.grid.ts`), `${constName}_GRID_DEF`, gridData);

    if (i18nUpdates && Object.keys(i18nUpdates).length > 0) {
        const i18nPath = path.join(resourcePath, 'i18n', `${name}.i18n.ts`);
        const i18nAST = parseFile(i18nPath);
        if (i18nAST) {
            traverse(i18nAST, {
                ObjectProperty(path) {
                    if ((path.node.key.name || path.node.key.value) === 'words' && t.isObjectExpression(path.node.value)) {
                        const wordsNode = path.node.value;
                        const existingKeys = new Set(wordsNode.properties.map(prop => prop.key.name || prop.key.value));

                        wordsNode.properties.forEach(prop => {
                            if (t.isObjectProperty(prop)) {
                                const keyName = prop.key.name || prop.key.value;
                                if (i18nUpdates.hasOwnProperty(keyName) && prop.value.value !== i18nUpdates[keyName]) {
                                    prop.value = t.stringLiteral(String(i18nUpdates[keyName]));
                                }
                            }
                        });

                        for (const key in i18nUpdates) {
                            if (!existingKeys.has(key)) {
                                console.log(chalk.green(`   + Añadiendo nueva clave i18n de grilla: ${key}`));
                                const newProperty = t.objectProperty(
                                    t.stringLiteral(key),
                                    t.stringLiteral(String(i18nUpdates[key]))
                                );
                                wordsNode.properties.push(newProperty);
                            }
                        }

                        path.stop();
                    }
                }
            });
            const { code: newI18nCode } = generate(i18nAST, { jsescOption: { quotes: 'single' } });
            await fs.writeFile(i18nPath, newI18nCode, 'utf8');
            console.log(chalk.blue(` -> Archivo i18n '${path.basename(i18nPath)}' actualizado para grilla.`));
        }
    }
}

app.post('/api/dev/definition/:name/grid', async (req, res) => {
    const { name } = req.params;
    const { gridData, i18nUpdates } = req.body;
    console.log(`\n[DEV-API] Petición para GUARDAR GRID de: ${name}`);

    try {
        await updateGridFile(name, gridData, i18nUpdates);

        const angularJsonPath = path.join(__dirname, '..', '..', '..', 'angular.json');
        fs.utimesSync(angularJsonPath, new Date(), new Date());
        console.log(`[DEV-API] Forzando reinicio del servidor de desarrollo de Angular.`);

        res.json({ success: true, message: `Configuración de grilla para "${name}" guardada.` });
    } catch (error) {
        console.error(`[DEV-API] Error guardando la grilla de '${name}':`, error.stack);
        res.status(500).json({ message: `No se pudo guardar la grilla de '${name}'.`, error: error.message });
    }
});

// form-editor definition editor
async function updateFormVariableInFile(filePath, varName, newData) {
    if (!await fs.pathExists(filePath)) {
        console.warn(chalk.yellow(`[DEV-API] ADVERTENCIA: No se encontró el archivo ${filePath}. Saltando actualización.`));
        return;
    }

    const ast = parseFile(filePath);
    if (!ast) return;

    let variableFound = false;
    traverse(ast, {
        VariableDeclarator(path) {
            if (path.node.id.name === varName) {
                variableFound = true;
                path.node.init = jsValueToASTNode(newData);
                path.stop();
            }
        }
    });

    if (!variableFound) {
        console.warn(chalk.yellow(`[DEV-API] ADVERTENCIA: No se encontró la variable '${varName}' en '${filePath}'.`));
        return;
    }

    const { code: tempCode } = generate(ast);

    const potentialImports = [
        { keyword: 'PREFIX_DOMAIN_API', path: 'environments/environment' },
        { keyword: 'PREFIX_STATS_API', path: 'environments/environment' },
        { keyword: 'FILTER_TYPE', path: '@fwk/services/filter-service/filter.service' }
    ];

    potentialImports.forEach(imp => {
        if (tempCode.includes(imp.keyword)) {
            let isAlreadyImported = false;
            traverse(ast, {
                ImportDeclaration(path) {
                    if (path.node.source.value === imp.path) {
                        if (path.node.specifiers.some(spec => spec.imported && spec.imported.name === imp.keyword)) {
                            isAlreadyImported = true;
                            path.stop();
                        }
                    }
                }
            });

            if (!isAlreadyImported) {
                console.log(chalk.gray(`   -> Inyectando import para '${imp.keyword}' en '${path.basename(filePath)}'.`));
                const importSpecifier = t.importSpecifier(t.identifier(imp.keyword), t.identifier(imp.keyword));
                const importDeclaration = t.importDeclaration([importSpecifier], t.stringLiteral(imp.path));
                ast.program.body.unshift(importDeclaration);
            }
        }
    });

    const { code } = generate(ast, { retainLines: false, comments: true, jsescOption: { quotes: 'single' } });

    await fs.writeFile(filePath, code, 'utf8');
    console.log(chalk.blue(` -> Archivo '${path.basename(filePath)}' actualizado para la variable '${varName}'.`));
}

async function updateFormsFile(name, formsData, i18nUpdates) {
    const resourcePath = path.join(__dirname, '..', '..', '..', 'src', 'app', 'resources', name);
    const constName = toConstCase(name);
    const neededBehaviors = {};

    for (const type in formsData) {
        const isBehavior = type.endsWith('Behavior');
        const formType = isBehavior ? type.replace('Behavior', '') : type;
        const fileName = isBehavior ? `${name}.${formType}.behavior.ts` : `${name}.${formType}.fields.ts`;
        const varName = isBehavior ? `${constName}_${formType.toUpperCase()}_FORM_BEHAVIOR_DEF` : `${constName}_${formType.toUpperCase()}_FORM_FIELDS_DEF`;
        const filePath = path.join(resourcePath, 'form', fileName);

        if (isBehavior && formsData[type].length > 0) {
            neededBehaviors[formType] = true;
        }

        if (!await fs.pathExists(filePath) && isBehavior) {
            console.log(chalk.yellow(`[DEV-API] Creando archivo de behavior faltante: ${fileName}`));
            const templatePath = path.join(__dirname, '..', '..', '@fwk', '_templates', 'crud_template', 'form', `__fileName__.${formType}.behavior.ts`);
            let templateContent = await fs.readFile(templatePath, 'utf8');
            templateContent = templateContent.replace(/__constName__/g, constName).replace(/__fileName__/g, name);
            await fs.writeFile(filePath, templateContent, 'utf8');
        }

        if (await fs.pathExists(filePath)) {
            await updateFormVariableInFile(filePath, varName, formsData[type]);
        } else {
            console.warn(chalk.yellow(`[DEV-API] ADVERTENCIA: No se encontró el archivo ${filePath} y no es de tipo behavior. No se pudo crear/actualizar.`));
        }
    }

    const mainDefPath = path.join(resourcePath, `${name}.def.ts`);
    const mainDefAst = parseFile(mainDefPath);
    if (mainDefAst) {
        const requiredImports = [];
        for (const formType in neededBehaviors) {
            requiredImports.push({
                varName: `${constName}_${formType.toUpperCase()}_FORM_BEHAVIOR_DEF`,
                path: `./form/${name}.${formType}.behavior`
            });
        }

        const existingImports = new Set();
        traverse(mainDefAst, {
            ImportDeclaration(path) {
                const specifier = path.node.specifiers.find(s => s.local.name.endsWith('BEHAVIOR_DEF'));
                if (specifier) {
                    existingImports.add(specifier.local.name);
                }
            }
        });

        requiredImports.forEach(imp => {
            if (!existingImports.has(imp.varName)) {
                console.log(chalk.green(`   + Añadiendo import para: ${imp.varName}`));
                const importSpecifier = t.importSpecifier(t.identifier(imp.varName), t.identifier(imp.varName));
                const importDeclaration = t.importDeclaration([importSpecifier], t.stringLiteral(imp.path));
                mainDefAst.program.body.unshift(importDeclaration);
            }
        });

        traverse(mainDefAst, {
            ObjectProperty(path) {
                if (path.node.key.name === 'forms' && t.isObjectExpression(path.node.value)) {
                    const formsObject = path.node.value;
                    const existingProps = new Set(formsObject.properties.map(p => p.key.name));

                    for (const formType in neededBehaviors) {
                        const propName = `${formType}Behavior`;
                        if (!existingProps.has(propName)) {
                            console.log(chalk.green(`   + Añadiendo propiedad: ${propName}`));
                            const newProperty = t.objectProperty(
                                t.identifier(propName),
                                t.identifier(`${constName}_${formType.toUpperCase()}_FORM_BEHAVIOR_DEF`)
                            );
                            formsObject.properties.push(newProperty);
                        }
                    }
                    path.stop();
                }
            }
        });

        const { code } = generate(mainDefAst, { jsescOption: { quotes: 'single' } });
        await fs.writeFile(mainDefPath, code, 'utf8');
        console.log(chalk.blue(` -> Archivo principal '${path.basename(mainDefPath)}' actualizado con imports/propiedades de behavior.`));
    }


    if (i18nUpdates && Object.keys(i18nUpdates).length > 0) {
        const i18nPath = path.join(resourcePath, 'i18n', `${name}.i18n.ts`);
        const i18nAST = parseFile(i18nPath);
        if (i18nAST) {
            traverse(i18nAST, {
                ObjectProperty(path) {
                    if ((path.node.key.name || path.node.key.value) === 'words' && t.isObjectExpression(path.node.value)) {
                        const wordsNode = path.node.value;
                        const existingKeys = new Set(
                            wordsNode.properties.map(prop => prop.key.name || prop.key.value)
                        );

                        wordsNode.properties.forEach(prop => {
                            if (t.isObjectProperty(prop)) {
                                const keyName = prop.key.name || prop.key.value;
                                if (i18nUpdates.hasOwnProperty(keyName) && prop.value.value !== i18nUpdates[keyName]) {
                                    prop.value = t.stringLiteral(String(i18nUpdates[keyName]));
                                }
                            }
                        });

                        for (const key in i18nUpdates) {
                            if (!existingKeys.has(key)) {
                                console.log(chalk.green(`   + Añadiendo nueva clave i18n de formulario: ${key}`));
                                const newProperty = t.objectProperty(
                                    t.stringLiteral(key),
                                    t.stringLiteral(String(i18nUpdates[key]))
                                );
                                wordsNode.properties.push(newProperty);
                            }
                        }

                        path.stop();
                    }
                }
            });
            const { code: newI18nCode } = generate(i18nAST, { jsescOption: { quotes: 'single' } });
            await fs.writeFile(i18nPath, newI18nCode, 'utf8');
            console.log(chalk.blue(` -> Archivo i18n '${path.basename(i18nPath)}' actualizado para formularios.`));
        }
    }
}

app.post('/api/dev/definition/:name/forms', async (req, res) => {
    const { name } = req.params;
    const { formsData, i18nUpdates } = req.body;
    console.log(`\n[DEV-API] Petición para GUARDAR FORMULARIOS de: ${name}`);

    try {
        await updateFormsFile(name, formsData, i18nUpdates);

        const angularJsonPath = path.join(__dirname, '..', '..', '..', 'angular.json');
        fs.utimesSync(angularJsonPath, new Date(), new Date());
        console.log(`[DEV-API] Forzando reinicio del servidor de desarrollo de Angular.`);

        res.json({ success: true, message: `Formularios para "${name}" guardados.` });
    } catch (error) {
        console.error(`[DEV-API] Error guardando los formularios de '${name}':`, error.stack);
        res.status(500).json({ message: `No se pudo guardar la configuración de formularios de '${name}'.`, error: error.message });
    }
});

async function extractAllExportedVariables(filePath) {
    const ast = parseFile(filePath);
    if (!ast) return {};
    const exports = {};
    traverse(ast, {
        VariableDeclarator(path) {
            if (path.parentPath.parent.type === 'ExportNamedDeclaration') {
                if (t.isIdentifier(path.node.id)) {
                    exports[path.node.id.name] = astNodeToJsValue(path.node.init);
                }
            }
        }
    });
    return exports;
};

async function updateDashboardFile(name, dashboardData, i18nUpdates) {
    const resourcePath = path.join(__dirname, '..', '..', '..', 'src', 'app', 'resources', name);
    const constName = toConstCase(name);

    const filterConstants = new Map();
    const widgetsWithDetails = (dashboardData.widgets || []).map(w => {
        const widgetDef = {
            titleKey: w.titleKey,
            type: w.type,
            size: w.size,
            ws: {
                key: w.ws.key,
                url: `%%PREFIX_STATS_API + '${w.ws.url}'%%`
            }
        };

        if (w.filterConfig.show && w.filterConfig.options && w.filterConfig.options.length > 0) {
            const widgetConstName = toConstCase(w.titleValue);
            const filterConstName = `${constName}_${widgetConstName}_FILTERS`;
            filterConstants.set(filterConstName, w.filterConfig.options);
            widgetDef.filterConfig = {
                show: true,
                options: `%%${filterConstName}%%`,
                defaultOption: w.filterConfig.defaultOption,
            };
        }
        return widgetDef;
    });

    let filterConstantsString = '';
    if (filterConstants.size > 0) {
        filterConstants.forEach((options, constName) => {
            filterConstantsString += `export const ${constName} = ${objectToString(options)};\n\n`;
        });
    }

    const widgetsDefString = objectToString(widgetsWithDetails);

    const layoutFilePath = path.join(resourcePath, 'layout', `${name}.layout.ts`);
    let layoutFileContent = await fs.readFile(layoutFilePath, 'utf8');

    layoutFileContent = layoutFileContent.replace(/export const .*_FILTERS\s*=\s*\[[\s\S]*?\];\s*\n/g, '');

    const layoutDefRegex = new RegExp(`export const ${constName}_LAYOUT_DEF: DashboardLayoutDef = {([\\s\\S]*?)};`);
    const newLayoutDefString = `export const ${constName}_LAYOUT_DEF: DashboardLayoutDef = {\n    pageIdentifier: '${name}',\n    sectionTitleKey: 'page_title',\n    widgets: ${widgetsDefString}\n};`;

    if (layoutDefRegex.test(layoutFileContent)) {
        layoutFileContent = layoutFileContent.replace(layoutDefRegex, newLayoutDefString);
    } else {
        layoutFileContent += `\n${newLayoutDefString}\n`;
    }

    const importStatement = "import { PREFIX_STATS_API } from 'environments/environment';";
    const newContentWithImports = `${importStatement}\n\n${filterConstantsString}${layoutFileContent.replace(importStatement, '')}`;

    await fs.writeFile(layoutFilePath, newContentWithImports, 'utf8');
    console.log(chalk.blue(` -> Archivo de layout '${path.basename(layoutFilePath)}' actualizado.`));

    if (i18nUpdates && Object.keys(i18nUpdates).length > 0) {
        const i18nPath = path.join(resourcePath, 'i18n', `${name}.i18n.ts`);
        const i18nAST = parseFile(i18nPath);
        if (i18nAST) {
            let wordsUpdated = false;
            traverse(i18nAST, {
                ObjectProperty(path) {
                    if ((path.node.key.name || path.node.key.value) === 'words' && t.isObjectExpression(path.node.value)) {
                        wordsUpdated = true;
                        const wordsNode = path.node.value;
                        const existingKeys = new Set(
                            wordsNode.properties.map(prop => prop.key.name || prop.key.value)
                        );

                        wordsNode.properties.forEach(prop => {
                            if (t.isObjectProperty(prop)) {
                                const keyName = prop.key.name || prop.key.value;
                                if (i18nUpdates.hasOwnProperty(keyName) && prop.value.value !== i18nUpdates[keyName]) {
                                    prop.value = t.stringLiteral(String(i18nUpdates[keyName]));
                                }
                            }
                        });

                        for (const key in i18nUpdates) {
                            if (!existingKeys.has(key)) {
                                const keyNode = /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(key)
                                    ? t.identifier(key)
                                    : t.stringLiteral(key);

                                const newProperty = t.objectProperty(
                                    keyNode,
                                    t.stringLiteral(String(i18nUpdates[key]))
                                );
                                wordsNode.properties.push(newProperty);
                            }
                        }
                        path.stop();
                    }
                }
            });

            if (wordsUpdated) {
                const { code: newI18nCode } = generate(i18nAST, { jsescOption: { quotes: 'single' } });
                await fs.writeFile(i18nPath, newI18nCode, 'utf8');
                console.log(chalk.blue(` -> Archivo i18n '${path.basename(i18nPath)}' actualizado.`));
            }
        }
    }
}

app.post('/api/dev/definition/:name/dashboard-config', async (req, res) => {
    const { name } = req.params;
    const { dashboardData, i18nUpdates } = req.body;
    console.log(`\n[DEV-API] Petición para GUARDAR DASHBOARD de: ${name}`);

    try {
        await updateDashboardFile(name, dashboardData, i18nUpdates);

        const angularJsonPath = path.join(__dirname, '..', '..', '..', 'angular.json');
        fs.utimesSync(angularJsonPath, new Date(), new Date());
        console.log(`[DEV-API] Forzando reinicio del servidor de desarrollo de Angular.`);

        res.json({ success: true, message: `Configuración de dashboard para "${name}" guardada.` });
    } catch (error) {
        console.error(`[DEV-API] Error guardando el dashboard de '${name}':`, error.stack);
        res.status(500).json({ message: `No se pudo guardar la configuración de dashboard de '${name}'.`, error: error.message });
    }
});

app.listen(port, () => {
    console.log(`[DEV-API] Escuchando en http://localhost:${port}`);
});

--- FILE: @fwk/_scripts/generate-registries.js ---

const { globSync } = require('glob');
const fs = require('fs');
const path = require('path');

console.log('🚀 Iniciando generador de registros CRUD...');

const ignoredDirs = [''];

function snakeToCamel(str) {
    return str.replace(/_([a-z])/g, (g) => g[1].toUpperCase());
}

const projectRoot = path.resolve(__dirname, '..', '..', '..');
const resourcesPath = path.join(projectRoot, 'src', 'app', 'resources');
const registryFilePath = path.join(projectRoot, 'src', 'app', 'core', 'registries', 'crud.registry.ts');

let existingPaths = new Set();
try {
    if (fs.existsSync(registryFilePath)) {
        const oldContent = fs.readFileSync(registryFilePath, 'utf8');
        const pathRegex = /path: '([^']+)'/g;
        let match;
        while ((match = pathRegex.exec(oldContent)) !== null) {
            existingPaths.add(match[1]);
        }
    }
} catch (e) {
    console.warn('⚠️ No se pudo leer el archivo de registro existente para comparar cambios.');
}

const defFiles = globSync(path.join(resourcesPath, '**', '*.def.ts').replace(/\\/g, '/'))
    .filter(file => {
        const dirName = path.basename(path.dirname(file));
        return !ignoredDirs.includes(dirName);
    });

const crudModules = [];
const allCrudDefsForNav = [];

defFiles.forEach(file => {
    const fileContent = fs.readFileSync(file, 'utf8');
    const constNameMatch = fileContent.match(/export const (\w+_DEF): (CrudDef|PageComponentDef)/);
    if (!constNameMatch) {
        console.warn(`⚠️  No se encontró una constante _DEF en: ${file}`);
        return;
    }
    const constName = constNameMatch[1];
    
    let routePath = '';

    const navConstMatch = fileContent.match(/navigation: (\w+_NAV_DEF)/);
    if (navConstMatch) {
        const navConstName = navConstMatch[1];
        const navImportMatch = fileContent.match(new RegExp(`import { ${navConstName} } from '([^']+)';`));
        if (navImportMatch) {
            const navImportPath = navImportMatch[1];
            const navFilePath = path.resolve(path.dirname(file), `${navImportPath}.ts`);
            try {
                const navFileContent = fs.readFileSync(navFilePath, 'utf8');
                const urlMatch = navFileContent.match(/url: '([^']*)'/);
                if (urlMatch && urlMatch[1]) {
                    routePath = urlMatch[1].replace(/^\//, '');
                }
            } catch (e) {
                console.warn(`- No se pudo leer el archivo de navegación para ${constName}.`);
            }
        }
    }

    if (!routePath) {
        const folderName = path.basename(path.dirname(file));
        routePath = snakeToCamel(folderName);
        console.warn(`- No se encontró URL en NAV_DEF para ${constName}. Usando fallback: '${routePath}'`);
    }

    const importPath = path.relative(path.join(projectRoot, 'src'), file).replace(/\\/g, '/').replace(/\.ts$/, '');
    
    crudModules.push({
        path: routePath,
        importPath: importPath
    });

    allCrudDefsForNav.push(importPath);
});

crudModules.sort((a, b) => a.path.localeCompare(b.path));
allCrudDefsForNav.sort();

const crudRegistryContent = `import { CrudDef } from "@fwk/model/component-def/crud-def";

export interface CrudModuleDefinition {
    path: string;
    loader: () => Promise<any>;
}

export const CRUD_MODULES: CrudModuleDefinition[] = [
${crudModules.map(m => `    {
        path: '${m.path}',
        loader: () => import('${m.importPath}')
    }`).join(',\n')},
];

export async function loadAllCrudDefs(): Promise<CrudDef[]> {
    const loaderPromises = [
${allCrudDefsForNav.map(p => `        import('${p}')`).join(',\n')},
    ];
    
    const loadedModules = await Promise.all(loaderPromises);

    return loadedModules.map(module => {
        const defKey = Object.keys(module).find(key => key.endsWith('_DEF'));
        return defKey ? module[defKey] : null;
    }).filter(Boolean) as CrudDef[];
}

export async function loadCrudDefByPath(path: string): Promise<CrudDef | null> {
    const moduleDefinition = CRUD_MODULES.find(m => m.path === path);
    if (!moduleDefinition) {
        return null;
    }
    const loadedModule = await moduleDefinition.loader();
    const defKey = Object.keys(loadedModule).find(key => key.endsWith('_DEF'));
    return defKey ? loadedModule[defKey] : null;
}
`;

try {
    fs.writeFileSync(registryFilePath, crudRegistryContent);
    console.log(`\n✅ Archivo de registro actualizado exitosamente en: ${registryFilePath}`);
    console.log(`   Se encontraron y registraron ${crudModules.length} CRUDs.`);

    const newPaths = new Set(crudModules.map(m => m.path));
    const addedCruds = [...newPaths].filter(p => !existingPaths.has(p));
    const removedCruds = [...existingPaths].filter(p => !newPaths.has(p));

    if (addedCruds.length > 0) {
        console.log('\n➕ CRUDs Agregados:');
        addedCruds.forEach(c => console.log(`   - ${c}`));
    }
    if (removedCruds.length > 0) {
        console.log('\n➖ CRUDs Eliminados:');
        removedCruds.forEach(c => console.log(`   - ${c}`));
    }
    if (addedCruds.length === 0 && removedCruds.length === 0 && existingPaths.size > 0) {
        console.log('\n🔄 No se detectaron cambios en los registros.');
    }

} catch (err) {
    console.error(`\n❌ Error al escribir el archivo de registro:`, err);
}

console.log('\n✨ Proceso completado.');

--- FILE: @fwk/_templates/crud_template/form/__fileName__.create.behavior.ts ---

export const __constName___CREATE_FORM_BEHAVIOR_DEF = [];

--- FILE: @fwk/_templates/crud_template/form/__fileName__.create.fields.ts ---

export const __constName___CREATE_FORM_FIELDS_DEF = [];

--- FILE: @fwk/_templates/crud_template/form/__fileName__.filter.behavior.ts ---

export const __constName___FILTER_FORM_BEHAVIOR_DEF = [];

--- FILE: @fwk/_templates/crud_template/form/__fileName__.filter.fields.ts ---

export const __constName___FILTER_FORM_FIELDS_DEF = [];

--- FILE: @fwk/_templates/crud_template/form/__fileName__.read.fields.ts ---

export const __constName___READ_FORM_FIELDS_DEF = [];

--- FILE: @fwk/_templates/crud_template/form/__fileName__.update.behavior.ts ---

export const __constName___UPDATE_FORM_BEHAVIOR_DEF = [];

--- FILE: @fwk/_templates/crud_template/form/__fileName__.update.fields.ts ---

export const __constName___UPDATE_FORM_FIELDS_DEF = [];

--- FILE: @fwk/_templates/crud_template/grid/__fileName__.grid.ts ---

import { GridDef } from "@fwk/model/component-def/grid-def";

export const __constName___GRID_DEF: GridDef = {
  actionCellClass: '',
  groupActions: true,
  columnsDef: [],
  sortAllColumns: true,
  deleteAction: __deleteAction__,
  displayedColumns: [],
  actions: [],
};

--- FILE: @fwk/_templates/crud_template/i18n/__fileName__.i18n.ts ---

import { I18n } from "@fwk/model/i18n";

export const __constName___I18N_DEF: I18n = {
  name: '__constName___I18N_DEF',
  lang: 'es',
  words: {
    __i18nWords__
  }
};

--- FILE: @fwk/_templates/crud_template/navigation/__fileName__.nav.ts ---

import { NavigationDef } from "@fwk/model/component-def/navigation-def";

export const __constName___NAV_DEF: NavigationDef = {
    id: '__navGroup__.__camelName__',
    translateKey: '__fileName___nav_def',
    url: '/__navUrl__',
    icon: __navIcon__,
    group: '__navGroup__',
    showInMenu: __showInMenu__
};

--- FILE: @fwk/_templates/crud_template/security/__fileName__.security.ts ---

import { SecurityDef } from "@fwk/model/component-def/security-def";

export const __constName___SECURITY_DEF: SecurityDef = __securityDef__;

--- FILE: @fwk/_templates/crud_template/__fileName__.def.ts ---

import { __constName___CREATE_FORM_FIELDS_DEF } from './form/__fileName__.create.fields';
import { __constName___UPDATE_FORM_FIELDS_DEF } from './form/__fileName__.update.fields';
import { __constName___READ_FORM_FIELDS_DEF } from './form/__fileName__.read.fields';
import { __constName___FILTER_FORM_FIELDS_DEF } from './form/__fileName__.filter.fields';
import { __constName___CREATE_FORM_BEHAVIOR_DEF } from './form/__fileName__.create.behavior';
import { __constName___UPDATE_FORM_BEHAVIOR_DEF } from './form/__fileName__.update.behavior';
import { __constName___FILTER_FORM_BEHAVIOR_DEF } from './form/__fileName__.filter.behavior';
import { __constName___SECURITY_DEF } from './security/__fileName__.security';
import { __constName___GRID_DEF } from './grid/__fileName__.grid';
import { __constName___I18N_DEF } from './i18n/__fileName__.i18n';
import { __constName___NAV_DEF } from './navigation/__fileName__.nav';
import { CrudDef } from '@fwk/model/component-def/crud-def';
import { PREFIX_DOMAIN_API } from 'environments/environment';

export const __constName___DEF: CrudDef = { 
    name: '__constName__',
    i18n: __constName___I18N_DEF,
    grid: __constName___GRID_DEF, 
    forms: {
        filter: __constName___FILTER_FORM_FIELDS_DEF, 
        __filterBehavior__
        __formCreate__
        __createBehavior__
        __formUpdate__
        __updateBehavior__
        __formRead__
    },
    navigation: __constName___NAV_DEF,
    security: __constName___SECURITY_DEF,
    ws: {
        key: '__constName___CRUD_URL',
        url: PREFIX_DOMAIN_API + '__apiEndpoint__'
    },
    dialogConfig: {
        width: '600px'
    },
    __exportCsv__
    filterInMemory: __filterInMemory__,
    serverPagination: __serverPagination__,
    pagination: {
        page: 0,
        pageSize: __pageSize__
    },
    cancelInitSearch: __cancelInitSearch__
};

--- FILE: @fwk/_templates/dashboard_template/i18n/__fileName__.i18n.ts ---

export const __constName___I18N_DEF = {
  name: '__constName___I18N_DEF',
  lang: 'es',
  words: {
    __i18nWords__
  }
};

--- FILE: @fwk/_templates/dashboard_template/layout/__fileName__.layout.ts ---

import { DashboardLayoutDef } from '@fwk/model/component-def/dashboard-def';
import { PREFIX_STATS_API } from 'environments/environment';

__filterConstants__

export const __constName___LAYOUT_DEF: DashboardLayoutDef = {
    pageIdentifier: '__fileName__',
    sectionTitleKey: 'page_title',
    widgets: [
        __widgetsDef__
    ]
};

--- FILE: @fwk/_templates/dashboard_template/navigation/__fileName__.nav.ts ---

export const __constName___NAV_DEF = {
    id: '__navGroup__.__camelName__',
    translateKey: '__translateKey__',
    url: '/__navUrl__',
    icon: __navIcon__,
    group: '__navGroup__',
    showInMenu: __showInMenu__
};

--- FILE: @fwk/_templates/dashboard_template/security/__fileName__.security.ts ---

export const __constName___SECURITY_DEF = {
    readAccess: '__constName___READ',
    updateAccess: null,
    createAccess: null,
    deleteAccess: null
};

--- FILE: @fwk/_templates/dashboard_template/__fileName__.def.ts ---

import { __constName___SECURITY_DEF } from './security/__fileName__.security';
import { __constName___I18N_DEF } from './i18n/__fileName__.i18n';
import { __constName___NAV_DEF } from './navigation/__fileName__.nav';
import { __constName___LAYOUT_DEF } from './layout/__fileName__.layout';
import { CrudDef } from '@fwk/model/component-def/crud-def';

export const __constName___DEF: CrudDef = { 
    name: '__constName__',
    i18n: __constName___I18N_DEF,
    navigation: __constName___NAV_DEF,
    security: __constName___SECURITY_DEF,
    dashboardConfig: __constName___LAYOUT_DEF,
};

--- FILE: app/app.component.html ---

<router-outlet></router-outlet>


--- FILE: app/app.component.ts ---

import { Component, ViewEncapsulation } from '@angular/core';
import { RouterOutlet } from '@angular/router';
import { CrudRegistryService } from '@fwk/services/crud-registry.service';
import { I18nService } from '@fwk/services/i18n-service/i18n.service';
import { FWK_I18N_DEF } from '@fwk/i18n/fwk.i18n';

@Component({
    selector: 'app-root',
    standalone: true,
    imports: [RouterOutlet],
    templateUrl: './app.component.html',
    styleUrls: ['./app.component.scss'],
    encapsulation: ViewEncapsulation.None,
})
export class AppComponent {
    constructor(
        private registry: CrudRegistryService,
        private i18nService: I18nService
    ) {
        this.registerGlobalI18n();
    }

    private registerGlobalI18n(): void {
        this.i18nService.addI18n(FWK_I18N_DEF as any);
    }
}

--- FILE: app/app.config.ts ---

import { ApplicationConfig, importProvidersFrom, LOCALE_ID } from '@angular/core';
import { registerLocaleData } from '@angular/common'; 
import localeEs from '@angular/common/locales/es';

import { provideRouter, withComponentInputBinding, withInMemoryScrolling, withRouterConfig } from '@angular/router';
import { provideAnimations } from '@angular/platform-browser/animations';
import { provideHttpClient, withInterceptorsFromDi } from '@angular/common/http';
import { MatDialogModule } from '@angular/material/dialog';
import { appRoutes } from 'app/app.routes';
import { provideFuse } from '@fuse';
import { Scheme } from '@fuse/services/config';

import { provideFwkAuth, provideAppAuth } from '@fwk/auth/auth.provider';
import { provideFwkCore } from '@fwk/providers/core.provider';
import { provideAppNavigation } from '@fwk/navigation/navigation.provider';

registerLocaleData(localeEs, 'es');

function getInitialScheme(): Scheme {
    const storedScheme = localStorage.getItem('fuse-theme-scheme');
    if (storedScheme === 'light' || storedScheme === 'dark' || storedScheme === 'auto') {
        return storedScheme;
    }
    return 'light';
}

export const appConfig: ApplicationConfig = {
    providers: [
        { provide: LOCALE_ID, useValue: 'es' }, 

        provideAnimations(),
        provideHttpClient(withInterceptorsFromDi()),
        provideRouter(
            appRoutes,
            withInMemoryScrolling({ scrollPositionRestoration: 'enabled' }),
            withComponentInputBinding(),
            withRouterConfig({ onSameUrlNavigation: 'reload' })
        ),
        importProvidersFrom(MatDialogModule),

        provideFwkCore(),
        provideFwkAuth(),
        provideAppAuth(),
        provideAppNavigation(),

        provideFuse({
            mockApi: undefined,
            fuse: {
                layout: 'dense',
                scheme: getInitialScheme(), 
                screens: {
                    sm: '600px',
                    md: '960px',
                    lg: '1280px',
                    xl: '1440px',
                },
                theme: 'theme-default',
                themes: [
                    {
                        id: 'theme-default',
                        name: 'Default',
                    },
                ],
            },
        }),
    ],
};

--- FILE: app/app.resolvers.ts ---

import { inject } from '@angular/core';
import { NavigationService } from '@fwk/navigation/navigation.service';
import { forkJoin } from 'rxjs';

export const initialDataResolver = () =>
{
    const navigationService = inject(NavigationService);

    return forkJoin([
        navigationService.get(),
    ]);
};

--- FILE: app/app.routes.ts ---

import { Route } from '@angular/router';
import { initialDataResolver } from 'app/app.resolvers';
import { AuthGuard } from '@fwk/auth/guards/auth.guard';
import { NoAuthGuard } from '@fwk/auth/guards/noAuth.guard';
import { LayoutComponent } from '@fwk/layout/layout.component';
import { InitialRedirectComponent } from '@fwk/auth/guards/initial-redirect.component';
import { CRUD_MODULES } from 'app/core/registries/crud.registry';
import { generateFwkPageRoutes } from '@fwk/utils/crud-route-generator';
import { DevModeGuard } from '@fwk/auth/guards/dev-mode.guard';

export const appRoutes: Route[] = [
    {
        path: '',
        pathMatch: 'full',
        canActivate: [NoAuthGuard],
        component: InitialRedirectComponent
    },
    { path: 'signed-in-redirect', pathMatch: 'full', redirectTo: 'welcome' },

    {
        path: '',
        canActivate: [NoAuthGuard],
        canActivateChild: [NoAuthGuard],
        component: LayoutComponent,
        data: { layout: 'empty' },
        children: [
            { path: 'confirmation-required', loadChildren: () => import('@fwk/auth/components/confirmation-required/confirmation-required.routes') },
            { path: 'forgot-password', loadChildren: () => import('@fwk/auth/components/forgot-password/forgot-password.routes') },
            { path: 'reset-password', loadChildren: () => import('@fwk/auth/components/reset-password/reset-password.routes') },
            { path: 'sign-in', loadChildren: () => import('@fwk/auth/components/sign-in/sign-in.routes') },
            { path: 'sign-up', loadChildren: () => import('@fwk/auth/components/sign-up/sign-up.routes') }
        ]
    },

    {
        path: '',
        canActivate: [AuthGuard],
        canActivateChild: [AuthGuard],
        component: LayoutComponent,
        resolve: { initialData: initialDataResolver },
        children: [
            {
                path: 'dev-tools',
                canActivate: [DevModeGuard],
                data: { layout: 'dense' },
                loadChildren: () => import('@fwk/modules/dev-tools/dev-tools.routes')
            },
            { path: 'unlock-session', data: { layout: 'empty' }, loadChildren: () => import('@fwk/auth/components/unlock-session/unlock-session.routes') },
            { path: 'welcome', loadChildren: () => import('app/modules/welcome/welcome.routes') },
            ...CRUD_MODULES.map(crudModule => ({
                path: crudModule.path,
                data: {
                    //
                },
                loadChildren: () => Promise.resolve(generateFwkPageRoutes(crudModule.loader))
            })),
        ]
    },

    {
        path: '',
        component: LayoutComponent,
        data: { layout: 'empty' },
        children: [
            { path: 'sign-out', loadChildren: () => import('@fwk/auth/components/sign-out/sign-out.routes') },
            { path: '403', loadChildren: () => import('@fwk/modules/error/error-403/error-403.routes') },
            { path: '404', loadChildren: () => import('@fwk/modules/error/error-404/error-404.routes') },
        ]
    },

    { path: '**', redirectTo: '/404' }
];

--- FILE: app/core/registries/crud.registry.ts ---

import { CrudDef } from "@fwk/model/component-def/crud-def";

export interface CrudModuleDefinition {
    path: string;
    loader: () => Promise<any>;
}

export const CRUD_MODULES: CrudModuleDefinition[] = [
    {
        path: 'abmroles',
        loader: () => import('app/resources/abm_roles/abm_roles.def')
    },
    {
        path: 'actividad',
        loader: () => import('app/resources/actividad/actividad.def')
    },
    {
        path: 'banner',
        loader: () => import('app/resources/banner/banner.def')
    },
    {
        path: 'estadisticasContenidos',
        loader: () => import('app/resources/estadisticas-contenidos/estadisticas-contenidos.def')
    },
    {
        path: 'upload-files',
        loader: () => import('app/resources/upload_files/upload_files.def')
    },
];

export async function loadAllCrudDefs(): Promise<CrudDef[]> {
    const loaderPromises = [
        import('app/resources/abm_roles/abm_roles.def'),
        import('app/resources/actividad/actividad.def'),
        import('app/resources/banner/banner.def'),
        import('app/resources/estadisticas-contenidos/estadisticas-contenidos.def'),
        import('app/resources/upload_files/upload_files.def'),
    ];
    
    const loadedModules = await Promise.all(loaderPromises);

    return loadedModules.map(module => {
        const defKey = Object.keys(module).find(key => key.endsWith('_DEF'));
        return defKey ? module[defKey] : null;
    }).filter(Boolean) as CrudDef[];
}

export async function loadCrudDefByPath(path: string): Promise<CrudDef | null> {
    const moduleDefinition = CRUD_MODULES.find(m => m.path === path);
    if (!moduleDefinition) {
        return null;
    }
    const loadedModule = await moduleDefinition.loader();
    const defKey = Object.keys(loadedModule).find(key => key.endsWith('_DEF'));
    return defKey ? loadedModule[defKey] : null;
}


--- FILE: index.html ---

<!DOCTYPE html>
<html lang="en">
    <head>
        <title>PREMEC - Administración</title>
        <meta charset="utf-8">
        <meta name="description" content="Administrador de Contenidos de PREMEC">
        <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1.0, minimum-scale=1.0">

        <base href="/">
        
        <link rel="icon" type="image/png" href="https://premecsa.com.ar/wp-content/uploads/2018/05/logo-pestan%CC%83a-01.png">

        <link href="assets/fonts/inter/inter.css" rel="stylesheet">
        <link href="https://fonts.gstatic.com" rel="preconnect">
        <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:ital,wght@0,400;0,500;0,600;1,400&amp;display=swap" rel="stylesheet">
        <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
        <link href="assets/styles/splash-screen.css" rel="stylesheet">
        <link href="assets/styles/style.css" rel="stylesheet">
    </head>

    <body>
        <fuse-splash-screen>
            <img src="https://premecsa.com.ar/wp-content/uploads/2018/05/logo-pestan%CC%83a-01.png" alt="Fuse logo">
            <div class="spinner">
                <div class="bounce1"></div>
                <div class="bounce2"></div>
                <div class="bounce3"></div>
            </div>
        </fuse-splash-screen>

        <app-root></app-root>
</body></html>

--- FILE: main.ts ---

import { bootstrapApplication } from '@angular/platform-browser';
import { AppComponent } from 'app/app.component';
import { appConfig } from 'app/app.config';

bootstrapApplication(AppComponent, appConfig)
    .catch(err => console.error(err));


--- FILE: vite-env.d.ts ---

/// <reference types="vite/client" />